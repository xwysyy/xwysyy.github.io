<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>xwysyy Algorithm | 善良的xwysyy</title><meta name="author" content="善良的xwysyy"><meta name="copyright" content="善良的xwysyy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础算法 贪心 codeforces1779C Least Prefix Sum  题意：给定n个数，每次修改可以让一个数乘以-1，求最少操作次数使得前m个数的和是所有前缀和中最小的。m≤n ≤200000 &#x3D;&#x3D;即前m个数的后缀和不大于0,1到m和可以大于0,m+1到n个数的前缀和不小0.&#x3D;&#x3D;  codeforces1768C Elemental Decompress  给定一个序列p，请构造两个">
<meta property="og:type" content="article">
<meta property="og:title" content="xwysyy Algorithm">
<meta property="og:url" content="https://vercel.xwysyy.cn/algorithm/xwysyy%20Algorithm/index.html">
<meta property="og:site_name" content="善良的xwysyy">
<meta property="og:description" content="基础算法 贪心 codeforces1779C Least Prefix Sum  题意：给定n个数，每次修改可以让一个数乘以-1，求最少操作次数使得前m个数的和是所有前缀和中最小的。m≤n ≤200000 &#x3D;&#x3D;即前m个数的后缀和不大于0,1到m和可以大于0,m+1到n个数的前缀和不小0.&#x3D;&#x3D;  codeforces1768C Elemental Decompress  给定一个序列p，请构造两个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vercel.xwysyy.cn/image/img-background/2.jpg">
<meta property="article:published_time" content="2023-04-01T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-29T07:35:52.369Z">
<meta property="article:author" content="善良的xwysyy">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vercel.xwysyy.cn/image/img-background/2.jpg"><link rel="shortcut icon" href="/img/%E5%A4%B4%E5%83%8F.png"><link rel="canonical" href="https://vercel.xwysyy.cn/algorithm/xwysyy%20Algorithm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":20,"languages":{"author":"作者: 善良的xwysyy","link":"链接: ","source":"来源: 善良的xwysyy","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'xwysyy Algorithm',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-29 15:35:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="/js/echarts.min.js"></script><link rel="stylesheet" type="text/css" href="/css/asidefloat.css"><link rel="stylesheet" type="text/css" href="/css/mystyle.css"><link rel="stylesheet" type="text/css" href="/css/console.css"><link rel="stylesheet" type="text/css" href="/css/double_row.css"><link rel="stylesheet" href="/css/essay_page.css"><link rel="stylesheet" href="/css/todolist.css"><link rel="stylesheet" href="/css/guanyv.css"><link rel="stylesheet" href="/css/weibo.css"><style id="settingStyle"></style><style id="yjjs"></style><style id="themeColor"></style><link rel="stylesheet" type="text/css" href="css/_custom/heoMainColor.css"><link rel="stylesheet" type="text/css" href="css/_custom/categoryBar.css"><script async src="/js/categoryBar.js"></script><link rel="stylesheet" type="text/css" href="css/404.css"><script type="text/javascript" src="js/jquery.min.js"></script><link rel="stylesheet" href="/css/records.css"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3FeErm4Qj3nJOxIa",ck:"3FeErm4Qj3nJOxIa"})</script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="/css/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/log/"><i class="fa-fw fas fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://uptime-kuma.xwysyy.cn/status/monitor"><i class="fa-fw fas fa-shield-alt"></i><span> 监控</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-file-alt"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-chart-area"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li><li><a class="site-page child" href="/ToDoList/"><i class="fa-fw fas fa-bell"></i><span> 待办</span></a></li><li><a class="site-page child" href="/records/"><i class="fa-fw fas fa-comments"></i><span> 文字瞬间</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page child" href="/friends/"><i class="fa-fw fas fa-user-friends"></i><span> 鱼塘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Fireworks"><i class="fa-fw fa fa-fire"></i><span> 烟花</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/reference"><i class="fa-fw fa fa-code"></i><span> 参考</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about-chat/"><i class="fa-fw fas fa-comment"></i><span> 交互版</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-envelope"></i><span> 静态版</span></a></li><li><a class="site-page child" href="/essay/"><i class="fa-fw fas fa-edit"></i><span> 杂谈</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><div id="console"><div class="close-btn" onclick="heo.hideConsole()" href="javascript:void(0);"><i class="fas fa-circle-xmark"></i></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="heo.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最近评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="heo.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><span class="author-content-item-title">寻找感兴趣的领域</span></div><div class="card-tag-cloud"><a href="/tags/CPP/" style="font-size: 1em; color: #d3d3d3">CPP</a> <a href="/tags/CSS/" style="font-size: 1em; color: #d3d3d3">CSS</a> <a href="/tags/ChatGPT/" style="font-size: 1em; color: #d3d3d3">ChatGPT</a> <a href="/tags/Git/" style="font-size: 1em; color: #d3d3d3">Git</a> <a href="/tags/HTML/" style="font-size: 1em; color: #d3d3d3">HTML</a> <a href="/tags/JavaScript/" style="font-size: 1em; color: #d3d3d3">JavaScript</a> <a href="/tags/LaTeX/" style="font-size: 1em; color: #d3d3d3">LaTeX</a> <a href="/tags/MySQL/" style="font-size: 1em; color: #d3d3d3">MySQL</a> <a href="/tags/Python/" style="font-size: 1em; color: #d3d3d3">Python</a> <a href="/tags/Sublime-Text/" style="font-size: 1em; color: #d3d3d3">Sublime Text</a> <a href="/tags/Typora/" style="font-size: 1em; color: #d3d3d3">Typora</a> <a href="/tags/ai/" style="font-size: 1em; color: #d3d3d3">ai</a> <a href="/tags/algorithm/" style="font-size: 1em; color: #d3d3d3">algorithm</a> <a href="/tags/course/" style="font-size: 1em; color: #d3d3d3">course</a> <a href="/tags/project/" style="font-size: 1em; color: #d3d3d3">project</a> <a href="/tags/syntax/" style="font-size: 1em; color: #d3d3d3">syntax</a> <a href="/tags/tutorial/" style="font-size: 1em; color: #d3d3d3">tutorial</a></div></div><div class="console-card history" onclick="heo.hideConsole()"> </div></div></div><div class="button-group"><div class="console-btn-item"> <a class="darkmode_switchbutton" onclick="rm.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="fas fa-moon" style="font-size: 1rem;"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="heo.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="fas fa-arrows-alt-h"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="heo.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="fas fa-keyboard"></i></a></div><div class="console-btn-item" id="assist-open" onclick="heo.hideConsole()" title="无障碍工具栏"><a class="assist-btn"><i class="fas fa-wheelchair"></i></a></div><div class="console-btn-item" id="consoleCommentBarrage" onclick="heo.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="fa-solid fa-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="heo.musicToggle()" title="音乐开关"><a class="music-switch"><i class="fas fa-music"></i></a></div></div><div class="console-mask" onclick="heo.hideConsole()" href="javascript:void(0);"></div></div><header class="post-bg" id="page-header" style="background-image: url('/image/img-background/2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="善良的xwysyy"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.png"/><span class="site-name">善良的xwysyy</span></a></span><div id="none_space"></div><div class="mask-name-container"><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)">PAGE_NAME</a></center></div><div id="menus"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon fas fa-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">主页</div><div class="back-menu-list"><a class="back-menu-item" href="https://index.xwysyy.cn" title="xwysyy主页" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/%E5%A4%B4%E5%83%8F.jpg"/><span class="back-menu-item-text">xwysyy主页</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客线路</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.xwysyy.cn" title="腾讯云线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube1.png"/><span class="back-menu-item-text">腾讯云主线路</span></a><a class="back-menu-item" href="https://vercel.xwysyy.cn" title="Vercel线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube2.png"/><span class="back-menu-item-text">Vercel线路</span></a><a class="back-menu-item" href="https://www.xwysyy.life" title="Github线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube4.png"/><span class="back-menu-item-text">Github线路</span></a><a class="back-menu-item" href="https://netlify.xwysyy.cn" title="Netlify线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube5.png"/><span class="back-menu-item-text">Netlify线路</span></a><a class="back-menu-item" href="https://xwysyy.pages.dev" title="Cloudflare线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube6.png"/><span class="back-menu-item-text">Cloudflare线路</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">部署项目</div><div class="back-menu-list"><a class="back-menu-item" href="https://pan.xwysyy.cn" title="xwysyy云盘" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube7.png"/><span class="back-menu-item-text">xwysyy云盘</span></a><a class="back-menu-item" href="https://cube.xwysyy.cn" title="Lijz的魔方小站" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube9.png"/><span class="back-menu-item-text">Lijz的魔方小站</span></a><a class="back-menu-item" href="https://chatgpt.xwysyy.cn" title="xwysyy ChatGPT" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube13.png"/><span class="back-menu-item-text">xwysyy ChatGPT</span></a></div></div></div></div><div class="nav-button" id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn"><i class="fas fa-arrow-up"></i><span id="percent" onclick="btf.scrollToDest(0,500)"> </span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/log/"><i class="fa-fw fas fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://uptime-kuma.xwysyy.cn/status/monitor"><i class="fa-fw fas fa-shield-alt"></i><span> 监控</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-file-alt"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-chart-area"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li><li><a class="site-page child" href="/ToDoList/"><i class="fa-fw fas fa-bell"></i><span> 待办</span></a></li><li><a class="site-page child" href="/records/"><i class="fa-fw fas fa-comments"></i><span> 文字瞬间</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page child" href="/friends/"><i class="fa-fw fas fa-user-friends"></i><span> 鱼塘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Fireworks"><i class="fa-fw fa fa-fire"></i><span> 烟花</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/reference"><i class="fa-fw fa fa-code"></i><span> 参考</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about-chat/"><i class="fa-fw fas fa-comment"></i><span> 交互版</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-envelope"></i><span> 静态版</span></a></li><li><a class="site-page child" href="/essay/"><i class="fa-fw fas fa-edit"></i><span> 杂谈</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">xwysyy Algorithm</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-01T16:00:00.000Z" title="发表于 2023-04-02 00:00:00">2023-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-29T07:35:52.369Z" title="更新于 2023-09-29 15:35:52">2023-09-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/algorithm/">algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6849</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="xwysyy Algorithm"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>基础算法</h1>
<h2 id="贪心">贪心</h2>
<p>codeforces1779C Least Prefix Sum</p>
<blockquote>
<p>题意：给定n个数，每次修改可以让一个数乘以-1，求最少操作次数使得前m个数的和是所有前缀和中最小的。m≤n ≤200000<br>
==即前m个数的后缀和不大于0,1到m和可以大于0,m+1到n个数的前缀和不小0.==</p>
</blockquote>
<p>codeforces1768C Elemental Decompress</p>
<blockquote>
<p>给定一个序列p，请构造两个排列a,b，使得pi=max(ai,bi)可能无解。n&lt;=200000</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6033">P6033  合并果子加强版</a></p>
<blockquote>
<p>桶排序+双队列优化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t,m,n,sum,arr[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;p,q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123; </span><br><span class="line">	ll f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> s=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">&#x27;0&#x27;</span>||s&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(s==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;s=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">&#x27;0&#x27;</span>;s=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tem;</span><br><span class="line">	<span class="keyword">if</span>(p.<span class="built_in">empty</span>()||(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;p.<span class="built_in">front</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		tem=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		tem=p.<span class="built_in">front</span>();</span><br><span class="line">		p.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(m);</span><br><span class="line">	    arr[m]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++)<span class="keyword">while</span>(arr[i]--)q.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="built_in">merge</span>(),b=<span class="built_in">merge</span>();</span><br><span class="line">		sum+=a+b;</span><br><span class="line">		p.<span class="built_in">push</span>(a+b);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搜索">搜索</h2>
<h3 id="dfs">dfs</h3>
<p>单调队列</p>
<h3 id="bfs">bfs</h3>
<p>递归</p>
<h4 id="八数码问题">八数码问题</h4>
<p>##异或前缀和</p>
<h1>数论</h1>
<h2 id="gcd-lcm">gcd&amp;lcm</h2>
<h3 id="gcd">gcd</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span><span class="comment">//最大公因数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v?<span class="built_in">gcd</span>(v,u%v):u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者stl</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__gcd(u,v);</span><br></pre></td></tr></table></figure>
<h3 id="lcm">lcm</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span><span class="comment">//最小公倍数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u*v/<span class="built_in">gcd</span>(u,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exgcd-扩展欧几里得算法">exgcd (扩展欧几里得算法)</h2>
<blockquote>
<p>用来解决:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">gcd(a,b)=ax+by</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><br>
其中系数x和y的求解  此处ab均大于0  显然正负可以由系数决定</p>
</blockquote>
<blockquote>
<p>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">ax+by=d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>,当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mi>k</mi><mo>∗</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d=k*gcd(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>时候有解  解为（kx，ky）<br>
设该方程的一个解为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0,y_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo>−</mo><mi>k</mi><mo>∗</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>b</mi><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mfrac></mstyle><mo separator="true">,</mo><msub><mi>y</mi><mn>0</mn></msub><mo>+</mo><mi>k</mi><mo>∗</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>a</mi><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mfrac></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0-k*\dfrac{b}{gcd(a,b)},y_0+k*\dfrac{a}{gcd(a,b)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.3074em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0436em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>也为该方程的一个解<br>
k为任意整数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prime-number-素数">Prime number(素数)</h2>
<h3 id="处理因子的方法">处理因子的方法</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=x;i++)<span class="comment">//x为处理的数,cnt记录因子出现的次数,num记录有多少个因子</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(x%i))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;=m)<span class="comment">//m为限定的因子范围</span></span><br><span class="line">			&#123;</span><br><span class="line">				cnt[i]++;</span><br><span class="line">				<span class="keyword">if</span>(cnt[i]==<span class="number">1</span>)num++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(x/i&lt;=m&amp;&amp;i*i!=x)</span><br><span class="line">			&#123;</span><br><span class="line">				cnt[x/i]++;</span><br><span class="line">				<span class="keyword">if</span>(cnt[x/i]==<span class="number">1</span>)num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=M;j+=i)</span><br><span class="line">        arr[j].<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>
<p>质因子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (x%i==<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        p.<span class="built_in">push_back</span>(i);</span><br><span class="line">        x/=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="埃氏筛">埃氏筛</h3>
<p>一般使用埃氏筛就足够了,不会卡时间<br>
时间复杂度O(nlog(logn))</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 666</span></span><br><span class="line"><span class="type">bool</span> notprime[N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(notprime[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;=N;j+=i)notprime[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线性筛-修">线性筛(修)</h3>
<p>时间复杂度O(n)</p>
<blockquote>
<p>枚举每个合数的最小因子<br>
pri[i]是最小质数, i是合数/最小质数的值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 666</span></span><br><span class="line"><span class="type">int</span> pri[N],pp;</span><br><span class="line"><span class="type">bool</span> gg[<span class="number">5</span>+N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!gg[i])pri[++pp]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pp;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll t=i*pri[j];</span><br><span class="line">            <span class="keyword">if</span>(t&gt;N)<span class="keyword">break</span>;</span><br><span class="line">            gg[t]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%pri[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="乘法快速幂">乘法快速幂</h2>
<p>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>u</mi><mi>v</mi></msup></mrow><annotation encoding="application/x-tex">u^v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> m 1000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="function">ll <span class="title">po</span><span class="params">(ll u,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v&amp;<span class="number">1</span>) res=res*u%m;</span><br><span class="line">	    u=u*u%m;<span class="comment">//取模的话,int容易溢出,加上1ll</span></span><br><span class="line">        v&gt;&gt;=<span class="number">1</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逆元">逆元</h2>
<p>在模m下的倒数,可以用exgcd,费马小定理求解</p>
<p>费马小定理:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>p</mi></msup><mo>≡</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^p≡ a(mod m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>≡</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^{p-2} ≡ a^{-1}(mod m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><br>
见<a href="#%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E4%B9%98">预处理阶乘</a></p>
<h2 id="组合数-可能需要取模">组合数(可能需要取模)</h2>
<h3 id="杨辉三角">杨辉三角</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;i++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">       c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>]); </span><br><span class="line">        <span class="comment">//c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;</span></span><br></pre></td></tr></table></figure>
<h3 id="预处理阶乘">预处理阶乘</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>u</mi><mi>v</mi></msubsup><mo>=</mo><mfrac><mrow><mi>u</mi><mo stretchy="false">!</mo></mrow><mrow><mi>v</mi><mo stretchy="false">!</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>u</mi><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">C^v_u=\frac {u!} {v!*(u-v)!}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9303em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4001em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">!</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<blockquote>
<p>预处理出每个数的阶乘和每个数阶乘的逆元</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fac存储阶乘,inv存储阶乘的逆元</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MN 1000</span></span><br><span class="line">ll fac[MN+<span class="number">5</span>],inv[MN+<span class="number">5</span>];</span><br><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=MN;i++)fac[i]=fac[i<span class="number">-1</span>]*i%M;</span><br><span class="line">inv[MN]=<span class="built_in">po</span>(fac[MN],M<span class="number">-2</span>);<span class="comment">//po为乘法快速幂</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=MN<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%M</span><br></pre></td></tr></table></figure>
<h2 id="排列数">排列数</h2>
<h3 id="全排列组合">全排列组合</h3>
<blockquote>
<p><strong>next_permutation</strong>这个函数可以把一个序列进行全排列,其返回值是一个bool,如果还存在下一个排列方式就对序列进行更改并返回true,该函数还接受第二个参数传入一个自定义的compare函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get_permutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;ans)</span>	<span class="comment">//返回的是排列数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());	<span class="comment">//先进行排序 保证从升序开始</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(arr);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>()));	<span class="comment">//全排列函数</span></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全错位排列">全错位排列</h3>
<blockquote>
<p>递推公式为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>D</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>D</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D_n=(n-1)(D_{n-1}+D_{n-2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">all_dislocation_arr</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d1=<span class="number">0</span>,d2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> d1;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> d2;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(i<span class="number">-1</span>)*(d2+d1);</span><br><span class="line">        d1=d2;</span><br><span class="line">        d2=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="卡特兰数">卡特兰数</h2>
<blockquote>
<p>1, 1, 2, 5, 14, 42, 132, 429, 1430…</p>
</blockquote>
<blockquote>
<p>卡特兰数相关公式</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>n</mi></msub><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle><mo>=</mo><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mo>−</mo><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">H_n=\dfrac{C_{2n}^n}{n+1}=C_{2n}^n-C_{2n}^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1205em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8542em;"><span style="top:-2.4337em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>n</mi></msub><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mn>4</mn><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle><mo>∗</mo><msub><mi>H</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>  </mtext><mtext>  </mtext><msub><mi>H</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">H_n=\dfrac{4n-2}{n+1}*H_{n-1}\;\;H_{0,1}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>n</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>H</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>H</mi><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow></msub><mtext>  </mtext><mo stretchy="false">(</mo><mi>n</mi><mo>&gt;</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext><mtext>  </mtext><mtext>  </mtext><msub><mi>H</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">H_n=\sum_{i=1}^nH_{i-1}H_{n-i}\;(n\gt1)\;\;\;\;H_{0,1}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
</ol>
</blockquote>
<h3 id="公式求解">公式求解</h3>
<blockquote>
<p>利用公式 1 <strong>直接求</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">catalan</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//此处的组合数可以用杨辉三角或者直接求得</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(<span class="number">2</span>*n,n)/(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递推求解">递推求解</h3>
<blockquote>
<p>利用公式2</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">catalan</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> cat=<span class="number">1</span>;	<span class="comment">//第0项</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cat=cat*(<span class="number">4</span>*i<span class="number">-2</span>)/(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度卡特兰数">高精度卡特兰数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">catalan</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C=<span class="built_in">getC</span>(<span class="number">2</span>*n,n);	<span class="comment">//因为div的原型是A和r都是引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">div</span>(C,n+<span class="number">1</span>,n);	<span class="comment">//公式1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="星期x">星期x</h2>
<blockquote>
<p>Kim Iarsen 公式</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mn>2</mn><mi>m</mi><mo>+</mo><mn>3</mn><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>5</mn><mo>+</mo><mi>y</mi><mo>+</mo><mi>y</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>−</mo><mi>y</mi><mi mathvariant="normal">/</mi><mn>100</mn><mo>+</mo><mi>y</mi><mi mathvariant="normal">/</mi><mn>400</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mn>7</mn></mrow><annotation encoding="application/x-tex">W=(d+2m+3(m+1)/5+y+y/4-y/100+y/400+1)\;mod\;7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">/4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">/100</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">/400</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">7</span></span></span></span></p>
<p>其中特别的,该公式把1月和2月看作是13月和14月</p>
<p>0-6 对应的是星期日-星期六</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> string week_day[]=&#123;<span class="string">&quot;Sun&quot;</span>,<span class="string">&quot;Mon&quot;</span>,<span class="string">&quot;Tue&quot;</span>,<span class="string">&quot;Wed&quot;</span>,<span class="string">&quot;Thu&quot;</span>,<span class="string">&quot;Fri&quot;</span>,<span class="string">&quot;Sat&quot;</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">get_week</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;<span class="number">0</span>||m&lt;<span class="number">1</span>||m&gt;<span class="number">12</span>||d&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">&quot;wrong day&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>||m==<span class="number">3</span>||m==<span class="number">5</span>||m==<span class="number">7</span>||m==<span class="number">8</span>||m==<span class="number">10</span>||m==<span class="number">12</span>)&#123;<span class="keyword">if</span>(d&gt;<span class="number">31</span>)<span class="keyword">return</span> <span class="string">&quot;wrong day&quot;</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">100</span>!=<span class="number">0</span>)||y%<span class="number">400</span>==<span class="number">0</span>)&#123;<span class="keyword">if</span>(d&gt;<span class="number">29</span>)<span class="keyword">return</span> <span class="string">&quot;wrong day&quot;</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d&gt;<span class="number">28</span>)<span class="keyword">return</span> <span class="string">&quot;wrong day&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d&gt;<span class="number">30</span>)<span class="keyword">return</span> <span class="string">&quot;wrong day&quot;</span>;</span><br><span class="line">    m&lt;<span class="number">3</span>?m+=<span class="number">12</span>,y--:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> week_day[(d+<span class="number">2</span>*m+<span class="number">3</span>*(m+<span class="number">1</span>)/<span class="number">5</span>+y+y/<span class="number">4</span>-y/<span class="number">100</span>+y/<span class="number">400</span>+<span class="number">1</span>)%<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>动态规划</h1>
<blockquote>
<p>==<strong>在一个困难的嵌套决策链中，决策出最优解</strong>==</p>
</blockquote>
<blockquote>
<p>==<strong>现在决定未来，未来与过去无关</strong>==</p>
<blockquote>
<p><span style="background-color:orange"><strong>无后效性</strong>，即每个当前状态会且仅会决策出下一状态，而不直接对未来的所有状态负责</span></p>
</blockquote>
</blockquote>
<h2 id="背包dp">背包dp</h2>
<h3 id="01背包">01背包</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>01背包bitset优化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;N+1&gt;dp&#123;&#125;;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  cin&gt;&gt;x;</span><br><span class="line">  dp|=dp&lt;&lt;x;</span><br><span class="line">  sum+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=sum;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(dp[i])</span><br><span class="line">    ans=......;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全背包">完全背包</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包-二进制优化">多重背包(二进制优化)</h3>
<blockquote>
<p>给定N个物品，其中第i个物品的体积为Vi，价值为Wi，并且有Ci个。有一容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//多重背包</span></span><br><span class="line">&#123;<span class="comment">//d为数量,m为总体积,v为单个体积</span></span><br><span class="line">   	<span class="keyword">if</span>(d*v&gt;m)<span class="comment">//是否为完全背包</span></span><br><span class="line">   	<span class="keyword">for</span>(<span class="type">int</span> j=v;j&lt;=m;j++)</span><br><span class="line">   	dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v]+w);</span><br><span class="line">   	<span class="keyword">else</span> </span><br><span class="line">     &#123;<span class="comment">//二进制优化</span></span><br><span class="line">	    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=d;j*=<span class="number">2</span>)</span><br><span class="line">   	    &#123;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="type">int</span> z=m;z&gt;=v*j;z--)</span><br><span class="line">   	        dp[z]=<span class="built_in">max</span>(dp[z],dp[z-v*j]+w*j);</span><br><span class="line">   	        d-=j;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span>(d&gt;<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v*d;j--)</span><br><span class="line">         dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v*d]+w*d);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组背包">分组背包</h3>
<blockquote>
<p>给定N个物品，其中第i个组有Ci个物品。第i组的第j个物品的体积为Vij，价值为Wij。有一容积为M的背包，要求选择一些物品放入背包，使得每组至多选择一个物品并且总体积不超过M的前提下，物品的价值总和最大。<br>
01背包转移时，状态由上一个物品转移而来; ==而分组背包状态则由上一组转移而来==</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=c[i];k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i][k])</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i][k]]+w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旅行商的背包"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1782">旅行商的背包</a></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10004</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,m,c,v,w,d,dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">   cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">   cin&gt;&gt;n&gt;&gt;m&gt;&gt;c;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//多重背包</span></span><br><span class="line">   &#123;</span><br><span class="line">   	cin&gt;&gt;v&gt;&gt;w&gt;&gt;d;</span><br><span class="line">   	<span class="keyword">if</span>(d*v&gt;c)<span class="comment">//是否为完全背包</span></span><br><span class="line">   	<span class="keyword">for</span>(<span class="type">int</span> j=v;j&lt;=c;j++)</span><br><span class="line">   	dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v]+w);</span><br><span class="line">   	<span class="keyword">else</span> </span><br><span class="line">     &#123;<span class="comment">//二进制优化</span></span><br><span class="line">	    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=d;j*=<span class="number">2</span>)</span><br><span class="line">   	    &#123;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="type">int</span> z=c;z&gt;=v*j;z--)</span><br><span class="line">   	        dp[z]=<span class="built_in">max</span>(dp[z],dp[z-v*j]+w*j);</span><br><span class="line">   	        d-=j;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span>(d&gt;<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=c;j&gt;=v*d;j--)</span><br><span class="line">         dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v*d]+w*d);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   	cin&gt;&gt;v&gt;&gt;w&gt;&gt;d;</span><br><span class="line">   	<span class="keyword">for</span>(<span class="type">int</span> j=c;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">   	<span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">0</span>;z&lt;=j;z++)<span class="comment">//完全背包</span></span><br><span class="line">   	dp[j]=<span class="built_in">max</span>(dp[j],dp[j-z]+(v*z+w)*z+d);</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;dp[c]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正整数划分">正整数划分</h3>
<blockquote>
<p>给定两个正整数n,m，求满足b1+b2+b3…+bm=n的序列个数, bi是正整数, 答案对998244353取模</p>
</blockquote>
<blockquote>
<p>可以记<code>dp[i][j]</code>表示将i划分为j个正整数之和的方案数然后枚举第j+1个数填多少，比如填k则<code>dp[i+k][j+1]+=dp[i][j]</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;i+k&lt;=n;k++)</span><br><span class="line">      &#123;</span><br><span class="line">          dp[i+k][j+<span class="number">1</span>]+=dp[i][j];</span><br><span class="line">          dp[i+k][j+<span class="number">1</span>]%=<span class="number">9982445353</span>;</span><br><span class="line">      &#125;</span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给定一个正整数n，求满足b1+b2+b3…+bk=n且1&lt;=b1&lt;=b2&lt;=b3….&lt;=bk的序列个数（k为任意值）答案对998244353取模</p>
</blockquote>
<blockquote>
<p>令<code>dp[i][j]</code>表示和为i，最大的数不超过j的方案数则<code>dp[i][j]=dp[i-j][j]+dp[i][j-1]</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][j]=dp[i-j][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">        dp[i][j]%=<span class="number">998244353</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    dp[i][j]=dp[i][j-1];</span></span><br><span class="line"><span class="comment">    if(i&gt;=j)dp[i][j]+=dp[i-j][j];</span></span><br><span class="line"><span class="comment">    dp[i][j]%=998244353;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;dp[n][n]&lt;&lt;endl;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>最简单的做法是把它看作一个完全背包、每个数都看作一个物品</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j]+=dp[j-i];</span><br><span class="line">        dp[j]%=<span class="number">998244353</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h2 id="LCS-最长公共子序列">LCS(最长公共子序列)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sring s,p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j])dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[n][n]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h2 id="LIS-最长上升子序列">LIS(最长上升子序列)</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i]=<span class="number">1</span>;<span class="comment">//初始化 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)<span class="comment">//枚举i之前的每一个j </span></span><br><span class="line">		<span class="keyword">if</span>(a[j]&lt;a[i])</span><br><span class="line">		dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);<span class="comment">//更新最优状态 </span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[len]&lt;a[i])</span><br><span class="line">        dp[++len]=a[i];</span><br><span class="line">    <span class="keyword">else</span> *<span class="built_in">lower_bound</span>(dp+<span class="number">1</span>,dp+len+<span class="number">1</span>,a[i])=a[i];</span><br><span class="line">    <span class="comment">/* l=0,r=len;</span></span><br><span class="line"><span class="comment">       while(l&lt;r)</span></span><br><span class="line"><span class="comment">		&#123;	</span></span><br><span class="line"><span class="comment">		    mid=(l+r)/2;</span></span><br><span class="line"><span class="comment">		    if(f[mid]&gt;a[i])r=mid;</span></span><br><span class="line"><span class="comment">			else l=mid+1; </span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		dp[l]=min(a[i],dp[l]);//更新最小末尾 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1439">P1439 最长公共子序列</a></p>
<blockquote>
<p>由lcs转化为lis,体现一种映射关系,上升数列的公共子序列必是上升的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;ll,ll&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1111111111111111111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll t,m,n,a[N],b[N],dp[N],x,len;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">   cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">   cin&gt;&gt;t;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   	cin&gt;&gt;x;</span><br><span class="line">   	a[x]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   	cin&gt;&gt;b[i];</span><br><span class="line">   	<span class="keyword">if</span>(dp[len]&lt; a[b[i]])</span><br><span class="line">   	dp[++len]=a[b[i]];</span><br><span class="line">   	<span class="keyword">else</span> *<span class="built_in">lower_bound</span>(dp+<span class="number">1</span>,dp+len+<span class="number">1</span>,a[b[i]])=a[b[i]];</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形dp">树形dp</h2>
<h3 id="树形背包">树形背包</h3>
<blockquote>
<p>给定N个物品，其中第i个物品的体积为Vi，价值为Wi。物品之间存在依赖关系，即如果要选择第i个物品，可能必须先选择第fi个物品。有一容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大。</p>
</blockquote>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mi>m</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll p=head[now];p;p=e[p].next)</span><br><span class="line">    &#123;</span><br><span class="line">        ll to=e[p].to;</span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">        <span class="keyword">for</span>(ll j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;<span class="comment">//这里类似于多重背包</span></span><br><span class="line">            <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=j;k++)</span><br><span class="line">                dp[now][j]=<span class="built_in">max</span>(dp[now][j],dp[now][j-k]+dp[to][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=m;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=v[now])dp[now][i]=dp[now][i-v[now]]+val[now];</span><br><span class="line">        <span class="keyword">else</span> dp[now][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[now][v[now]]=val[now];</span><br><span class="line">    <span class="keyword">for</span>(ll p=head[now];p;p=e[p].next)</span><br><span class="line">    &#123;</span><br><span class="line">        ll to=e[p].to;</span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">        <span class="keyword">for</span>(ll j=m;j&gt;=v[now];j--)</span><br><span class="line">        &#123;<span class="comment">//这里类似于多重背包</span></span><br><span class="line">            <span class="keyword">for</span>(ll k=<span class="number">0</span>;k+v[now]&lt;=j;k++)</span><br><span class="line">                dp[now][j]=<span class="built_in">max</span>(dp[now][j],dp[now][j-k]+dp[to][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给定N个物品，其中第i个物品的体积为1，价值为Wi。物品之间存在依赖关系，即如果要选择第i个物品，可能必须先选择第fi个物品。有一容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大。</p>
</blockquote>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>(跟LCA有关)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	v[now]=<span class="number">1</span>;</span><br><span class="line">    dp[now][<span class="number">1</span>]=val[now];</span><br><span class="line">     <span class="keyword">for</span>(ll p=head[now];p;p=e[p].next)</span><br><span class="line">     &#123;</span><br><span class="line">         ll to=e[p].to;</span><br><span class="line">         <span class="built_in">dfs</span>(to);</span><br><span class="line">         <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=v[now];i++)</span><br><span class="line">         &#123;<span class="comment">//和上面表示的方法不一样</span></span><br><span class="line">             <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=v[to];j++)</span><br><span class="line">                 tmp[i+j]=<span class="built_in">max</span>(tmp[i+j],dp[now][i]+dp[to][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         v[now]+=v[to];</span><br><span class="line">         <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=v[now];i++)dp[now][i]=tmp[i],tmp[i]=<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mi>m</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[now][<span class="number">1</span>]=val[now];</span><br><span class="line">	<span class="keyword">for</span>(ll p=head[now];p;p=e[now].next)</span><br><span class="line">	&#123;</span><br><span class="line">		ll to=e[p].to;</span><br><span class="line">		<span class="built_in">dfs</span>(to);</span><br><span class="line">		<span class="keyword">for</span>(ll i=m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[x][i]=<span class="built_in">max</span>(dp[x][i],dp[x][i-j]+dp[to][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树形dp-2">树形dp</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;ll,ll&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1111111111111111111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 6007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll t,m,n,arr[N],p,q,vis[N],root,dp[N][<span class="number">2</span>];</span><br><span class="line">string s;</span><br><span class="line">vector&lt;ll&gt;e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	dp[x][<span class="number">1</span>]=arr[x];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y);</span><br><span class="line">		dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[y][<span class="number">0</span>],dp[y][<span class="number">1</span>]);</span><br><span class="line">		dp[x][<span class="number">1</span>]+=dp[y][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">   cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   	cin&gt;&gt;p&gt;&gt;q;</span><br><span class="line">   	e[q].<span class="built_in">push_back</span>(p);</span><br><span class="line">   	vis[p]=<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   	<span class="keyword">if</span>(!vis[i])<span class="comment">//找根</span></span><br><span class="line">   	&#123;</span><br><span class="line">   		root=i;</span><br><span class="line">   		<span class="keyword">break</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">dfs</span>(root);</span><br><span class="line">   cout&lt;&lt;<span class="built_in">max</span>(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>==<strong>拓扑排序解法</strong>==</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> happy[<span class="number">6005</span>];</span><br><span class="line"><span class="type">int</span> ru[<span class="number">6005</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">6005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">6005</span>][<span class="number">2</span>]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;happy[i]); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>&amp;&amp;b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ru[b]++;</span><br><span class="line">        fa[a] = b;</span><br><span class="line">    &#125; </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ru[i] == <span class="number">0</span>)<span class="comment">//找根</span></span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxn = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//bfs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        dp[u][<span class="number">1</span>] += happy[u];</span><br><span class="line">        maxn = <span class="built_in">max</span>(dp[u][<span class="number">1</span>],maxn);</span><br><span class="line">        maxn = <span class="built_in">max</span>(dp[u][<span class="number">0</span>],maxn);</span><br><span class="line">        ru[fa[u]] --;</span><br><span class="line">        <span class="keyword">if</span>(ru[fa[u]] == <span class="number">0</span>)</span><br><span class="line">        q.<span class="built_in">push</span>(fa[u]); </span><br><span class="line">        dp[fa[u]][<span class="number">0</span>] = <span class="built_in">max</span>(dp[fa[u]][<span class="number">0</span>] + dp[u][<span class="number">0</span>],dp[fa[u]][<span class="number">0</span>] + dp[u][<span class="number">1</span>]);</span><br><span class="line">        dp[fa[u]][<span class="number">1</span>] += dp[u][<span class="number">0</span>] &gt;= <span class="number">0</span> ? dp[u][<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,maxn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="换根dp-修">换根dp(修)</h3>
<ul>
<li>hdu 2196: 求取一颗无根树上每一个节点，到树上其余任意节点的最远距离</li>
</ul>
<p>==<strong>dfs</strong>==</p>
<blockquote>
<p>利用树的直径的性质，假设树的直径的两个端点为 A 与 B, 那么树上任意节点C到树上其余任何节点的最远距离一定是C-&gt;A或者是C-&gt;B<br>
利用这个性质，我们只需利用3次dfs，第一次是为了求取直径的A端点, 第二次是为了求取其余所有点到A端点的距离，顺便可以求取B端点, 最后可以再求取一次所有点到B端点的距离</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll now,ll fa,ll dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[now]=<span class="built_in">max</span>(ans[mow],dep);</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;maxn)maxn=dep,pos=now;</span><br><span class="line">    <span class="keyword">for</span>(ll i=head[now];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        ll to=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to,now,dep+e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">maxn=<span class="number">-1</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">maxn=<span class="number">-1</span>,<span class="built_in">dfs</span>(pos,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs</span>(pos,<span class="number">-1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>==<strong>换根dp</strong>==</p>
<blockquote>
<p>现在转化成有根的情况，我们以1号节点为根节点，并进行一次dfs那么对于每个点只有两种情况1.向他的子树中走，这是可以通过dfs求出的2.向他的爸爸走，这种情况比较复杂</p>
<p>如果他向他的爸爸走，那么又可以分为两种情况：1.他向他的爷爷走2.他向他的兄弟走对于第一种情况，我们不妨在dfs过程中用up表示每个点向他爸爸走最多可以走多远<code>dis[i]=max(dis[i],up[fa[i]]+len)</code>, 对于第二种情况，则需处理出他爸爸向下走的最长链和次长链二者结合即可得到up值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll t,n,m,ans[N],mx[N],son[N],m2[N];</span><br><span class="line">vector&lt;ll&gt;to[N],len[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll now,ll last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;to[now].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll t=to[now][i],tmp;</span><br><span class="line">		<span class="keyword">if</span>(t==last)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(t,now);</span><br><span class="line">		tmp=len[now][i]+mx[t];</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;mx[now])m2[now]=mx[now],mx[now]=tmp,son[now]=t;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tmp&gt;m2[now])m2[now]=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(ll now,ll last,ll up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans[now]=<span class="built_in">max</span>(mx[now],up);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;to[now].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll t=to[now][i],tmp;</span><br><span class="line">		<span class="keyword">if</span>(t==last)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(t,now,<span class="built_in">max</span>(up,t==son[now]?m2[now]:mx[now])+len[now][i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		ll p,q;</span><br><span class="line"> 		cin&gt;&gt;p&gt;&gt;q;</span><br><span class="line"> 		to[p].<span class="built_in">push_back</span>(i),len[p].<span class="built_in">push_back</span>(q);</span><br><span class="line"> 		to[i].<span class="built_in">push_back</span>(p),len[i].<span class="built_in">push_back</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1364">P1364 医院设置</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 102</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,val[N],p,q,f[N],dis[N],ans;</span><br><span class="line">vector&lt;ll&gt;edge[N];</span><br><span class="line"><span class="comment">//f储存大小,dis储存距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll fa,ll dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[u]=val[u];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> y:edge[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(y,u,dep+<span class="number">1</span>);</span><br><span class="line">		f[u]+=f[y];</span><br><span class="line">	&#125;</span><br><span class="line">	dis[<span class="number">1</span>]+=val[u]*dep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(ll u,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> y:edge[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">		dis[y]=dis[u]+f[<span class="number">1</span>]<span class="number">-2</span>*f[y];</span><br><span class="line">		<span class="built_in">dp</span>(y,u);</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="built_in">min</span>(ans,dis[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	ans=<span class="number">2</span>&lt;&lt;<span class="number">31</span><span class="number">-2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;val[i];</span><br><span class="line">		cin&gt;&gt;p&gt;&gt;q;</span><br><span class="line">		<span class="keyword">if</span>(q)edge[i].<span class="built_in">push_back</span>(q),edge[q].<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span>(p)edge[i].<span class="built_in">push_back</span>(p),edge[p].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题">题</h3>
<p>==codeforces1775F Laboratory on Pluto==</p>
<h1>数据结构</h1>
<h2 id="堆">堆</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt;pq;</span><br><span class="line"><span class="comment">//大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;pq;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序-小顶堆">堆排序(小顶堆)</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pq</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,num[N];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> !n;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> num[<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num[++n]=u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i/=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;=num[i/<span class="number">2</span>])<span class="keyword">return</span> ;</span><br><span class="line">            <span class="built_in">swap</span>(num[i],num[i/<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(num[<span class="number">1</span>],num[n]);</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((i*<span class="number">2</span>&lt;=n&amp;&amp;num[i]&gt;num[i*<span class="number">2</span>])||(i*<span class="number">2</span>+<span class="number">1</span>&lt;=n&amp;&amp;num[i]&gt;num[i*<span class="number">2</span>+<span class="number">1</span>]))</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span>(num[i*<span class="number">2</span>]&lt;=num[i*<span class="number">2</span>+<span class="number">1</span>]||i*<span class="number">2</span>+<span class="number">1</span>&gt;n)<span class="built_in">swap</span>(num[i],num[i*<span class="number">2</span>]),i*=<span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="built_in">swap</span>(num[i],num[i*<span class="number">2</span>+<span class="number">1</span>]),i=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;pq;</span><br></pre></td></tr></table></figure>
<h3 id="可删堆">可删堆</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pq</span></span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span> <span class="params">(<span class="type">int</span> u)</span></span>&#123;A.<span class="built_in">push</span>(u);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;B.<span class="built_in">push</span>(u);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!B.empty&amp;&amp;A.<span class="built_in">top</span>()==B.<span class="built_in">top</span>())</span><br><span class="line">            A.<span class="built_in">pop</span>(),B.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">clear</span>(),A.<span class="built_in">top</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="built_in">clear</span>(),A.<span class="built_in">pop</span>();&#125;</span><br><span class="line">&#125;pq;</span><br></pre></td></tr></table></figure>
<h2 id="BIT-树状数组">BIT(树状数组)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;<span class="keyword">return</span>((x) &amp; (-x));&#125; </span><br><span class="line"><span class="type">int</span> tree[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pos=i;p&lt;M;p+=<span class="built_in">lowbit</span>(p))</span><br><span class="line">       tree[p]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p=n;p;p-=<span class="built_in">lowbit</span>(p))</span><br><span class="line">        ans+=tree[p];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(b)-<span class="built_in">query</span>(a<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Segment-Tree-线段树">Segment Tree(线段树)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll tree[M&lt;&lt;<span class="number">2</span>],mark[M&lt;&lt;<span class="number">2</span>],val[M],n;<span class="comment">//开四倍数组即可，tree维护区间和，mark打上标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p=<span class="number">1</span>,<span class="type">int</span> cl=<span class="number">1</span>,<span class="type">int</span> cr=n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cl==cr)<span class="keyword">return</span> <span class="built_in">void</span>(tree[p]=val[cl]);</span><br><span class="line">	<span class="type">int</span> mid=(cr+cl)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,cl,mid);</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,cr);</span><br><span class="line">	tree[p]=tree[p&lt;&lt;<span class="number">1</span>]+tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> cl,<span class="type">int</span> cr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cl&gt;=cr)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(cr+cl)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	tree[p&lt;&lt;<span class="number">1</span>]+=mark[p]*(mid-cl+<span class="number">1</span>);</span><br><span class="line">	tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=mark[p]*(cr-mid);</span><br><span class="line">	mark[p&lt;&lt;<span class="number">1</span>]+=mark[p];</span><br><span class="line">	mark[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=mark[p];</span><br><span class="line">	mark[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d,<span class="type">int</span> p=<span class="number">1</span>,<span class="type">int</span> cl=<span class="number">1</span>,<span class="type">int</span> cr=n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cl&gt;=l&amp;&amp;cr&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">	 tree[p]+=d*(cr-cl+<span class="number">1</span>);</span><br><span class="line">	 mark[p]+=d;</span><br><span class="line">	 <span class="keyword">return</span>;	</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">push_down</span>(p,cl,cr);</span><br><span class="line">	<span class="type">int</span> mid=(cl+cr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(mid&gt;=l)<span class="built_in">update</span>(l,r,d,p&lt;&lt;<span class="number">1</span>,cl,mid);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;r)<span class="built_in">update</span>(l,r,d,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,cr);</span><br><span class="line">	tree[p]=tree[p&lt;&lt;<span class="number">1</span>]+tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p=<span class="number">1</span>,<span class="type">int</span> cl=<span class="number">1</span>,<span class="type">int</span> cr=n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cl&gt;=l&amp;&amp;cr&lt;=r)<span class="keyword">return</span> tree[p];</span><br><span class="line">	<span class="built_in">push_down</span>(p,cl,cr);</span><br><span class="line">	ll mid=(cl+cr)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mid&gt;=l)ans+=<span class="built_in">query</span>(l,r,p&lt;&lt;<span class="number">1</span>,cl,mid);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;r)ans+=<span class="built_in">query</span>(l,r,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,cr);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ST表">ST表</h2>
<blockquote>
<p>ST表用来处理一类<strong>静态</strong>区间问题,只要该区间符合性质: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext><mo stretchy="false">(</mo><mi>a</mi><mo>&gt;</mo><mo>=</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(L,R)=f(f(L,a),f(b,R))\;\;(a&gt;=b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></p>
<p>可知此处ab部分区间是可以有重叠的</p>
<p>函数max,min,gcd,lcm等这些均符合该性质 即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f(a,a)=a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></p>
<p>只能解决静态的问题</p>
<p>利用了区间dp的思想</p>
</blockquote>
<blockquote>
<p><strong>RMQ</strong>区间最值问题</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>预处理  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>询问</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>定义为左端点为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>的区间所求值,也就是区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,i+2^j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.908em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>状态转移方程为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp_{i,j}=max(dp_{i,j-1},dp_{i+2^{j-1},j-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0713em;vertical-align:-0.3213em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5148em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7571em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3213em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr;	<span class="comment">//数组下标从1开始方便处理</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)dp[i][<span class="number">0</span>] = arr[i];		<span class="comment">//初始化 表示长度为1的时候是自身</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">log2</span>(n); j++)		<span class="comment">//枚举区间长度j</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)	<span class="comment">//枚举起点i</span></span><br><span class="line">			dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);	<span class="comment">//保证区间重叠且不超过l r</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(dp[l][len], dp[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DSU-并查集">DSU(并查集)</h2>
<h3 id="并查集模板">并查集模板</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jls的模板</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> </span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;fa,size;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n):<span class="built_in">fa</span>(n),<span class="built_in">size</span>(n,<span class="number">1</span>) &#123;<span class="built_in">iota</span>(fa.<span class="built_in">begin</span>(),fa.<span class="built_in">end</span>(),<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y);&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        size[x]+=size[y];</span><br><span class="line">        fa[y]=x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SIZE</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> size[<span class="built_in">find</span>(x)];&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>==cf1770D==</p>
<h3 id="路径压缩">路径压缩</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[p]==p)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> f[p]=<span class="built_in">find</span>(f[p]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按秩合并">按秩合并</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> size[N];<span class="comment">//初始化为1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x]==x)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find2</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//选择树的大小中大的合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find2</span>(f[x]),fy=<span class="built_in">find2</span>(f[y]);</span><br><span class="line">    <span class="keyword">if</span>(fx==fy)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(size[fx]&lt;size[fy])f[fx]=fy,size[fy]+=size[fx];</span><br><span class="line">    <span class="keyword">else</span> f[fy]=fx,size[fx]+=size[fy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带权并查集">带权并查集</h3>
<p>对于并查集所维护的树形结构 。</p>
<blockquote>
<p>对于每个点，分别记录所属链的头结点、该点到头结点的距离以及它所在集合的大小。<br>
每次合并将y接在x的尾部，改变y头的权值和所属链的头结点，同时改变x的尾节点。<br>
注意：每次查找的时候也要维护每个节点的权值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000</span></span><br><span class="line"><span class="type">int</span> f[N+<span class="number">5</span>],val[N+<span class="number">5</span>];<span class="comment">//f记录根结点,val记录权值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==f[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> fn=<span class="built_in">find</span>(f[x]);</span><br><span class="line">	val[x]+=val[f[x]];</span><br><span class="line">	<span class="keyword">return</span> f[x]=fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1196">P1196 银河英雄传说</a></p>
<details><summary><big><stong>代码</stong></big></summary>
<pre><code>#include<bits/stdc++.h>
#define ll long long 
#define N 500000
#define M 30000
using namespace std;
ll t,a,b,f[M+1],dis[M+1],num[M+1];
char ord;
ll find(ll x)
&#123;
	if(x==f[x])return x;
	ll z=find(f[x]);
	dis[x]+=dis[f[x]];
	return f[x]=z;
&#125;
int main()
&#123;
	for(int i=1;i<=30000;i++)
	&#123;
		f[i]=i;
		num[i]=1;
	&#125;
	cin>>t;
	while(t--)
	&#123;
	  cin>>ord>>a>>b;
	  ll x=find(a),y=find(b);
	  if(ord=='M')
	  &#123;
	  	dis[x]+=num[y];
	  	f[x]=y;
	  	num[y]+=num[x];
	  	num[x]=0;
	  &#125;	
	   if(ord=='C')
	   &#123;
	   	if(x==y)cout<< abs(dis[a]-dis[b])-1<< endl;
	   	else cout<< -1<< endl;
	   &#125;
	&#125;
&#125;
</code></pre></details>
###  种类并查集
<p>增添几倍的新的结点来维护更复杂的种类之间的关系。一般用循环关系解题。</p>
<blockquote>
<p>合并种类一定有序,第一个集合到第二个集合,不能串</p>
</blockquote>
<p>例子:</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1525">洛谷 关押罪犯</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,m,f[M&lt;&lt;<span class="number">1</span>];<span class="comment">//两个集合就开两倍</span></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==f[x])<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span> &#123;</span><br><span class="line">	ll x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(P a,P b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.z&gt;b.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(fx==fy)<span class="keyword">return</span>;</span><br><span class="line">	f[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line">vector&lt;P&gt;arr;</span><br><span class="line">P s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)f[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;s.x&gt;&gt;s.y&gt;&gt;s.z;</span><br><span class="line">		arr.<span class="built_in">push_back</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> tem:arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(tem.x)!=<span class="built_in">find</span>(tem.y))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">merge</span>(tem.x,tem.y+n);</span><br><span class="line">			<span class="built_in">merge</span>(tem.y,tem.x+n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">	       cout&lt;&lt; tem.z &lt;&lt; endl;</span><br><span class="line">	       flag=<span class="number">1</span>;</span><br><span class="line">	       <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">if</span>(!flag)cout&lt;&lt;<span class="number">0</span>&lt;&lt; endl; </span><br><span class="line">&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/details&gt;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2024">洛谷 食物链</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100004</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,k,m,a,b,ans,f[M*<span class="number">3</span>];</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==f[x])<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*n;i++)f[i]=i;</span><br><span class="line">	<span class="keyword">while</span>(k--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="keyword">if</span>(a&gt;n||b&gt;n)</span><br><span class="line">		&#123;</span><br><span class="line">			ans++;<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b+n)||<span class="built_in">find</span>(b+<span class="number">2</span>*n)==<span class="built_in">find</span>(a))</span><br><span class="line">			&#123;</span><br><span class="line">			ans++;<span class="keyword">continue</span>;</span><br><span class="line">		    &#125;</span><br><span class="line">		    f[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">		    f[<span class="built_in">find</span>(a+n)]=<span class="built_in">find</span>(b+n);</span><br><span class="line">		    f[<span class="built_in">find</span>(a+<span class="number">2</span>*n)]=<span class="built_in">find</span>(b+<span class="number">2</span>*n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a==b||<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)||<span class="built_in">find</span>(a+<span class="number">2</span>*n)==<span class="built_in">find</span>(b))</span><br><span class="line">			&#123;</span><br><span class="line">			 ans++;<span class="keyword">continue</span>;</span><br><span class="line">		    &#125;</span><br><span class="line">		    f[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b+<span class="number">2</span>*n);</span><br><span class="line">		    f[<span class="built_in">find</span>(a+n)]=<span class="built_in">find</span>(b);</span><br><span class="line">		    f[<span class="built_in">find</span>(a+<span class="number">2</span>*n)]=<span class="built_in">find</span>(b+n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt; ans&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的简单结构-修">树的简单结构(修)</h2>
<blockquote>
<p><strong>二叉树</strong> <em>Binary Tree	BT</em></p>
<ul>
<li>每个节点最多有两个子树</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BT</span>&#123;</span><br><span class="line">    type data;</span><br><span class="line">    BT *left;</span><br><span class="line">    BT *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="满二叉树-修">满二叉树(修)</h3>
<p><em>Full Binary Tree	FBT</em></p>
<blockquote>
<ul>
<li>国内定义
<ul>
<li>二叉树的层数为K 那么总结点数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^K-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9247em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
<li>为金字塔型 无缺口的</li>
</ul>
</li>
<li>国际定义
<ul>
<li>二叉树的子节点要么为0 要么为2
<ul>
<li>国际把国内定义的满二叉树叫做 <strong>完美二叉树</strong> <em>Perfect Binary Tree	PBT</em></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="完全二叉树-修">完全二叉树(修)</h3>
<p><em>Complete Binary Tree	CBT</em></p>
<blockquote>
<ul>
<li>
<p>叶子结点只可能在最深的两层出现</p>
</li>
<li>
<p>子节点数为1的节点只有1个或没有</p>
</li>
<li>
<p>1-n的节点与同样深度的满二叉树的1-n节点相互对应</p>
</li>
<li>
<p>节点从1-n编号 如果i&gt;1 那么该节点的父节点为i/2</p>
</li>
<li>
<p>i&gt;1 奇数节点是右节点 偶数节点是左节点</p>
</li>
<li>
<p>节点i的左孩子节点为2<em>i 右孩子节点为2</em>i+1</p>
</li>
<li>
<p>i&gt;n/2的节点均为叶子节点</p>
</li>
</ul>
</blockquote>
<h3 id="二叉查找树-修">二叉查找树(修)</h3>
<p><em>Binary Sort Tree	BST</em></p>
<blockquote>
<ul>
<li>若左子树不为空 那么左子树上节点的值均小于根节点</li>
<li>若右子树不为空 那么左子树上节点的值均大于根节点</li>
<li>左右子树也为二叉查找树</li>
<li>没有值相同的节点</li>
<li>中序遍历的结果是排序</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BST的查找 失败返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BST_find</span><span class="params">(TreeNode* t,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;val==v)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;t-&gt;val)<span class="keyword">return</span> <span class="built_in">BST_find</span>(t-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(v&gt;t-&gt;val)<span class="keyword">return</span> <span class="built_in">BST_find</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BST的插入</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BST_INS</span><span class="params">(TreeNode* t,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t)<span class="keyword">return</span> <span class="built_in">TreeNode</span>(v);	<span class="comment">//空节点直接链接</span></span><br><span class="line">    <span class="keyword">if</span>(v&lt;t-&gt;val)t-&gt;left=<span class="built_in">BST_INS</span>(t-&gt;left,v);		<span class="comment">//要插入的节点肯定在左边</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v&gt;t-&gt;val)t-&gt;right=<span class="built_in">BST_INS</span>(t-&gt;right,v);		<span class="comment">//要插入的节点肯定在右边</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BST的删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST_DEL</span><span class="params">(TreeNode* t,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;t-&gt;val)<span class="built_in">BST_DEL</span>(t-&gt;left,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v&gt;t-&gt;val)<span class="built_in">BST_DEL</span>(t-&gt;right,v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到被删的节点</span></span><br><span class="line">        <span class="comment">//不考虑空间的释放</span></span><br><span class="line">        <span class="comment">//考虑空间的释放用递归返回节点或传入父亲节点做法</span></span><br><span class="line">        <span class="keyword">if</span>(!t-&gt;left)*t=*(t-&gt;right);	<span class="comment">//只有右节点 包含左右都为空的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!t-&gt;right)*t=*(t-&gt;left);	<span class="comment">//只有左节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到右边的最小节点</span></span><br><span class="line">            TreeNode* p=t;</span><br><span class="line">            TreeNode* x=p-&gt;right;	<span class="comment">//肯定会有</span></span><br><span class="line">            <span class="keyword">while</span>(x-&gt;left)&#123;</span><br><span class="line">                p=x;</span><br><span class="line">                x=x-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束时 p是x的父亲 x是最小节点</span></span><br><span class="line">            t-&gt;val=x-&gt;val;	<span class="comment">//赋值后继节点</span></span><br><span class="line">            p-&gt;left=x-&gt;right;	<span class="comment">//把节点删掉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线索二叉树-修">线索二叉树(修)</h3>
<p><em>Threaded Binary Tree	TBT</em></p>
<blockquote>
<p>以某种遍历方式 在节点上利用空指针域来储存前驱或后继</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线索二叉树的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TBT</span>&#123;</span><br><span class="line">    type data;</span><br><span class="line">    TBT *left;</span><br><span class="line">    TBT *right;</span><br><span class="line">    <span class="type">bool</span> lTag;</span><br><span class="line">    <span class="type">bool</span> rTag;</span><br><span class="line">    <span class="comment">//tag为0时表示正常的左右子节点 为0时表示前驱或后继</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过一次的遍历就能将其线索化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode* pre;	<span class="comment">//全局指针 始终指向刚刚访问过的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_threading</span><span class="params">(TreeNode* t)</span>		<span class="comment">//以中序遍历为例</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!t-&gt;left)&#123;</span><br><span class="line">        t-&gt;lTag=<span class="number">1</span>;</span><br><span class="line">        t-&gt;left=pre;	<span class="comment">//指向前驱;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">in_threading</span>(t-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(!t-&gt;right)&#123;</span><br><span class="line">        pre-&gt;rTag=<span class="number">1</span>;</span><br><span class="line">        pre-&gt;right=t;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=t;	<span class="comment">//前驱处理完毕</span></span><br><span class="line">    <span class="built_in">in_threading</span>(t-&gt;right);	<span class="comment">//注意和上面语句的顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼树-修">哈夫曼树(修)</h2>
<h3 id="建树">建树</h3>
<blockquote>
<p>又称<strong>最优二叉树</strong> 是带权路径长度最短的二叉树</p>
<p><strong>带权路径</strong></p>
<ul>
<li>
<p>假设某个节点的权值为w 该节点的深度为h 那么带权路径长度为wh</p>
</li>
<li>
<p>总的带权路径就是<strong>所有叶子节点带权路径的和</strong>或者是<strong>所有节点的权值之和</strong></p>
</li>
</ul>
<p><strong>建树过程</strong></p>
<ul>
<li>每次把节点权值中<strong>最小</strong>的<strong>两个节点</strong>连接到一个新的节点的左右孩子上 其中新节点的权值为<strong>两个节点之和</strong></li>
<li>采用最小堆来维护最小的节点</li>
<li>合并操作后把左右孩子的权值从堆中pop掉然后把新节点权值push进堆</li>
<li>直到堆中只有一个数字了</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;	<span class="comment">//树节点的定义</span></span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> c_,<span class="type">int</span> w_, TreeNode* l, TreeNode* r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;c = c_;</span><br><span class="line">		<span class="keyword">this</span>-&gt;w = w_;</span><br><span class="line">		left = l;</span><br><span class="line">		right = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> TreeNode &amp;t) <span class="type">const</span>	<span class="comment">//对节点重载&lt;可以用stl</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> w &gt; t.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildHuffman</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; &amp;arr)</span>	<span class="comment">//传入叶子节点的权值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue&lt;TreeNode, vector&lt;TreeNode&gt;, greater&lt;TreeNode&gt;&gt; heap;	<span class="comment">//最小堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="function">TreeNode <span class="title">t</span><span class="params">(arr[i].first,arr[i].second, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		heap.<span class="built_in">push</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)	<span class="comment">//当还能把森林or叶子拼成树时</span></span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode* t1 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(heap.<span class="built_in">top</span>().c,heap.<span class="built_in">top</span>().w, heap.<span class="built_in">top</span>().left, heap.<span class="built_in">top</span>().right);</span><br><span class="line">		heap.<span class="built_in">pop</span>();</span><br><span class="line">		TreeNode* t2 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(heap.<span class="built_in">top</span>().c, heap.<span class="built_in">top</span>().w, heap.<span class="built_in">top</span>().left, heap.<span class="built_in">top</span>().right);</span><br><span class="line">		heap.<span class="built_in">pop</span>();</span><br><span class="line">		TreeNode* t = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&#x27; &#x27;</span>,t1-&gt;w + t2-&gt;w, t1, t2);	<span class="comment">//拿出最小的两个节点拼成新的</span></span><br><span class="line">		heap.<span class="built_in">push</span>(*t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(heap.<span class="built_in">top</span>().c,heap.<span class="built_in">top</span>().w, heap.<span class="built_in">top</span>().left, heap.<span class="built_in">top</span>().right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
<blockquote>
<ul>
<li>哈夫曼树中只有叶子节点有意义 左子节点的边记作0 右子节点的边记作1 那么从根节点到某个叶子结点的边的编码就是该叶子节点的哈夫曼编码</li>
<li>哈夫曼编码是前缀编码 任一个叶子结点的编码都不是另一个叶子编码的前缀</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,pair&lt;<span class="type">int</span>, string&gt;&gt; codes;	<span class="comment">//表示叶子c权值为i 它的编码为j 元组(i,j)数组</span></span><br><span class="line">pair&lt;<span class="type">int</span>, string&gt; tmp;	<span class="comment">//全局保存临时路径 便于回溯</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_code_dfs</span><span class="params">(TreeNode* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!t-&gt;left &amp;&amp; !t-&gt;left) &#123;	<span class="comment">//叶子节点</span></span><br><span class="line">		tmp.first = t-&gt;w;</span><br><span class="line">		codes[t-&gt;c]=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (t-&gt;left) &#123;</span><br><span class="line">			tmp.second.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);	<span class="comment">//左0</span></span><br><span class="line">			<span class="built_in">get_code_dfs</span>(t-&gt;left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t-&gt;right) &#123;</span><br><span class="line">			tmp.second.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);	<span class="comment">//右1</span></span><br><span class="line">			<span class="built_in">get_code_dfs</span>(t-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp.second.<span class="built_in">pop_back</span>();	<span class="comment">//回溯还原</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈夫曼译码">哈夫曼译码</h3>
<blockquote>
<p>按照同一棵树进行译码</p>
<p>还是按照左0右1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string res_code;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translate_code_dfs</span><span class="params">(string &amp;code,<span class="type">int</span> idx,TreeNode* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!t)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (idx &gt;= code.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!t-&gt;left&amp;&amp;!t-&gt;right) &#123;	<span class="comment">//到了叶子节点</span></span><br><span class="line">		res_code.<span class="built_in">push_back</span>(t-&gt;c);</span><br><span class="line">		<span class="built_in">translate_code_dfs</span>(code, idx, root);	<span class="comment">//重新重头开始</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (code[idx] == <span class="string">&#x27;0&#x27;</span>)<span class="built_in">translate_code_dfs</span>(code, idx + <span class="number">1</span>, t-&gt;left);	<span class="comment">//左0</span></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">translate_code_dfs</span>(code, idx + <span class="number">1</span>, t-&gt;right);	<span class="comment">//右1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列-修">单调队列(修)</h2>
<blockquote>
<p><strong>滑动窗口问题</strong></p>
<p>有一个大小为 <em>k</em> 的滑动窗口从数组的最左侧移动到数组的最右侧,只可以看到在滑动窗口内的 <em>k</em> 个数字,滑动窗口每次只向右移动一位.求滑动窗口中的最大值.</p>
</blockquote>
<blockquote>
<p>deque实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">window_max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;	<span class="comment">//存每个窗口的最大值</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;	<span class="comment">//q存的是索引 保证队列中不会超出k范围</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;arr[q.<span class="built_in">back</span>()]&lt;=arr[i])q.<span class="built_in">pop_back</span>();<span class="comment">//进队时保证前方的都比他大</span></span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">-1</span>;i&lt;(<span class="type">int</span>)arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i-q.<span class="built_in">front</span>()==k)q.<span class="built_in">pop_front</span>();	<span class="comment">//超出k个 队头出队</span></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;arr[q.<span class="built_in">back</span>()]&lt;=arr[i])q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(arr[q.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr,q;</span><br><span class="line"><span class="type">int</span> k,front=<span class="number">0</span>,back=<span class="number">0</span>;	<span class="comment">//当front=back时队列为空</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">window_max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(back&gt;front&amp;&amp;arr[q[back<span class="number">-1</span>]]&lt;=arr[i])back--;	<span class="comment">//队列不空</span></span><br><span class="line">        q[back++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">-1</span>;i&lt;(<span class="type">int</span>)arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i-q[front]==k)front++;	<span class="comment">//队头出队 队肯定不为空</span></span><br><span class="line">        <span class="keyword">while</span>(back&gt;front&amp;&amp;arr[q[back<span class="number">-1</span>]]&lt;=arr[i])back--;</span><br><span class="line">        q[back++]=i;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(arr[q[front]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈-修">单调栈(修)</h2>
<blockquote>
<p>栈内是单调的,用来解决如:</p>
<p>给定一个长度为N的整数数列,输出每个数左边第一个比它小的数,如果不存在则输出-1.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">m_stack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack_;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_.<span class="built_in">empty</span>())ans.<span class="built_in">push_back</span>(<span class="number">-1</span>);	<span class="comment">//当前已经是最小的数了</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(stack_.<span class="built_in">size</span>()&amp;&amp;stack_.<span class="built_in">top</span>()&gt;=arr[i])stack_.<span class="built_in">pop</span>();<span class="comment">//找到第一个比当前小的</span></span><br><span class="line">            <span class="keyword">if</span>(stack_.<span class="built_in">empty</span>())ans.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> ans.<span class="built_in">push_back</span>(stack_.<span class="built_in">top</span>());</span><br><span class="line">            stack_.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DSU-并查集-修">DSU(并查集)(修)</h2>
<h3 id="朴素并查集">朴素并查集</h3>
<blockquote>
<p>最坏情况当树退化成链的时候 每次的查询和合并操作都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;	<span class="comment">//father节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span>	<span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        f[i]=i;		<span class="comment">//表示每个节点是独立的 他的祖先节点是自己</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x]==x?x:<span class="built_in">find</span>(f[x]);	<span class="comment">//如果该节点是祖先节点 那么就返回 否则递归往上寻找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);	<span class="comment">//令a的祖先连到b的祖先	相同祖先的话会自己连自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高度并查集">高度并查集</h3>
<blockquote>
<p>额外储存树的高度,每次合并低的树指向高的树,控制树高增加</p>
<p>查找和合并操作都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;	<span class="comment">//father 节点</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">h</span><span class="params">(n)</span></span>;	<span class="comment">//储存树的高度且仅祖先节点有意义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span>	<span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        f[i]=i;</span><br><span class="line">        h[i]=<span class="number">1</span>;		<span class="comment">//初始每棵树的高度都为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x]==x?x:<span class="built_in">find</span>(f[x]);	<span class="comment">//如果该节点是祖先节点 那么就返回 否则递归往上寻找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fa=<span class="built_in">find</span>(a),fb=<span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(fa==fb)<span class="keyword">return</span>;	<span class="comment">//相同祖先 不进行其他操作</span></span><br><span class="line">    <span class="keyword">if</span>(h[fa]&lt;=h[fb])&#123;</span><br><span class="line">        f[fa]=fb;</span><br><span class="line">        h[fb]=<span class="built_in">max</span>(h[fb],<span class="number">1</span>+h[fa]);	<span class="comment">//当树高相等时 合并需要把树高度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> f[fb]=fa;	<span class="comment">//此时高度合并后的肯定不会超出h[fa]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="维护集合大小的路径压缩并查集">维护集合大小的路径压缩并查集</h3>
<blockquote>
<p>查询和合并操作均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;	<span class="comment">//forefather 节点</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">h</span><span class="params">(n)</span></span>;	<span class="comment">//储存树的高度且仅祖先节点有意义</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">size</span><span class="params">(n)</span></span>;	<span class="comment">//储存树的节点数量且仅祖先节点有意义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        f[i]=i;</span><br><span class="line">        size[i]=<span class="number">1</span>;		<span class="comment">//初始每棵树的大小都为1</span></span><br><span class="line">        h[i]=<span class="number">1</span>;		<span class="comment">//初始每棵树的高度都为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x]=(f[x]==x?x:<span class="built_in">find</span>(f[x]));	<span class="comment">//直接把当前节点的父节点改为祖先节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fa=<span class="built_in">find</span>(a),fb=<span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(fa==fb)<span class="keyword">return</span>;	<span class="comment">//相同祖先 不进行其他操作</span></span><br><span class="line">    <span class="keyword">if</span>(h[fa]&lt;=h[fb])&#123;</span><br><span class="line">        size[fb]+=size[fa];</span><br><span class="line">        f[fa]=fb;</span><br><span class="line">        h[fb]=<span class="built_in">max</span>(h[fb],<span class="number">1</span>+h[fa]);	<span class="comment">//当树高相等时 合并需要把树高度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size[fa]+=size[fb];</span><br><span class="line">        f[fb]=fa;	<span class="comment">//此时高度合并后的肯定不会超出h[fa]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="维护链长的路径压缩并查集">维护链长的路径压缩并查集</h3>
<blockquote>
<p>维护元素到根节点的长度	(抽象成为一条链  与实际的树不一样)</p>
<p>合并的时候把原来的根的链长从0加上要移到的集合的大小 (即抽象链 实际上是以树直接接到另一个集合的根的)</p>
<p>查询的时候 每个元素都加上其祖先节点的链长即可 (一定要先往祖先节点搜索完)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; f,dis,cnt;	<span class="comment">//祖先 到根的距离 集合的大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> root=<span class="built_in">find</span>(f[x]);</span><br><span class="line">    dis[x]+=dis[f[x]];	<span class="comment">//这时候x的祖先的长度已经算好了</span></span><br><span class="line">    <span class="keyword">return</span> f[x]=root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fa=<span class="built_in">find</span>(a),fb=<span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(fa==fb)<span class="keyword">return</span>;</span><br><span class="line">    dis[fa]=cnt[fb];	<span class="comment">//加上另一个集合大小 原来作为根是0</span></span><br><span class="line">    cnt[fb]+=cnt[fa];	<span class="comment">//改掉集合大小 不能和上面语句顺序交换</span></span><br><span class="line">    f[fa]=fb;	<span class="comment">//合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对顶堆-修">对顶堆(修)</h2>
<blockquote>
<p>对顶堆可以动态维护中位数和动态第K大/小值等问题</p>
<p>本质是维护了一个大顶堆和一个小顶堆</p>
<ul>
<li>两个堆各自是单调的</li>
<li>大顶堆在下,小顶堆在上</li>
<li>保证小顶堆里面的元素都比大顶堆的要大</li>
<li>堆中元素只能不断动态增加</li>
</ul>
</blockquote>
<blockquote>
<p><strong>动态中位数</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; big;	<span class="comment">//大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; small;	<span class="comment">//小顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(small.<span class="built_in">empty</span>()||x&gt;small.<span class="built_in">top</span>())small.<span class="built_in">push</span>(x);	<span class="comment">//如果上面的小堆是空或者元素比分界线大</span></span><br><span class="line">    <span class="keyword">else</span> big.<span class="built_in">push</span>(x);								<span class="comment">//先加入小堆 否则加入下面</span></span><br><span class="line">    <span class="comment">//开始调整 保证上方的小堆大小大于等于下面大堆的大小 保证从上方取中位数</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="type">int</span>)big.<span class="built_in">size</span>()-(<span class="type">int</span>)small.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;		<span class="comment">//下面比上面多了一个</span></span><br><span class="line">        small.<span class="built_in">push</span>(big.<span class="built_in">top</span>());	<span class="comment">//把下面的移到上面去</span></span><br><span class="line">        big.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">int</span>)small.<span class="built_in">size</span>()-(<span class="type">int</span>)big.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;	<span class="comment">//上面的堆数量多了</span></span><br><span class="line">        big.<span class="built_in">push</span>(small.<span class="built_in">top</span>());</span><br><span class="line">        small.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>动态第K小数</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> K=<span class="number">0</span>;	<span class="comment">//该K值先获取最值再增加 保证小顶堆恒有元素 获取时候保证下面的大堆的大小为K-1</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; big;	<span class="comment">//大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; small;	<span class="comment">//小顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//动态添加元素	此时无需调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (small.<span class="built_in">empty</span>() || x &gt; small.<span class="built_in">top</span>())small.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">else</span> big.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;		<span class="comment">//调整至下面的大堆大小为K-1</span></span><br><span class="line">	<span class="keyword">while</span> (big.<span class="built_in">size</span>() &lt; K&amp;&amp;small.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		big.<span class="built_in">push</span>(small.<span class="built_in">top</span>());</span><br><span class="line">		small.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (big.<span class="built_in">size</span>() &gt; K&amp;&amp;big.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		small.<span class="built_in">push</span>(big.<span class="built_in">top</span>());</span><br><span class="line">		big.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据应当保证adjust时元素数大于K</span></span><br></pre></td></tr></table></figure>
<h2 id="树的dfs序-修">树的dfs序(修)</h2>
<blockquote>
<p>用dfs先序的方法把从根出发对树进行遍历, 并且记录下进入某个节点x的时间in[x]以及记录某个节点遍历完所有子节点后的离开时间out[x]. 从时间的递增性质可以知道对于节点x的(in[x],out[x])是可以构成一个合法区间的,且该范围的含义是<strong>包含x节点与其所有子节点的区间</strong>,x节点在区间的最左端,这样就可以实现对树的所有子节点操作改为对线性序列的区间操作.</p>
<p>显然,根据in[x]可以给树的节点进行编号并构成一个树的序列</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设该树是以二维数组储存的	tree[x][i] 表示当前节点x的第i个儿子是哪个节点</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tree;</span><br><span class="line"><span class="comment">//range[x] 表示节点x的子节点们的范围(range[x].first,range[x].second)</span></span><br><span class="line"><span class="comment">//其中range[x].first为x节点的序号</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; range;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; seq;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seq.<span class="built_in">push_back</span>(x);</span><br><span class="line">    range.first = seq.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tree[x].<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">dfs</span>(tree[x][i]);</span><br><span class="line">    range[x].second = seq.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>几何</h1>
<h2 id="判断圆和矩形是否重叠-修">判断圆和矩形是否重叠(修)</h2>
<blockquote>
<ul>
<li>先把矩形中心移到坐标原点 同时把圆也相对移动</li>
<li>把圆移到第一象限 因为此时矩形中心在原点 所以无论圆在哪个象限都能映射到第一象限进行相交判断</li>
<li>计算出原点与矩形右上角的dx与dy</li>
<li>dx与dy如果小于0 那么则直接映射为0 因为小于0时dx与dy方向上的可当做圆心垂直矩形右上角最短 即只需要考虑大于0的方向</li>
<li>计算dx与dy和矩形右上角的欧拉距离</li>
<li>与半径进行对比</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆半径和原点坐标 矩形左下角坐标和右上角坐标</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="type">double</span> r,<span class="type">double</span> x,<span class="type">double</span> y,<span class="type">double</span> x1,<span class="type">double</span> y1,<span class="type">double</span> x2,<span class="type">double</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x_center = (x1+x2)/<span class="number">2</span>, y_center = (y1+y2)/<span class="number">2</span>;</span><br><span class="line">    x2-=x_center;</span><br><span class="line">    y2-=y_center;</span><br><span class="line">    x = <span class="built_in">fabs</span>(x-x_center);</span><br><span class="line">    y = <span class="built_in">fabs</span>(y-y_center);</span><br><span class="line">    <span class="type">double</span> dx = <span class="built_in">max</span>(x-x2,<span class="number">0.0</span>), dy = <span class="built_in">max</span>(y-y2,<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">return</span> dx*dx+dy*dy &lt;= r*r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="圆覆盖最多点问题-修">圆覆盖最多点问题(修)</h2>
<blockquote>
<p>给定一个<strong>半径为r</strong>的圆</p>
<p>给定一些<strong>点的坐标(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i,y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</strong></p>
<p>求圆能覆盖最多点的个数</p>
</blockquote>
<blockquote>
<p><strong>暴力枚举圆</strong></p>
<ul>
<li>最优解的圆是可移动的</li>
<li>必定可以移动到某两个或以上点在最优圆的边缘上</li>
<li>枚举这两个点在固定半径圆边缘上的圆心位置</li>
<li>暴力循环看在这两个点生成的圆有多少个点在里面</li>
<li>计算圆心位置根据勾股定律和三角函数可算得</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x_,<span class="type">double</span> y)&#123;x=x_;y=y_;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Point&gt; points;</span><br><span class="line"><span class="type">int</span> r;	<span class="comment">//半径</span></span><br><span class="line"><span class="type">int</span> n;	<span class="comment">//点数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(Point a,Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x-b.x,<span class="number">2</span>)+<span class="built_in">pow</span>(a.y-b.y,<span class="number">2</span>));	<span class="comment">//欧几里得距离</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Point <span class="title">getCenter</span><span class="params">(Point a,Point b)</span>	<span class="comment">//重点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point mid=<span class="built_in">Point</span>((a.x+b.x)/<span class="number">2</span>,(a.y+b.y)/<span class="number">2</span>);	<span class="comment">//中点</span></span><br><span class="line">    <span class="type">double</span> theta=<span class="built_in">atan2</span>(a.x-b.x,b.y-a.y);	<span class="comment">//把y分量向量反向 模板背就行</span></span><br><span class="line">    <span class="type">double</span> d=<span class="built_in">sqrt</span>(r*r-<span class="built_in">pow</span>(<span class="built_in">dist</span>(a,mid),<span class="number">2</span>));	<span class="comment">//ab直线和圆心的距离</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(mid.x+d*<span class="built_in">cos</span>(theta),mid.y+d*<span class="built_in">sin</span>(theta));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numPoints</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;	<span class="comment">//最少有一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)	<span class="comment">//遍历两个相同的点时由于顺序不同 会把两个方向的圆都考虑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dist</span>(points[i],points[j])&gt;<span class="number">2.0</span>*r)<span class="keyword">continue</span>;	<span class="comment">//不可能</span></span><br><span class="line">            Point center=<span class="built_in">getCenter</span>(points[i],points[j]);</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)	<span class="comment">//暴力计数</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dist</span>(center,points[k])&lt;=<span class="number">1.0</span>*r+<span class="number">1e-8</span>)cnt++;	<span class="comment">//注意误差</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>图论</h1>
<h2 id="图的存储-不要忘了两倍数组-双向边">图的存储(不要忘了两倍数组 双向边)</h2>
<h3 id="邻接表">邻接表</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; to[MAXN],val[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    val[x].<span class="built_in">push_back</span>(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:to[x])</span><br><span class="line"><span class="comment">// for(int i=0;i&lt;to[x].size();i++)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式前向星">链式前向星</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;ll next,to&#125;e[N];</span><br><span class="line">ll head[N],num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(ll from,ll to,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//to为指向的边,head为每个点的第一条边的编号,next为这一条边的下一条边,val为边权</span></span><br><span class="line">	e[++num].to=to;</span><br><span class="line">    e[num].val=val;</span><br><span class="line">	e[num].next=head[from];</span><br><span class="line">	head[from]=num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他">其他</h3>
<blockquote>
<p>求到达的最大结点时可以反向建图,求大的结点能到的小结点</p>
</blockquote>
<h2 id="二分图-修">二分图(修)</h2>
<h3 id="并查集版">并查集版</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1330">P1330 封锁阳光大学</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,m,p,q,fa[N],num[N],ans,h[N],vis[N];</span><br><span class="line"><span class="comment">//num储存染成同一张颜色结点个数,h[i]储存与i异色的点的集合中的某一点,vis判断是否访问完所有联通块(图不一定是连通图)</span></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(fx==fy)<span class="keyword">return</span>;</span><br><span class="line">	fa[fx]=fy;</span><br><span class="line">	num[fy]+=num[fx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i,num[i]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   	    cin&gt;&gt;p&gt;&gt;q;</span><br><span class="line">        ll fp=<span class="built_in">find</span>(p),fq=<span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span>(fp!=fq)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(h[p]) <span class="built_in">merge</span>(h[p],q);</span><br><span class="line">        	<span class="keyword">if</span>(h[q]) <span class="built_in">merge</span>(h[q],p);</span><br><span class="line">        	h[p]=q;</span><br><span class="line">        	h[q]=p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll fi=<span class="built_in">find</span>(i);</span><br><span class="line">		<span class="keyword">if</span>(!vis[fi])</span><br><span class="line">		&#123;</span><br><span class="line">			ll fhi=<span class="built_in">find</span>(h[i]);</span><br><span class="line">			vis[fhi]=vis[fi]=<span class="number">1</span>;</span><br><span class="line">			ans+=<span class="built_in">min</span>(num[fhi],num[fi]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="染色法判断二分图">染色法判断二分图</h3>
<p>选定任意未染色节点,染上一种颜色,然后遍历所有相邻节点染上另一种颜色,如果在期间发现相邻节点染上相同颜色,那么表示该图不是二分图</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;	<span class="comment">//节点数</span></span><br><span class="line"><span class="type">int</span> m;	<span class="comment">//边数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">edge</span><span class="params">(m+<span class="number">5</span>,<span class="number">0</span>)</span></span>;	<span class="comment">//存编号为i的边的终点节点 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Next</span><span class="params">(m+<span class="number">5</span>,<span class="number">0</span>)</span></span>;	<span class="comment">//存编号为i的边的下一个兄弟节点编号	</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(n+<span class="number">5</span>,<span class="number">-1</span>)</span></span>;	<span class="comment">//存节点i的第一条边的编号 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;	<span class="title">color</span><span class="params">(n,<span class="number">-1</span>)</span></span>;	<span class="comment">//-1表示未染色 0表示黑色 1表示白色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">paint</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span>	<span class="comment">//深搜去染色</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u]=c;		<span class="comment">//进行染色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=Next[i])&#123;	<span class="comment">//对相邻的节点进行染色</span></span><br><span class="line">        <span class="type">int</span> node=edge[i];</span><br><span class="line">        <span class="keyword">if</span>(color[node]==<span class="number">-1</span>)&#123;	<span class="comment">//如果未染色</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">paint</span>(node,!c))<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//进行深搜染色 如果失败则返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[node]==c)<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//同一个颜色 染色失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_bipartite_graph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(color[i]==<span class="number">-1</span>)		<span class="comment">//对未染色节点进行检查</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">paint</span>(i,<span class="number">0</span>))<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//染色失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匈牙利算法求二分图最大匹配">匈牙利算法求二分图最大匹配</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1,n2;	<span class="comment">//分别表示二分图里两个集合的点数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(n,<span class="number">-1</span>)</span></span>;		<span class="comment">//邻接表的三个数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">edge</span><span class="params">(m,<span class="number">0</span>)</span></span>;		<span class="comment">//匈牙利算法只会用到第一个集合指向第二个集合的边</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Next</span><span class="params">(m,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">match</span><span class="params">(n2,<span class="number">-1</span>)</span></span>;	<span class="comment">//表示第二个集合的节点当前所对应着的第一个集合的节点 -1为没有匹配</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n2,<span class="literal">false</span>)</span></span>;	<span class="comment">//表示是否在一次匹配中访问过节点 防止重边重复访问</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> v)</span>	<span class="comment">//进行增广路径的寻找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[v];~i;i=Next[i])&#123;</span><br><span class="line">        <span class="type">int</span> node=edge[i];</span><br><span class="line">        <span class="keyword">if</span>(!visited[node])&#123;</span><br><span class="line">            visited[node]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[node]==<span class="number">-1</span>||<span class="built_in">find</span>(match[node]))&#123;	<span class="comment">//对应的点无匹配 或者可以使其他节点让位</span></span><br><span class="line">                match[node]=v;	<span class="comment">//定下这个匹配表示是可行的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hungary</span><span class="params">()</span>	<span class="comment">//求最大匹配数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">        visited=<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n2,<span class="literal">false</span>);	<span class="comment">//重置</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i))ans++;	<span class="comment">//以此匹配成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序">拓扑排序</h2>
<p>有向图判断是否有环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:to[i])ru[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ru[i]==<span class="number">0</span>)  q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();  </span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:to[x])</span><br><span class="line">        &#123;</span><br><span class="line">            ru[y]--;</span><br><span class="line">            <span class="keyword">if</span>(ru[y]==<span class="number">0</span>) q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> is_cycled=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ru[i]!=<span class="number">0</span>)is_cycled=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1983">P1983 车站分级</a></p>
<blockquote>
<p>按层拓扑</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll m,n,num[M][M],vis[M],edge[M][M],ans,ru[M];</span><br><span class="line">vector&lt;ll&gt;to[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;P&gt;q;</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ru[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(<span class="built_in">mp</span>(i,<span class="number">1</span>));</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ll a=q.<span class="built_in">front</span>().fi,b=q.<span class="built_in">front</span>().se;  </span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:to[a])</span><br><span class="line">        &#123;</span><br><span class="line">            ru[y]--;</span><br><span class="line">            <span class="keyword">if</span>(ru[y]==<span class="number">0</span>) </span><br><span class="line">			&#123;</span><br><span class="line">			 q.<span class="built_in">push</span>(<span class="built_in">mp</span>(y,b+<span class="number">1</span>));</span><br><span class="line">			 ans=<span class="built_in">max</span>(ans,b+<span class="number">1</span>);</span><br><span class="line">	    	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">   cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		cin&gt;&gt;num[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num[i][<span class="number">0</span>];j++)cin&gt;&gt;num[i][j],vis[num[i][j]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=num[i][<span class="number">1</span>];j&lt;=num[i][num[i][<span class="number">0</span>]];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">1</span>;z&lt;=num[i][<span class="number">0</span>];z++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!edge[j][num[i][z]])</span><br><span class="line">				&#123;</span><br><span class="line">					ru[num[i][z]]++;</span><br><span class="line">					to[j].<span class="built_in">push_back</span>(num[i][z]);</span><br><span class="line">					edge[j][num[i][z]]=<span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">             &#125;	</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">tp</span>();</span><br><span class="line">cout&lt;&lt; ans&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的重心">树的重心</h2>
<p>找到一个点，其所有的子树中最大的子树节点数最少，那么这个点就是这棵树的重心</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//f记录结点数,res为最大子树的结点数和父辈结点数中的最大值,ans为答案</span></span><br><span class="line">	f[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> y:edge[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(y,u);</span><br><span class="line">		f[u]+=f[y];</span><br><span class="line">        res=<span class="built_in">max</span>(res,f[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	res=<span class="built_in">max</span>(res,n-f[u]);</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的直径-修">树的直径(修)</h2>
<h3 id="BFS-DFS">BFS/DFS</h3>
<p>两次搜索<br>
第一次从任意一个点a出发进行搜索 找到离他最远的点x<br>
然后从x出发 进行第二次搜索 找到离他最远的点y<br>
xy的路径就是树的直径</p>
<p>证明  从一个点出发必定能走到最远的为x或者y点<br>
假设其走到最远点为z点 那么显然有xz或yz的路径长度大于xy<br>
这样就与假设xy为直径不符合了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;	<span class="comment">//点的数量</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; G;	<span class="comment">//邻接表</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line"><span class="type">int</span> d=<span class="number">0</span>,node=<span class="number">-1</span>;	<span class="comment">//直径长度和xy点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(len&gt;d)&#123;</span><br><span class="line">        d=len;	<span class="comment">//更新直径  第二次有用</span></span><br><span class="line">        node=x;	<span class="comment">//更新最远的点 第一次有用</span></span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[x].<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">dfs</span>(G[x][i],len+<span class="number">1</span>);	<span class="comment">//如果该树有权值的话  len+1 改为len+两点的权值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTreeD</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(a,<span class="number">0</span>);	<span class="comment">//从任意点a出发</span></span><br><span class="line">	<span class="built_in">dfs</span>(node,<span class="number">0</span>);	<span class="comment">//从最远点出发</span></span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树形dp-3">树形dp</h3>
<p>先取任意点为根 通常取0号点<br>
定义<code>dp[x]</code>为 以x为根节点的子树 (子树是相对上一步选取的根节点的) 的高度<br>
显然高度可以递归来获取<br>
在更新高度的同时 (记住 是同时)  可能某个节点x的<code>dp[x]</code>会经过另一条分支递归回来 从而比原来的<code>dp[x]</code>要大 那么这时候显然原来的高度值为次大值 现在的为最大值  那么此时定义<code>d[x]</code>为经过x节点的最长链长度 <code>d[x]=dp[x]'+dp[x]</code><br>
最终的答案树的直径即为 <code>d=max&#123;d[i]&#125;(1&lt;=i&lt;=n)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; G,w;	<span class="comment">//邻接表和权值</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;	<span class="comment">//假如把图建成有根有向 则不需要这个</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dp,d;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])<span class="keyword">return</span>;</span><br><span class="line">    vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> y=G[x][i];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(dp[y]+w[x][y]&gt;dp[x])&#123;	<span class="comment">//y这条路径比原来的长</span></span><br><span class="line">            d[x]=dp[x]+dp[y]+w[x][y];	<span class="comment">//更新一下次大和最大形成的链</span></span><br><span class="line">            dp[x]=dp[y]+w[x][y];	<span class="comment">//记得先更新d再更新dp</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,d[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树">最小生成树</h2>
<p>定义：给出一张联通图，在这张联通图上面找到一颗树，要求覆盖所有结点，并且使得选出来这些边的边权和最小。</p>
<p>比较形式化的定义是，要求图的顶点集不动，选出边集的一个子集，要求选出的边集构成一颗树，并且边权和最小。</p>
<h3 id="Kruskal">Kruskal</h3>
<blockquote>
<p>对于给出的每一条边，我们按照边权从小到大给这些边进行排序。同时，我们维护一个并查集，满足当我们以边权从小到大访问这些边的时候，如果这条边的两端结点不在同一个集合的时候，我们把这两个集合合并并且加上边权。当我们加入了N-1（N是顶点个数）条边的时候，我们便可以结束这个操作。<br>
Kruskal算法的时间复杂度为 O(mlogm) ，主要是对边排序的时间复杂度，正因如此，该算法在面对稀疏图（边数较少）时，效果较好。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,m,p,q,v,num,sum,f[N],sign;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="comment">//x,y记录结点,val记录边权,sum为最小边权和</span></span><br><span class="line">	ll x,y,val;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge a,Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.val&lt;b.val; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll x,ll y,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++num].x=x;</span><br><span class="line">	edge[num].y=y;</span><br><span class="line">	edge[num].val=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==f[x])<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+num+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll x=<span class="built_in">find</span>(edge[i].x),y=<span class="built_in">find</span>(edge[i].y);</span><br><span class="line">		<span class="keyword">if</span>(x==y)<span class="keyword">continue</span>;</span><br><span class="line">		f[x]=y;</span><br><span class="line">		sum+=edge[i].val;</span><br><span class="line">		sign++;<span class="comment">//sign记录连了几条边</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sign!=n<span class="number">-1</span>)sum=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;p&gt;&gt;q&gt;&gt;v;</span><br><span class="line">		<span class="built_in">add</span>(p,q,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">kruskal</span>();</span><br><span class="line">	<span class="keyword">if</span>(!sum)cout&lt;&lt;<span class="string">&quot;error&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="prim">prim</h3>
<blockquote>
<p>先建立一个只有一个结点的树，这个结点可以是原图中任意的一个结点. 使用一条边扩展这个树，要求这条边一个顶点在树中另一 个顶点不在树中，并且这条边的权值要求最小。重复步骤, 直到所有顶点都在树中。<br>
代码的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，与边数基本无关（更新时遍历边的部分基本可忽略），所以对稠密图（边数较多）效果较好。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 5007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//dis数组储存到一个点的最小距离，vis表示是否加入</span></span><br><span class="line">ll vis[M],head[M],m,n,p,q,v,dis[M],MIN,now,sum,num;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	ll to,val,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll from,ll to,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++num].to=to;</span><br><span class="line">	edge[num].val=val;</span><br><span class="line">	edge[num].next=head[from];</span><br><span class="line">	head[from]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	now=<span class="number">1</span>;vis[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//从第一个结点开始访问</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=inf;<span class="comment">//先将所有点视为不可到，距离为inf</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[now];j;j=edge[j].next)</span><br><span class="line">            dis[edge[j].to]=<span class="built_in">min</span>(dis[edge[j].to],edge[j].val);</span><br><span class="line">        <span class="comment">//更新一遍当前节点能到的所有节点的最小距离</span></span><br><span class="line">        MIN=inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(!vis[j]&amp;&amp;MIN&gt;dis[j])</span><br><span class="line">			&#123;</span><br><span class="line">				MIN=dis[j];</span><br><span class="line">				now=j;</span><br><span class="line">			&#125;</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        sum+=MIN;</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="keyword">if</span>( !*<span class="built_in">min_element</span>(vis+<span class="number">1</span>,vis+n+<span class="number">1</span>))sum=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;p&gt;&gt;q&gt;&gt;v;</span><br><span class="line">		<span class="built_in">add</span>(p,q,v),<span class="built_in">add</span>(q,p,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">prim</span>();</span><br><span class="line">	<span class="keyword">if</span>(sum==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;error&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Prim-Heap">Prim_Heap</h3>
<blockquote>
<p>使用优先队列来维护最小点<br>
Prim_Heap的时间复杂度为 O(mlogn) 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 5007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//dis数组储存到一个点的最小距离，vis表示是否加入</span></span><br><span class="line">ll vis[M],head[M],m,n,p,q,v,dis[M],MIN,now,sum,num;</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt;que;<span class="comment">//优先队列</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	ll to,val,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll from,ll to,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++num].to=to;</span><br><span class="line">	edge[num].val=val;</span><br><span class="line">	edge[num].next=head[from];</span><br><span class="line">	head[from]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim_heap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=inf;<span class="comment">//先将所有点视为不可到，距离为inf</span></span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>,<span class="number">1</span>));<span class="comment">//从第一个结点开始访问</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n&amp;&amp;!que.<span class="built_in">empty</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        ll val=que.<span class="built_in">top</span>().fi,now=que.<span class="built_in">top</span>().se;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[now])<span class="keyword">continue</span>;</span><br><span class="line">        i++;</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        sum+=val;</span><br><span class="line">        <span class="keyword">for</span>(ll j=head[now];j;j=edge[j].next)</span><br><span class="line">            <span class="keyword">if</span>(!vis[edge[j].to]&amp;&amp;edge[j].val&lt;dis[edge[j].to])</span><br><span class="line">                dis[edge[j].to]=edge[j].val,que.<span class="built_in">push</span>(<span class="built_in">mp</span>(dis[edge[j].to],edge[j].to));</span><br><span class="line">        <span class="comment">//更新一遍当前节点能到的所有节点的最小距离</span></span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="keyword">if</span>(!*<span class="built_in">min_element</span>(vis+<span class="number">1</span>,vis+n+<span class="number">1</span>))sum=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;p&gt;&gt;q&gt;&gt;v;</span><br><span class="line">		<span class="built_in">add</span>(p,q,v),<span class="built_in">add</span>(q,p,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">prim_heap</span>();</span><br><span class="line">	<span class="keyword">if</span>(sum==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;error&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;sum&lt;&lt;endl;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路">最短路</h2>
<h3 id="单源最短路">单源最短路</h3>
<p>求一个<strong>固定的起点</strong>到各个顶点的最短路径</p>
<h4 id="Bellman-Ford">Bellman-Ford</h4>
<p>时间复杂度O(mn)(==<strong>几乎会超时</strong>==)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bellman_Ford</span><span class="params">(ll n,ll m)</span><span class="comment">//n为点数,m为边数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s]=<span class="number">0</span>;<span class="comment">//s为起点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n<span class="number">-1</span>;j++)<span class="comment">//可以由此限制最短路经过的边数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;i++)</span><br><span class="line">            dist[edge[i].to]=<span class="built_in">min</span>(dist[edge[i].to],dist[edge[i].from]+edge[i].w);</span><br><span class="line">    <span class="comment">//这里简单存储边就行,不需要前向星</span></span><br><span class="line">    <span class="comment">//如果判负环,再将所有边松弛一遍,看看是否还有变化</span></span><br><span class="line">    <span class="keyword">if</span>(dist[finish]&gt;(inf&gt;&gt;<span class="number">1</span>))cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;dist[finish]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="SPFA">SPFA</h4>
<blockquote>
<p>SPFA算法，也就是<strong>队列优化</strong>的Bellman-Ford算法, 期望时间复杂度是 O(m+nlog⁡n) ,其时间复杂度<strong>不稳定</strong>，最坏情况可以被卡成Bellman-Ford, 也就是 O(mn) 。现在不少最短路的题会刻意卡SPFA</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll flag,inqueue[N],dist[N],cnt[N]<span class="comment">//inque判断是否在队列中,dist记录距离,cnt记录入队次数</span></span><br><span class="line">queue&lt;ll&gt;que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(ll s)</span><span class="comment">//s为起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    dist[s]=<span class="number">0</span>;flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">       ll p=que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        inqueue[p]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i=head[p];i;i=edge[i].next)</span><br><span class="line">        &#123;<span class="comment">//这里用链式前向星存储</span></span><br><span class="line">            ll to=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dist[to]&gt;dist[p]+edge[i].val)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[to]=dist[p]+edge[i].val;</span><br><span class="line">               <span class="comment">/* pre[to]=p;*/</span><span class="comment">//逆序记录路径</span></span><br><span class="line">                   cnt[to]=cnt[p]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[to]&gt;=n)<span class="comment">//说明存在赋权环</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!inqueue[to])</span><br><span class="line">                &#123;</span><br><span class="line">                    inqueue[to]=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">queush</span>(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;dist[finish]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dijkstra">Dijkstra</h4>
<blockquote>
<p>Dijkstra基于一种<strong>贪心</strong>的思想，我们假定有一张没有==<strong>负边</strong>==的图,前两种算法==可以处理负边==<br>
时间复杂度为O(mlog⁡m)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;ll,ll&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line">ll dist[N],vis[N];</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt;que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(ll s)</span><span class="comment">//s为起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ll p=que.<span class="built_in">top</span>().se;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[p])<span class="keyword">continue</span>;</span><br><span class="line">        vis[p]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=head[p];i;i=edge[i].next)</span><br><span class="line">        &#123;<span class="comment">//链式前向星存图</span></span><br><span class="line">            ll to=edge[i].to;</span><br><span class="line">            dist[to]=<span class="built_in">min</span>(dist[to],dist[p]+edge[i].val);</span><br><span class="line">            <span class="keyword">if</span> (!vis[to])que.<span class="built_in">push</span>(<span class="built_in">mp</span>(dist[to],to));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多源最短路">多源最短路</h3>
<p>得出<strong>任意两个顶点</strong>之间的最短路径</p>
<h4 id="Floyd">Floyd</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line">ll dist[M][M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dist[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll u,v,w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<span class="comment">//u为起点,v为终点,w为边权值</span></span><br><span class="line">        dist[u][v]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)<span class="comment">//确保 用k尝试过将所有的距离缩短</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>字符串</h1>
<h2 id="字符串">字符串</h2>
<p>子串: <strong>需要连续</strong><br>
子序列: <strong>不需要连续</strong><br>
回文串:正着写和倒着写相同的字符串</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1470">P1470 [USACO2.3]最长前缀 Longest Prefix</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll t,m,n,num,pmt[N][<span class="number">12</span>],loc[N][M],h[N],l,ans;</span><br><span class="line"><span class="type">bool</span> dp[M]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">string s,p[N],x;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll l=p[i].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">if</span>(x&gt;=l&amp;&amp;p[i]==s.<span class="built_in">substr</span>(x-l+<span class="number">1</span>,l)&amp;&amp;dp[x-l])<span class="comment">//dp的思想</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans=x;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(;cin&gt;&gt;x&amp;&amp;x!=<span class="string">&quot;.&quot;</span>;p[++num]=x);</span><br><span class="line">    <span class="keyword">for</span>(;cin&gt;&gt;x;s+=x);</span><br><span class="line">    s=<span class="string">&#x27;-&#x27;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)dp[i]=<span class="built_in">check</span>(i);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hash-哈希">Hash(哈希)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1111111111111111111</span></span><br><span class="line">ll base=<span class="number">63</span>,ans;</span><br><span class="line"><span class="function">ll <span class="title">Hash</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=s.<span class="built_in">size</span>();i++)</span><br><span class="line">	ans=(ans*base+(ll)s[i])%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//任意区间子串哈希值</span></span><br><span class="line">ll h[N], p[N]; </span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//p为base的次数, h为前缀和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i]=(h[i<span class="number">-1</span>]*base+(ll)s[i])%mod;</span><br><span class="line">    p[i]=p[i<span class="number">-1</span>]*base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP">KMP</h2>
<p>时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span></span></span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pmt</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">        <span class="comment">/*//字符串从1开始</span></span><br><span class="line"><span class="comment">         for (int i=1,j=0;i&lt;s.length()-1;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        while(j&amp;&amp;p[i+1]!=p[j+1])j=pmt[j];</span></span><br><span class="line"><span class="comment">		if(p[i+1]==p[j+1])j++;</span></span><br><span class="line"><span class="comment">		pmt[i+1]=j;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(string s,string p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j])j++;</span><br><span class="line">        <span class="keyword">if</span>(j==p.<span class="built_in">length</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i-j+<span class="number">2</span>&lt;&lt;endl;<span class="comment">//位置为第几个所以加1,j在之后加了1,所以再加1</span></span><br><span class="line">            j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Tire-字典树">Tire(字典树)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N </span></span><br><span class="line">ll next[N][<span class="number">26</span>],cnt,exist[N],vis[N]; <span class="comment">// 用类似链式前向星的方式存图，next[i][c]表示i号点所连、存储字符为c+&#x27;a&#x27;的点的编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="built_in">sizeof</span>(next));</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span> <span class="comment">// 插入字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cur=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c:s)</span><br><span class="line">    &#123;<span class="comment">// 尽可能重用之前的路径，如果做不到则新建节点</span></span><br><span class="line">        <span class="keyword">if</span> (!next[cur][c-<span class="string">&#x27;a&#x27;</span>]) </span><br><span class="line">            next[cur][c-<span class="string">&#x27;a&#x27;</span>]=++cnt; </span><br><span class="line">        cur=next[cur][c-<span class="string">&#x27;a&#x27;</span>];<span class="comment">// 继续向下</span></span><br><span class="line">    &#125;</span><br><span class="line">    exist[cur]=<span class="number">1</span>;<span class="comment">//记录插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(string s)</span> <span class="comment">// 查找某个前缀是否出现过</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cur=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">    &#123; <span class="comment">// 沿着前缀所决定的路径往下走，如果中途发现某个节点不存在，说明前缀不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!next[cur][c-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cur=next[cur][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vis[cur]=<span class="number">1</span>;<span class="comment">//记录查询</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3879">P3879 [TJOI2010] 阅读理解</a></p>
<p>使用map代替tire</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;ll,ll&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1111111111111111111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll t,m,n,arr[N];</span><br><span class="line">string s;</span><br><span class="line">map&lt;string,vector&lt;ll&gt;&gt;tire;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">   cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">   cin&gt;&gt;t;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cin&gt;&gt;n;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">      &#123;</span><br><span class="line"> 	    cin&gt;&gt;s;</span><br><span class="line"> 	    tire[s].<span class="built_in">push_back</span>(i);<span class="comment">//直接对应</span></span><br><span class="line">      &#125; </span><br><span class="line">	&#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	cin&gt;&gt;s;</span><br><span class="line">    	<span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in">sizeof</span>(arr));</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> y:tire[s])</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(!arr[y])</span><br><span class="line">        	&#123;</span><br><span class="line">        		cout&lt;&lt;y&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        		arr[y]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="01Tire">01Tire</h2>
<blockquote>
<p>一组数中取==任意==个数求最大/最小异或和可以用线性基，取==两个数==求最大/最小异或和则可以用01字典树解决。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4551">P4551 最长异或路径</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll t,m,n,num,head[N],dis[N],tire[N&lt;&lt;<span class="number">3</span>][<span class="number">2</span>],sign=<span class="number">1</span>,exist[N],u,v,w,sum;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	ll v,w,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll u,ll v,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++num].v=v;</span><br><span class="line">	e[num].w=w;</span><br><span class="line">	e[num].next=head[u];</span><br><span class="line">	head[u]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(e[i].v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		dis[e[i].v]=e[i].w^dis[x];</span><br><span class="line">		<span class="built_in">dfs</span>(e[i].v,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll cur=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;	</span><br><span class="line">	   ll cnt=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">	   <span class="keyword">if</span>(!tire[cur][cnt])</span><br><span class="line">	   tire[cur][cnt]=++sign;</span><br><span class="line">	   cur=tire[cur][cnt];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll cur=<span class="number">1</span>;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		ll cnt=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(tire[cur][cnt^<span class="number">1</span>])</span><br><span class="line">		sum+=(<span class="number">1</span>&lt;&lt;i),cur=tire[cur][cnt^<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> cur=tire[cur][cnt];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">   cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">   <span class="built_in">add</span>(u,v,w);</span><br><span class="line">   <span class="built_in">add</span>(v,u,w);</span><br><span class="line">  &#125;</span><br><span class="line">  dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">insert</span>(dis[i]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum=<span class="built_in">max</span>(sum,<span class="built_in">find</span>(dis[i]));</span><br><span class="line">  cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机-修">AC自动机(修)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree[maxm][<span class="number">26</span>],fail[maxm],flag[maxn],cnt;</span><br><span class="line"><span class="type">char</span> str[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(fail,<span class="number">0</span>,<span class="built_in">sizeof</span>(fail));</span><br><span class="line">	<span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in">sizeof</span>(tree));</span><br><span class="line">	<span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">strlen</span>(ch);</span><br><span class="line">	<span class="type">int</span> root=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> id=ch[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!tree[root][id])</span><br><span class="line">		tree[root][id]=++cnt;</span><br><span class="line">		root=tree[root][id];</span><br><span class="line">	&#125;</span><br><span class="line">	flag[root]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getfail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(tree[<span class="number">0</span>][i])</span><br><span class="line">		&#123;</span><br><span class="line">			fail[tree[<span class="number">0</span>][i]]=<span class="number">0</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(tree[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(tree[now][i])</span><br><span class="line">			&#123;</span><br><span class="line">				fail[tree[now][i]]=tree[fail[now]][i];</span><br><span class="line">				q.<span class="built_in">push</span>(tree[now][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				tree[now][i]=tree[fail[now]][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">strlen</span>(ch);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> id=ch[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		now=tree[now][id];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=now;j&amp;&amp;flag[j]!=<span class="number">-1</span>;j=fail[j])</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=flag[j];</span><br><span class="line">			flag[j]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t,n;</span><br><span class="line">	<span class="type">char</span> ss[<span class="number">60</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss);</span><br><span class="line">			<span class="built_in">insert</span>(ss);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getfail</span>();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="Manacher-修">Manacher(修)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210005</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> S[N],str[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len1,len2,ans,p[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//数组初始化，即数组长度翻倍 </span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span>;<span class="comment">//为了防止数组越界 </span></span><br><span class="line">    str[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; ++i)&#123;</span><br><span class="line">        str[i * <span class="number">2</span> + <span class="number">2</span>] = S[i];</span><br><span class="line">        str[i * <span class="number">2</span> + <span class="number">3</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len2 = len1 * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    str[len2] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;<span class="comment">//manacher </span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>,mx = <span class="number">0</span>;<span class="comment">//mx表示的是当前计算回文串最右边字符的最大值 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; len2; ++i)&#123;</span><br><span class="line">        p[i]=mx &gt; i?<span class="built_in">min</span>(p[id*<span class="number">2</span>-i],mx-i) : <span class="number">1</span>;<span class="comment">//p[i]=mx&gt;i?min(p[id*2-i],m-i):1; </span></span><br><span class="line">        <span class="keyword">for</span>(; str[i+p[i]] == str[i-p[i]]; p[i]++);<span class="comment">//如果字符串对称则对称长度增加 </span></span><br><span class="line">        　　<span class="keyword">if</span>(p[i]+i &gt; mx)<span class="comment">//如果大于当前的最大长度则更新 </span></span><br><span class="line">        　　　　mx = p[i]+i, id = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,S))&#123;</span><br><span class="line">        len1 = <span class="built_in">strlen</span>(S);</span><br><span class="line">        <span class="built_in">manacher</span>();</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len2; ++i)</span><br><span class="line">            maxlen = <span class="built_in">max</span>(p[i], maxlen);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxlen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>博弈论</h1>
<h2 id="ICG游戏">ICG游戏</h2>
<p>经典的博弈论游戏Impartial Combinatorial Games</p>
<p><strong>游戏定义</strong></p>
<ul>
<li>玩家只有两个人</li>
<li>游戏给定了状态之间转移的规则</li>
<li>玩家的状态有限</li>
<li>每个人轮流移动</li>
<li>有明确的状态结束情况</li>
</ul>
<p><strong>状态定义</strong></p>
<ul>
<li>必败点 当前玩家无论怎么移动都<strong>只能</strong>转移到必胜点</li>
<li>必胜点 当前玩家<strong>存在</strong>一种可以移动到必败点的方法</li>
<li>最终(结束)点 为必败点</li>
</ul>
<h2 id="Bash-博弈">Bash 博弈</h2>
<blockquote>
<p>只有一堆n个物品 两个人轮流从这对物品取物 规定每次至少取一个 最多取m个 最后取光者胜</p>
</blockquote>
<p>显然 如果n=m+1 由于一次最多只能取m个 所以无论先取者拿走多少个 后取者都能够一次拿走剩余的物品</p>
<p>当n=k(m+1)+x 时 先取者只要保证拿走x个 就能把局面变成 n=k(m+1) 无论后取者拿走多少个 都会重新把局面变回到n=(k-1)(m+1)+k’ 那么最终显然会让后手变成局面n=m+1 这是必输的局面</p>
<h2 id="威佐夫博弈">威佐夫博弈</h2>
<blockquote>
<p>有两堆若干个物品 两个人轮流从某一堆或同时从两堆中取同样任意多的物品 规定每次最少取一个 最后取光获胜</p>
</blockquote>
<p>假设两堆物品的数量为 (n,m)  那么该游戏的前几个必败点可枚举出为:</p>
<p>(0,0)  (1,2)  (3,5)  (4,7)  (6,10)  (8,13)  (9,15)  (11,18)  (12,20) …</p>
<p>从中找到规律为 第k个必败点为 (x,x+k)  k从0开始  x为前面必败点两堆数量中没出现过的最小自然数</p>
<p><strong>胜负手交换</strong></p>
<p>可以证明出  当在必败点的时候 肯定会转移到必胜点   因为假设只改变一堆物品的数量  那么另一个数量固定  这样的组合肯定不存在于必败点中  而假设改变了两队物品的数量 但是由于其差值不变 那么也比定不存在这样的组合在必败点中</p>
<p>也可以证明出 在必胜点 必定存在一种方式转移到必败点  证略</p>
<p><strong>结论</strong></p>
<p>假设第一堆数目小于第二堆的数目 当<code>n==int((m-n)*(sqrt(5)+1)/2)</code>  (n,m)为必败点</p>
<h2 id="NIM石子游戏">NIM石子游戏</h2>
<blockquote>
<p>有若干堆石子 每堆石子的数量都是有限的 有两个人 每一次操作可以从任意一堆石子中取出任意数量的石子 至少取一颗 至多取完一整堆 (不能跨堆)  两个人轮流行动 取走最后一个石子的人胜利  假设两人都足够聪明 问谁会赢</p>
</blockquote>
<p>结论为 当所有石子堆的异或和为0时 当前选手必输</p>
<p>证明:</p>
<p>当石子堆的异或和<strong>等于k</strong>的时候(k!=0) 那么肯定存在一堆石子X它的二进制的最高位和k的二进制最高位是同一位(否则k的最高位就无法得到)  那么此时只要把X拿剩下X^k时(最高位从1变0  数字大小肯定是变小的了)  之后的石子堆的异或和就会为0</p>
<p>当局面异或和为0的时候 肯定不存在一种删除方式使异或和仍为0  因为异或显然要异或自身才能变为0  假如删除了某一堆 那么原来的堆里的某两个相同数量的异或为0就会被打破  变成异或为非0的</p>
<p>那么到最后 显然可以取到最后一块石头的状态异或0肯定不为0 (因为是只剩下单组了)  因为全0是必败点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">stones</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">nim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        ans^=stones[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SG函数">SG函数</h2>
<p>可以解决多个不同的组合博弈游戏的问题</p>
<h3 id="mex运算">mex运算</h3>
<p>定义mex(minimal excludant)为一个集合运算   mex(S) 表示最小的不属于这个集合的非负数</p>
<p>如 mex({0,1,2,4})=3  mex({2,3,5})=0</p>
<p>该运算主要是用来作必胜点和必败点之间的转移</p>
<h3 id="SG数组">SG数组</h3>
<p>SG数组是对于 <strong>单个游戏而言的</strong></p>
<p>SG[i] 表示的是一个游戏的<strong>i状态</strong> (状态可以是一个值  也可以是某个集合 视游戏而定) 时候的胜负转移情况</p>
<p>转移方程为:</p>
<ul>
<li>
<p><code>SG[i] = mex(S)</code>    S表示为i状态可以<strong>单步</strong>转移的<strong>所有</strong>状态的<strong>SG值</strong>的<strong>集合</strong> 即若i可以单步转换到a,b,c 的话 那么SG[i] = mex({SG[a],SG[b],SG[c]})</p>
</li>
<li>
<p><code>SG[i]=0</code>  当且仅当i为必败状态时</p>
</li>
<li>
<p><code>SG[end]=0</code> 即结束态SG值为0</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;	<span class="comment">//n表示该游戏有限的状态数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">SG</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m)</span></span>;	<span class="comment">//每一步能如何转换 m表示有多少种转换方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSG</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SG[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//结束状态 不同游戏不一样</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;	<span class="comment">//不一定是这样的顺序转移状态 视游戏而定</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">S</span><span class="params">(n+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;	<span class="comment">//单步能转移的所有状态的SG值集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;f[j]&lt;=i&amp;&amp;j&lt;m;j++)	<span class="comment">//遍历所有单步能转移的方式 然后填充S</span></span><br><span class="line">            S[SG[i-f[j]]]=<span class="literal">true</span>;		<span class="comment">//i-f[j]表示转移后的状态值 视不同游戏而定 不一定是减</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;;j++)	<span class="comment">//其实就是计算mex函数</span></span><br><span class="line">            <span class="keyword">if</span>(!S[j])&#123;</span><br><span class="line">            	SG[i]=j;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sprague-Grundy定理">Sprague-Grundy定理</h3>
<p>游戏和的SG值等于<strong>各个游戏的SG值</strong>的NIM和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> game1_status,game2_status,game3_status;	<span class="comment">//假如有多个游戏的多个初始态	不一定为int类型的状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对不同游戏获取对应的SG值</span></span><br><span class="line"><span class="built_in">getSG1</span>();</span><br><span class="line"><span class="built_in">getSG2</span>();</span><br><span class="line"><span class="built_in">getSG3</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//其组合博弈游戏的答案就是多个游戏的SG值的NIM和</span></span><br><span class="line"><span class="type">int</span> ans=SG1[game1_status]^SG2[game2_status]^SG3[game3_status];</span><br></pre></td></tr></table></figure>
<h2 id="树上删边游戏">树上删边游戏</h2>
<blockquote>
<p>有两个人轮流操作, 每次从一棵树上删除一条边,同时删去所有在删除边后不再和根相连的部分. 无法再进行操作者判定为失败. 一个游戏有多棵树.</p>
</blockquote>
<h3 id="竹子树">竹子树</h3>
<p>引入竹子树的概念 也就是一条链 很显然 当从竹子中砍掉某一节(某条边)之后  其上面的边都会一同删掉 (重力的原因)  因此 这样就等同于你可以一次对一棵竹子树删除任意节</p>
<p>显然 这样就可以转化为NIM游戏了</p>
<h3 id="克朗定理">克朗定理</h3>
<p>对于树上的某个点 它的分支可以转换为以这个点为根的一棵竹子树  这棵竹子树的高度等于它各个竹子树分支边高度的异或和 (显然  根据这个定理 非竹子树边也能转换为竹子树边)</p>
<p>那么最终 树都能转换为竹子树 也就是可以用NIM游戏来解决</p>
<p>其实质是 对于博弈论游戏的大部分问题  只要SG值相同 模型都可以相互转换的</p>
<h2 id="无向图删边游戏">无向图删边游戏</h2>
<blockquote>
<p>有一个无向连通图 有一个点作为图的根 两人轮流从图中删去一条边 不与根节点相连的部分移走</p>
<p>该图会有环 但是保证环没有共用边</p>
</blockquote>
<h3 id="费森定理">费森定理</h3>
<p>图中的简单环可以如下处理:</p>
<ul>
<li>
<p>偶长度环可以缩成一个新点</p>
</li>
<li>
<p>奇长度环可以缩成一个新点加一个新边</p>
</li>
</ul>
<p>这样的改动不会影响图的SG值</p>
<h1>其他</h1>
<h2 id="快读快输">快读快输</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(ll &amp;x)</span></span>&#123; </span><br><span class="line">	ll f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> s=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">&#x27;0&#x27;</span>||s&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(s==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;s=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">&#x27;0&#x27;</span>;s=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(ll X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(X&lt;<span class="number">0</span>) &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); X=~(X<span class="number">-1</span>);&#125;</span><br><span class="line">	ll s[<span class="number">20</span>],top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(X) &#123;s[++top]=X%<span class="number">10</span>; X/=<span class="number">10</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(!top) s[++top]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top) <span class="built_in">putchar</span>(s[top--]+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板">模板</h2>
<h3 id="取模">取模</h3>
<blockquote>
<p>不要<code>#define int long long</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">int</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ModInt</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> mod = T;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(x % mod) &#123;&#125;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">long</span> <span class="type">long</span> x) : <span class="built_in">x</span>(<span class="built_in">int</span>(x % mod)) &#123;&#125; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> + (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x + a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> - (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x - a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; <span class="number">0</span> ? x0 + mod : x0); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> * (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(<span class="number">1LL</span> * x * a.x % mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> / (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> * a.<span class="built_in">inv</span>(); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> x == a.x; &#125;;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> x != a.x; &#125;;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> += (<span class="type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="keyword">if</span> (x &gt;= mod) x -= mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> -= (<span class="type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> *= (<span class="type">const</span> ModInt &amp;a) &#123; x = <span class="number">1LL</span> * x * a.x % mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> /= (<span class="type">const</span> ModInt &amp;a) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> / a; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span> + (<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)&#123; <span class="type">int</span> x0 = y + a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span> - (<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)&#123; <span class="type">int</span> x0 = y - a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; <span class="number">0</span> ? x0 + mod : x0); &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span> * (<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)&#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(<span class="number">1LL</span> * y * a.x % mod);&#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span> / (<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)&#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(y) / a;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> ModInt &amp;a) &#123; <span class="keyword">return</span> os &lt;&lt; a.x;&#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="keyword">return</span> is &gt;&gt; t.x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ModInt <span class="title">pow</span><span class="params">(<span class="type">int64_t</span> n)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">ModInt <span class="title">res</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">mul</span><span class="params">(x)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res *= mul;</span><br><span class="line">            mul *= mul;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ModInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = x, b = mod, u = <span class="number">1</span>, v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = a / b;</span><br><span class="line">            a -= t * b; <span class="built_in">swap</span>(a, b);</span><br><span class="line">            u -= t * v; <span class="built_in">swap</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u &lt; <span class="number">0</span>) u += mod;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> mint = ModInt&lt;<span class="number">998244353</span>&gt;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from jiangly</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">power</span><span class="params">(T a, i64 b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> i64 <span class="title">mul</span><span class="params">(i64 a, i64 b, i64 p)</span> </span>&#123;</span><br><span class="line">    i64 res = a * b - <span class="built_in">i64</span>(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;i64 P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MLong</span> &#123;</span><br><span class="line">    i64 x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MLong</span><span class="params">()</span> : x&#123;</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MLong</span><span class="params">(i64 x)</span> : x&#123;</span><span class="built_in">norm</span>(x % <span class="built_in">getMod</span>())&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> i64 Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> i64 <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(i64 Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">norm</span><span class="params">(i64 x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">i64</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MLong res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MLong <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>*=(MLong rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">mul</span>(x, rhs.x, <span class="built_in">getMod</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>+=(MLong rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>-=(MLong rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>/=(MLong rhs) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>*(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>+(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>-(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>/(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, MLong &amp;a) &#123;</span><br><span class="line">        i64 v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MLong</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> MLong &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">i64 MLong&lt;<span class="number">0LL</span>&gt;::Mod = <span class="built_in">i64</span>(<span class="number">1E18</span>) + <span class="number">9</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MInt</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">()</span> : x&#123;</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">(i64 x)</span> : x&#123;</span><span class="built_in">norm</span>(x % <span class="built_in">getMod</span>())&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(<span class="type">int</span> Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">norm</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MInt res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>*=(MInt rhs) &amp; &#123;</span><br><span class="line">        x = <span class="number">1LL</span> * x * rhs.x % <span class="built_in">getMod</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>+=(MInt rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>-=(MInt rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>/=(MInt rhs) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>*(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>+(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>/(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, MInt &amp;a) &#123;</span><br><span class="line">        i64 v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> MInt &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int</span> MInt&lt;<span class="number">0</span>&gt;::Mod = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> V, <span class="type">int</span> P&gt;</span><br><span class="line"><span class="keyword">constexpr</span> MInt&lt;P&gt; CInv = <span class="built_in">MInt</span>&lt;P&gt;(V).<span class="built_in">inv</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> Z = MInt&lt;P&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="素数筛">素数筛</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; minp,primes;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    minp.<span class="built_in">assign</span>(n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    primes.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(minp[i]==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            minp[i]=i;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*p&gt;n)<span class="keyword">break</span>;</span><br><span class="line">            minp[i*p]=p;</span><br><span class="line">            <span class="keyword">if</span>(p==minp[i])<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合数">组合数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Comb</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;Z&gt; _fac,_invfac,_inv;</span><br><span class="line">    <span class="built_in">Comb</span>():n&#123;<span class="number">0</span>&#125;, _fac&#123;<span class="number">1</span>&#125;, _invfac&#123;<span class="number">1</span>&#125;, _inv&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">Comb</span>(<span class="type">int</span> n):<span class="built_in">Comb</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> m)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=n)<span class="keyword">return</span>;</span><br><span class="line">        _fac.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">        _invfac.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">        _inv.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">         _fac[i]=_fac[i<span class="number">-1</span>]*i;</span><br><span class="line">        _invfac[m]=_fac[m].<span class="built_in">inv</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;n;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _invfac[i<span class="number">-1</span>]=_invfac[i]*i;</span><br><span class="line">            _inv[i]=_invfac[i]*_fac[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        n=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">fac</span><span class="params">(<span class="type">int</span> m)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)<span class="built_in">init</span>(<span class="number">2</span>*m);</span><br><span class="line">        <span class="keyword">return</span> _fac[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">invfac</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)<span class="built_in">init</span>(<span class="number">2</span>*m);</span><br><span class="line">        <span class="keyword">return</span> _invfac[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">(<span class="type">int</span> m)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)<span class="built_in">init</span>(<span class="number">2</span>*m);</span><br><span class="line">        <span class="keyword">return</span> _inv[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">binom</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;m||m&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fac</span>(n)*<span class="built_in">invfac</span>(m)*<span class="built_in">invfac</span>(n-m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; comb;</span><br></pre></td></tr></table></figure>
<h3 id="并查集">并查集</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<h3 id="归并排序">归并排序</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> arr[<span class="number">100</span>],tem[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;	</span><br><span class="line">    <span class="type">int</span>	mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line">	<span class="built_in">merge</span>(l,mid),<span class="built_in">merge</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">for</span>( i=l,j=mid+<span class="number">1</span>;i&lt;=mid&amp;&amp;j&lt;=r;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;=arr[j])tem[k++]=arr[i++];</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">		   tem[k++]=arr[j++];</span><br><span class="line">            num+=mid+<span class="number">1</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)tem[k++]=arr[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r)tem[k++]=arr[j++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=l;x&lt;=r;x++)arr[x]=tem[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序">快速排序</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low; </span><br><span class="line">    <span class="type">int</span> j = high;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= j) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> temp = array[low];</span><br><span class="line">    <span class="keyword">while</span>(i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(array[j] &gt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">while</span>(array[i] &lt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(array[i], array[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将基准temp放于自己的位置，（第i个位置）</span></span><br><span class="line">    <span class="built_in">swap</span>(array[low], array[i]);</span><br><span class="line">    <span class="built_in">QuickSort</span>(array, low, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(array, i + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序">堆排序</h3>
<p>见<a href="#%E5%A0%86%E6%8E%92%E5%BA%8F(%E5%B0%8F%E9%A1%B6%E5%A0%86)">堆排序(小顶堆)</a></p>
<h3 id="sort-stl">sort(stl)</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a%<span class="number">10</span>&gt;b%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(arr+<span class="number">1</span>,arr+n+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//sort(arr+1,arr+n+1,cmp);</span></span><br></pre></td></tr></table></figure>
<h2 id="大整数运算">大整数运算</h2>
<h3 id="比较函数">比较函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span>		<span class="comment">//小于返回真</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>())<span class="keyword">return</span> A.<span class="built_in">size</span>()&lt;B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)		<span class="comment">//因为是倒序的</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i])<span class="keyword">return</span> A[i]&lt;B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">&#125;	<span class="comment">//只有!cmp(A,B)&amp;&amp;!cmp(B,A)才是相等</span></span><br></pre></td></tr></table></figure>
<h3 id="加法">加法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C=A+B  A&gt;=0  B&gt;=0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span>	<span class="comment">//返回的是倒序的大整数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>()&lt;(<span class="type">int</span>)B.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="built_in">add</span>(B,A);	<span class="comment">//保证A比B长</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;		<span class="comment">//答案数组</span></span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)A.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t+=A[i];	<span class="comment">//+A</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;(<span class="type">int</span>)B.<span class="built_in">size</span>())t+=B[i];	<span class="comment">//如果B位数还有 +B</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);		<span class="comment">//此处的10代表数组每个下标只存一位</span></span><br><span class="line">        t/=<span class="number">10</span>;					<span class="comment">//根据需求还可以进行把多位数大数压进一个下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t)C.<span class="built_in">push_back</span>(t);	<span class="comment">//还有剩的进位  加法保证进位只有一次</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="减法">减法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C=A-B  A&gt;=0  B&gt;=0  A&gt;=B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span>	<span class="comment">//返回的是倒序的大整数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;	<span class="comment">//答案数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,t=<span class="number">0</span>;i&lt;(<span class="type">int</span>)A.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t=A[i]-t;	<span class="comment">//A-借位</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;(<span class="type">int</span>)B.<span class="built_in">size</span>())t-=B[i];		<span class="comment">//如果B还有就 -B</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);		<span class="comment">//防止减到负数	此处的10可以是更大</span></span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">0</span>;		<span class="comment">//借位判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)C.<span class="built_in">pop_back</span>();	<span class="comment">//去掉前缀0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="乘法">乘法</h3>
<h4 id="大整数乘整数">大整数乘整数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C=A*b  A&gt;=0  b&gt;0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> b)</span>	<span class="comment">//返回的是倒序的大整数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;	<span class="comment">//答案数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,t=<span class="number">0</span>;i&lt;(<span class="type">int</span>)A.<span class="built_in">size</span>()||t;i++)		<span class="comment">//当A还有位数或者t还有进位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;(<span class="type">int</span>)A.<span class="built_in">size</span>())t+=A[i]*b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);		<span class="comment">//此处的10可以是更大</span></span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大整数乘大整数">大整数乘大整数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C=A*B  A&gt;=0  B&gt;=0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span>	<span class="comment">//返回的是倒序的大整数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s1=(<span class="type">int</span>)A.<span class="built_in">size</span>(),s2=(<span class="type">int</span>)B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(s1+s2,<span class="number">0</span>)</span></span>;	<span class="comment">//答案数组且初始化为s1+s2长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1;i++)	</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s2;j++)&#123;</span><br><span class="line">            <span class="type">int</span> sum=C[i+j]+A[i]*B[j];	<span class="comment">//当前位数相乘加上进位</span></span><br><span class="line">            C[i+j]=sum%<span class="number">10</span>;		<span class="comment">//答案当前位写入	此处的10可以是更大</span></span><br><span class="line">            C[i+j+<span class="number">1</span>]+=sum/<span class="number">10</span>;	<span class="comment">//进位</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)C.<span class="built_in">pop_back</span>();	<span class="comment">//去除前缀0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="除法">除法</h3>
<h4 id="整数除以整数">整数除以整数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A/b=C......r  A&gt;=0  b&gt;0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">div</span>(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b,<span class="type">int</span> &amp;r)	<span class="comment">//返回的是倒序的大整数	余数存在r中</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(<span class="type">int</span>)A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)	<span class="comment">//从前往后除</span></span><br><span class="line">    &#123;</span><br><span class="line">        r=r*<span class="number">10</span>+A[i];	<span class="comment">//模拟加0</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);	<span class="comment">//商</span></span><br><span class="line">        r%=b;	<span class="comment">//余数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());	<span class="comment">//把正序的反过来</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)C.<span class="built_in">pop_back</span>();	<span class="comment">//去除前缀0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大整数除以大整数">大整数除以大整数</h4>
<blockquote>
<p>利用的是减法,把除数扩大等价于把减的次数扩大</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A/B=C  A&gt;=0  B&gt;0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,vector&lt;<span class="type">int</span>&gt; B)</span>	<span class="comment">//返回的是倒序的大整数且此处会修改AB</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s1=A.<span class="built_in">size</span>(),s2=B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> d=s1-s2;	<span class="comment">//相差位数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(d+<span class="number">1</span>,<span class="number">0</span>)</span></span>;	<span class="comment">//答案数组  大小最大为长度相差+1</span></span><br><span class="line">    <span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(),B.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;d;i++)B.<span class="built_in">push_back</span>(<span class="number">0</span>);		<span class="comment">//在后面补0	即扩大倍数</span></span><br><span class="line">    <span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(),B.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=d;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">cmp</span>(A,B))&#123;		<span class="comment">//当A大于等于B的时候	当A无法再进行减法的时候结束</span></span><br><span class="line">            A=<span class="built_in">sub</span>(A,B);		<span class="comment">//减去</span></span><br><span class="line">            C[d-i]++;		<span class="comment">//对应商的位数计数++</span></span><br><span class="line">        &#125;</span><br><span class="line">        B.<span class="built_in">erase</span>(B.<span class="built_in">begin</span>());	<span class="comment">//缩小减数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)C.<span class="built_in">pop_back</span>();		<span class="comment">//去除前缀0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取模-2">取模</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mod</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        ans=(ans*<span class="number">10</span>+A[i])%mod;		<span class="comment">//每步取模</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出">输出</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_num</span><span class="params">(vector&lt;<span class="type">int</span>&gt; num)</span>	<span class="comment">//输出大整数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(<span class="type">int</span>)num.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num[i]);	<span class="comment">//根据压位的数可以改变输出的位数 如 %08d</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="位运算">位运算</h2>
<h3 id="lowbit">lowbit</h3>
<blockquote>
<p>一个数二进制最右边的1与后面的0组成的数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求二进制数1的个数">求二进制数1的个数</h3>
<blockquote>
<p>直接通过公式: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\&amp;(x-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>因此可以得到一个数二进制1的个数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">num_of_1</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用库函数求</span></span><br><span class="line">__builtin_popcount();	<span class="comment">//返回二进制的1的个数 部分编译器不能用</span></span><br></pre></td></tr></table></figure>
<h3 id="预处理多个数的二进制1的个数">预处理多个数的二进制1的个数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="枚举集合的所有非空子集">枚举集合的所有非空子集</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> S;	<span class="comment">//某个集合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> sub=S;sub;sub=(sub<span class="number">-1</span>)&amp;S)</span><br><span class="line">    <span class="comment">//do something</span></span><br></pre></td></tr></table></figure>
<h3 id="暴力搜索">暴力搜索</h3>
<p>当题目说求某个合法子集的最大长度时</p>
<p>且集合总大小较小(&lt;20)</p>
<p>可以用位运算枚举出所有情况</p>
<h2 id="常用数">常用数</h2>
<h3 id="int">int</h3>
<p>2^31^-1=2147483647</p>
<h3 id="memset-arr-0x3f-sizeof-arr">memset(arr,0x3f,sizeof(arr))</h3>
<h3 id="大质数">大质数</h3>
<p>998244353<br>
1e9+7<br>
212370440130137957  (18位数)<br>
1111111111111111111 (19个1)</p>
<h2 id="一些函数用法">一些函数用法</h2>
<h3 id="builtin-ctz">builtin_ctz</h3>
<p>求二进制末尾有多少个零</p>
<h3 id="memset">memset</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in">sizeof</span>(arr));<span class="comment">//一般就干这三件事</span></span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">-1</span>,<span class="built_in">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(arr));</span><br></pre></td></tr></table></figure>
<h3 id="max">max</h3>
<ul>
<li>比较的元素的类型一定要一样</li>
</ul>
<h3 id="sort">sort</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr+<span class="number">1</span>,arr+n+<span class="number">1</span>,[&amp;](<span class="type">int</span> i,<span class="type">int</span> j) &#123;</span><br><span class="line">     <span class="keyword">return</span> sum[i]&lt;sum[j];</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="map">map</h3>
<ul>
<li>开map.clear()比memset快</li>
<li>map内部是有序的</li>
</ul>
<h3 id="max-element和min-element">max_element和min_element</h3>
<p>返回的是这一段最大或最小值的地址,可以用*来获取值</p>
<h3 id="substr">substr</h3>
<p>选取指定范围的字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">substr</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="comment">//下标为3的字符开始,选取4个字符</span></span><br></pre></td></tr></table></figure>
<h3 id="reverse">reverse</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="islower">islower</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">islower</span>(a)<span class="comment">//判断是否为小写字母</span></span><br></pre></td></tr></table></figure>
<h3 id="二分查找">二分查找</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), value);</span><br><span class="line">   <span class="comment">//binary_search(arr,arr+n,value)</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),value);</span><br><span class="line"><span class="comment">//只有大于</span></span><br><span class="line"><span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),value);</span><br><span class="line"><span class="comment">//函数lower_bound()在first和last的前闭后开区间进行二分查找，返回大于或等于val的第一个元素的位置，如果所有元素都小于val，则返回last的位置。</span></span><br><span class="line"><span class="comment">// lower_bound(v.begin(),v.end(),value,greater&lt;int&gt;())可查不增数列</span></span><br></pre></td></tr></table></figure>
<h2 id="预编译">预编译</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;ll,ll&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1111111111111111111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">   cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="type">int</span> t; cin&gt;&gt;t;</span><br><span class="line">   <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="超级加速">超级加速</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target(<span class="string">&quot;avx&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse-lm&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fipa-sra&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-pre&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-vrp&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpeephole2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ffast-math&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-spec&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-labels&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fdevirtualize&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcaller-saves&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcrossjumping&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fthread-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-funroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fwhole-program&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-freorder-blocks&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fschedule-insns&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-tail-merge&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fschedule-insns2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fstrict-aliasing&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fstrict-overflow&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcse-skip-blocks&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcse-follow-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-interblock&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpartial-inlining&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;no-stack-protector&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-freorder-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-findirect-inlining&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fhoist-adjacent-loads&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-frerun-cse-after-loop&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-small-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-finline-small-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-switch-conversion&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-foptimize-sibling-calls&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fexpensive-optimizations&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-funsafe-loop-optimizations&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-functions-called-once&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fdelete-null-pointer-checks&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度">时间复杂度</h2>
<p>在竞赛中，一般认为计算机1秒执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">5*10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>次计算</p>
<table>
<thead>
<tr>
<th style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5000</mn></mrow><annotation encoding="application/x-tex">5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5000</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>300</mn></mrow><annotation encoding="application/x-tex">300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">300</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn></mrow><annotation encoding="application/x-tex">25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">25</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span></td>
</tr>
</tbody>
</table>
<h2 id="变量命名常用规则">变量命名常用规则</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">add 加</span><br><span class="line">anc, ancestor 祖先</span><br><span class="line">ans, answer 答案</span><br><span class="line">bel, belong 属于</span><br><span class="line">best 最佳的</span><br><span class="line">build 建立</span><br><span class="line">block 障碍</span><br><span class="line">ch, <span class="type">char</span> 字符</span><br><span class="line">check 判定</span><br><span class="line">color 颜色</span><br><span class="line">cmp, compare 比较</span><br><span class="line">cnt, count 计数器</span><br><span class="line">cur, current 当前量</span><br><span class="line">deg, degree 度数</span><br><span class="line">dep, depth 深度</span><br><span class="line">del, <span class="keyword">delete</span> 删除</span><br><span class="line">delta 增量</span><br><span class="line">diff, difference 差别</span><br><span class="line">dist, distance 距离</span><br><span class="line">div, division 除法，部分</span><br><span class="line">dp 动态规划</span><br><span class="line">edge 边</span><br><span class="line">extra 额外的</span><br><span class="line">fa, father 父亲</span><br><span class="line">factor 因子</span><br><span class="line">flag 标志</span><br><span class="line">flow 流</span><br><span class="line">from 来自</span><br><span class="line">get 得到</span><br><span class="line">Hash 哈希表（hash是保留字）</span><br><span class="line">heap 堆</span><br><span class="line">in 入</span><br><span class="line">ind, index 标号</span><br><span class="line">inq 在队列里</span><br><span class="line">inf, infinity 无穷大</span><br><span class="line">init, initialize 初始化</span><br><span class="line">insert 插入</span><br><span class="line">inv, inverse 翻转，颠倒</span><br><span class="line">last 最后一个</span><br><span class="line">len, length 长度</span><br><span class="line">lim, limit 极限</span><br><span class="line">low, lower 下边的</span><br><span class="line">mat, matrix 矩阵</span><br><span class="line">mid, middle 中间量</span><br><span class="line">mod 模</span><br><span class="line">modify 修改</span><br><span class="line">mp, map 映射</span><br><span class="line">mst 最小生成树</span><br><span class="line">mul, multiply 乘法</span><br><span class="line">node 结点</span><br><span class="line">num, number 数量</span><br><span class="line">nxt 后继（next是保留字）</span><br><span class="line">out 出</span><br><span class="line">pa, pair 对子</span><br><span class="line">pre, precursor 前驱</span><br><span class="line">prime 质数</span><br><span class="line">pos, position 位置</span><br><span class="line">prod, product 乘积</span><br><span class="line">put 放置</span><br><span class="line">que, queue 队列</span><br><span class="line">query 询问</span><br><span class="line">rank 秩</span><br><span class="line">res, result 结果</span><br><span class="line">res, residual 剩余</span><br><span class="line">scc 强连通分量</span><br><span class="line">size 大小</span><br><span class="line">split 分裂</span><br><span class="line">start 开始</span><br><span class="line">stk, stack 栈</span><br><span class="line">str 字符串</span><br><span class="line">suc, succeed 后继</span><br><span class="line">sum 和</span><br><span class="line">tim 时间（time是保留字）</span><br><span class="line">tmp, temporary 临时量</span><br><span class="line">tree 树</span><br><span class="line">to 表目的</span><br><span class="line">unite 联合</span><br><span class="line">up, upper 上边的</span><br><span class="line">update 更新</span><br><span class="line">used 使用过的</span><br><span class="line">val, value 值</span><br><span class="line">vec, vector 向量</span><br><span class="line">vis, visit 访问</span><br><span class="line">zero 零</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.xwysyy.cn">善良的xwysyy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vercel.xwysyy.cn/algorithm/xwysyy%20Algorithm/">https://vercel.xwysyy.cn/algorithm/xwysyy Algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vercel.xwysyy.cn" target="_blank">善良的xwysyy</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a><a class="post-meta__tags" href="/tags/CPP/">CPP</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/course/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="线性代数"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">线性代数</div></div></a></div><div class="next-post pull-right"><a href="/course/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8A%EF%BC%89/" title="离散数学(上)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">离散数学(上)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/tutorial/Codeforces/" title="Codeforces"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/28.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-11</div><div class="title">Codeforces</div></div></a></div><div><a href="/syntax/CPP/C++%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="C++ Lambda表达式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/48.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-19</div><div class="title">C++ Lambda表达式</div></div></a></div><div><a href="/syntax/CPP/CPP/" title="CPP"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-22</div><div class="title">CPP</div></div></a></div><div><a href="/syntax/CPP/multiset(cf-1862-round894-g)/" title="multiset(cf-1862-round894-g)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/43.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="title">multiset(cf-1862-round894-g)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="cols"><div class="col"><div class="container"><div class="front avatarPanel"><div class="inner"><div class="player-title">Attributes</div><div class="player-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></div></div><div class="back attributesPanel"><div class="inner"><div class="player-lv">LV.3</div><div class="player-name">善良的xwysyy</div><div class="attributes-value"><div class="attributes-value-item"><a href="/archives/"><div class="attributes">文章</div><div class="value-bar"><div class="value-bar-fill" style="width:24.00%"><div class="value-bar-fill-in" style="background: rgba(89, 230, 54,0.6)"></div></div></div><span>24/100</span></a></div><div class="attributes-value-item"><a href="/tags/"><div class="attributes">标签</div><div class="value-bar"><div class="value-bar-fill" style="width:17.00%"><div class="value-bar-fill-in" style="background: rgba(224, 20, 20, 0.6)"></div></div></div><span>17/100</span></a></div><div class="attributes-value-item"><a href="/categories/"><div class="attributes">分类</div><div class="value-bar"><div class="value-bar-fill" style="width:7.00%"><div class="value-bar-fill-in" style="background: rgba(30, 97, 226, 0.6)"></div></div></div><span>7/100</span></a></div></div></div></div></div></div><div class="col"><div class="container"><div class="front descriptionPanel"><div class="inner"><div class="player_description"><p>一念净心 花开遍世界<br>每临绝境 峰回路又转<br>但凭净信 自在出乾坤<br>恰似如梦初醒 归途在眼前</p></div><div class="play-bottom"></div></div></div><div class="back buttonPanel"><div class="inner"><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xwysyy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xwysyy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_73844376" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:xwysyy@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><div class="play-bottom"></div></div></div></div></div></div></div><div class="card-widget card-announcement"><div id="welcome-info"></div><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>welcome</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">1.1.</span> <span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">1.2.</span> <span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs"><span class="toc-number">1.2.1.</span> <span class="toc-text">dfs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bfs"><span class="toc-number">1.2.2.</span> <span class="toc-text">bfs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">八数码问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">数论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gcd-lcm"><span class="toc-number">2.1.</span> <span class="toc-text">gcd&amp;lcm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gcd"><span class="toc-number">2.1.1.</span> <span class="toc-text">gcd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lcm"><span class="toc-number">2.1.2.</span> <span class="toc-text">lcm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exgcd-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">exgcd (扩展欧几里得算法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prime-number-%E7%B4%A0%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">Prime number(素数)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%9B%A0%E5%AD%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">处理因子的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B"><span class="toc-number">2.3.2.</span> <span class="toc-text">埃氏筛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B-%E4%BF%AE"><span class="toc-number">2.3.3.</span> <span class="toc-text">线性筛(修)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">2.4.</span> <span class="toc-text">乘法快速幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E5%85%83"><span class="toc-number">2.5.</span> <span class="toc-text">逆元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0-%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E5%8F%96%E6%A8%A1"><span class="toc-number">2.6.</span> <span class="toc-text">组合数(可能需要取模)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">2.6.1.</span> <span class="toc-text">杨辉三角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E4%B9%98"><span class="toc-number">2.6.2.</span> <span class="toc-text">预处理阶乘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">排列数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="toc-number">2.7.1.</span> <span class="toc-text">全排列组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97"><span class="toc-number">2.7.2.</span> <span class="toc-text">全错位排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="toc-number">2.8.</span> <span class="toc-text">卡特兰数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F%E6%B1%82%E8%A7%A3"><span class="toc-number">2.8.1.</span> <span class="toc-text">公式求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E6%8E%A8%E6%B1%82%E8%A7%A3"><span class="toc-number">2.8.2.</span> <span class="toc-text">递推求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="toc-number">2.8.3.</span> <span class="toc-text">高精度卡特兰数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%9F%E6%9C%9Fx"><span class="toc-number">2.9.</span> <span class="toc-text">星期x</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85dp"><span class="toc-number">3.1.</span> <span class="toc-text">背包dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="toc-number">3.1.1.</span> <span class="toc-text">01背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">3.1.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.3.</span> <span class="toc-text">多重背包(二进制优化)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="toc-number">3.1.4.</span> <span class="toc-text">分组背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%85%E8%A1%8C%E5%95%86%E7%9A%84%E8%83%8C%E5%8C%85"><span class="toc-number">3.1.5.</span> <span class="toc-text">旅行商的背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86"><span class="toc-number">3.1.6.</span> <span class="toc-text">正整数划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LCS-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">LCS(最长公共子序列)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIS-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">LIS(最长上升子序列)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2dp"><span class="toc-number">3.4.</span> <span class="toc-text">树形dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85"><span class="toc-number">3.4.1.</span> <span class="toc-text">树形背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2dp-2"><span class="toc-number">3.4.2.</span> <span class="toc-text">树形dp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E6%A0%B9dp-%E4%BF%AE"><span class="toc-number">3.4.3.</span> <span class="toc-text">换根dp(修)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98"><span class="toc-number">3.4.4.</span> <span class="toc-text">题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">4.1.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-%E5%B0%8F%E9%A1%B6%E5%A0%86"><span class="toc-number">4.1.1.</span> <span class="toc-text">堆排序(小顶堆)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%88%A0%E5%A0%86"><span class="toc-number">4.1.2.</span> <span class="toc-text">可删堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIT-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.</span> <span class="toc-text">BIT(树状数组)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment-Tree-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">4.3.</span> <span class="toc-text">Segment Tree(线段树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ST%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">ST表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSU-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.5.</span> <span class="toc-text">DSU(并查集)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.5.1.</span> <span class="toc-text">并查集模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">4.5.2.</span> <span class="toc-text">路径压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6"><span class="toc-number">4.5.3.</span> <span class="toc-text">按秩合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.5.4.</span> <span class="toc-text">带权并查集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84-%E4%BF%AE"><span class="toc-number">4.6.</span> <span class="toc-text">树的简单结构(修)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BF%AE"><span class="toc-number">4.6.1.</span> <span class="toc-text">满二叉树(修)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BF%AE"><span class="toc-number">4.6.2.</span> <span class="toc-text">完全二叉树(修)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-%E4%BF%AE"><span class="toc-number">4.6.3.</span> <span class="toc-text">二叉查找树(修)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BF%AE"><span class="toc-number">4.6.4.</span> <span class="toc-text">线索二叉树(修)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-%E4%BF%AE"><span class="toc-number">4.7.</span> <span class="toc-text">哈夫曼树(修)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E6%A0%91"><span class="toc-number">4.7.1.</span> <span class="toc-text">建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">4.7.2.</span> <span class="toc-text">哈夫曼编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E8%AF%91%E7%A0%81"><span class="toc-number">4.7.3.</span> <span class="toc-text">哈夫曼译码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E4%BF%AE"><span class="toc-number">4.8.</span> <span class="toc-text">单调队列(修)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88-%E4%BF%AE"><span class="toc-number">4.9.</span> <span class="toc-text">单调栈(修)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSU-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E4%BF%AE"><span class="toc-number">4.10.</span> <span class="toc-text">DSU(并查集)(修)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.10.1.</span> <span class="toc-text">朴素并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.10.2.</span> <span class="toc-text">高度并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.10.3.</span> <span class="toc-text">维护集合大小的路径压缩并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E9%93%BE%E9%95%BF%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.10.4.</span> <span class="toc-text">维护链长的路径压缩并查集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E9%A1%B6%E5%A0%86-%E4%BF%AE"><span class="toc-number">4.11.</span> <span class="toc-text">对顶堆(修)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84dfs%E5%BA%8F-%E4%BF%AE"><span class="toc-number">4.12.</span> <span class="toc-text">树的dfs序(修)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">几何</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9C%86%E5%92%8C%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E9%87%8D%E5%8F%A0-%E4%BF%AE"><span class="toc-number">5.1.</span> <span class="toc-text">判断圆和矩形是否重叠(修)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%86%E8%A6%86%E7%9B%96%E6%9C%80%E5%A4%9A%E7%82%B9%E9%97%AE%E9%A2%98-%E4%BF%AE"><span class="toc-number">5.2.</span> <span class="toc-text">圆覆盖最多点问题(修)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8-%E4%B8%8D%E8%A6%81%E5%BF%98%E4%BA%86%E4%B8%A4%E5%80%8D%E6%95%B0%E7%BB%84-%E5%8F%8C%E5%90%91%E8%BE%B9"><span class="toc-number">6.1.</span> <span class="toc-text">图的存储(不要忘了两倍数组 双向边)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">6.1.1.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F"><span class="toc-number">6.1.2.</span> <span class="toc-text">链式前向星</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">6.1.3.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE-%E4%BF%AE"><span class="toc-number">6.2.</span> <span class="toc-text">二分图(修)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%89%88"><span class="toc-number">6.2.1.</span> <span class="toc-text">并查集版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">6.2.2.</span> <span class="toc-text">染色法判断二分图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E6%B1%82%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="toc-number">6.2.3.</span> <span class="toc-text">匈牙利算法求二分图最大匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="toc-number">6.4.</span> <span class="toc-text">树的重心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-%E4%BF%AE"><span class="toc-number">6.5.</span> <span class="toc-text">树的直径(修)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-DFS"><span class="toc-number">6.5.1.</span> <span class="toc-text">BFS&#x2F;DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2dp-3"><span class="toc-number">6.5.2.</span> <span class="toc-text">树形dp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.6.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal"><span class="toc-number">6.6.1.</span> <span class="toc-text">Kruskal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prim"><span class="toc-number">6.6.2.</span> <span class="toc-text">prim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim-Heap"><span class="toc-number">6.6.3.</span> <span class="toc-text">Prim_Heap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">6.7.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">6.7.1.</span> <span class="toc-text">单源最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bellman-Ford"><span class="toc-number">6.7.1.1.</span> <span class="toc-text">Bellman-Ford</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPFA"><span class="toc-number">6.7.1.2.</span> <span class="toc-text">SPFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra"><span class="toc-number">6.7.1.3.</span> <span class="toc-text">Dijkstra</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">6.7.2.</span> <span class="toc-text">多源最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd"><span class="toc-number">6.7.2.1.</span> <span class="toc-text">Floyd</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">7.1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash-%E5%93%88%E5%B8%8C"><span class="toc-number">7.2.</span> <span class="toc-text">Hash(哈希)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-number">7.3.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tire-%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">7.4.</span> <span class="toc-text">Tire(字典树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01Tire"><span class="toc-number">7.5.</span> <span class="toc-text">01Tire</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E4%BF%AE"><span class="toc-number">7.6.</span> <span class="toc-text">AC自动机(修)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manacher-%E4%BF%AE"><span class="toc-number">7.7.</span> <span class="toc-text">Manacher(修)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">博弈论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ICG%E6%B8%B8%E6%88%8F"><span class="toc-number">8.1.</span> <span class="toc-text">ICG游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash-%E5%8D%9A%E5%BC%88"><span class="toc-number">8.2.</span> <span class="toc-text">Bash 博弈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88"><span class="toc-number">8.3.</span> <span class="toc-text">威佐夫博弈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIM%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F"><span class="toc-number">8.4.</span> <span class="toc-text">NIM石子游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SG%E5%87%BD%E6%95%B0"><span class="toc-number">8.5.</span> <span class="toc-text">SG函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mex%E8%BF%90%E7%AE%97"><span class="toc-number">8.5.1.</span> <span class="toc-text">mex运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SG%E6%95%B0%E7%BB%84"><span class="toc-number">8.5.2.</span> <span class="toc-text">SG数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sprague-Grundy%E5%AE%9A%E7%90%86"><span class="toc-number">8.5.3.</span> <span class="toc-text">Sprague-Grundy定理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%88%A0%E8%BE%B9%E6%B8%B8%E6%88%8F"><span class="toc-number">8.6.</span> <span class="toc-text">树上删边游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%B9%E5%AD%90%E6%A0%91"><span class="toc-number">8.6.1.</span> <span class="toc-text">竹子树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8B%E6%9C%97%E5%AE%9A%E7%90%86"><span class="toc-number">8.6.2.</span> <span class="toc-text">克朗定理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E5%88%A0%E8%BE%B9%E6%B8%B8%E6%88%8F"><span class="toc-number">8.7.</span> <span class="toc-text">无向图删边游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B9%E6%A3%AE%E5%AE%9A%E7%90%86"><span class="toc-number">8.7.1.</span> <span class="toc-text">费森定理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E8%AF%BB%E5%BF%AB%E8%BE%93"><span class="toc-number">9.1.</span> <span class="toc-text">快读快输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">9.2.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%A8%A1"><span class="toc-number">9.2.1.</span> <span class="toc-text">取模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E7%AD%9B"><span class="toc-number">9.2.2.</span> <span class="toc-text">素数筛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-number">9.2.3.</span> <span class="toc-text">组合数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">9.2.4.</span> <span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.1.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.2.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.3.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-stl"><span class="toc-number">9.3.4.</span> <span class="toc-text">sort(stl)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">9.4.</span> <span class="toc-text">大整数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.1.</span> <span class="toc-text">比较函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95"><span class="toc-number">9.4.2.</span> <span class="toc-text">加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E6%B3%95"><span class="toc-number">9.4.3.</span> <span class="toc-text">减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95"><span class="toc-number">9.4.4.</span> <span class="toc-text">乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%95%B4%E6%95%B0"><span class="toc-number">9.4.4.1.</span> <span class="toc-text">大整数乘整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E5%A4%A7%E6%95%B4%E6%95%B0"><span class="toc-number">9.4.4.2.</span> <span class="toc-text">大整数乘大整数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95"><span class="toc-number">9.4.5.</span> <span class="toc-text">除法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%99%A4%E4%BB%A5%E6%95%B4%E6%95%B0"><span class="toc-number">9.4.5.1.</span> <span class="toc-text">整数除以整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E9%99%A4%E4%BB%A5%E5%A4%A7%E6%95%B4%E6%95%B0"><span class="toc-number">9.4.5.2.</span> <span class="toc-text">大整数除以大整数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%A8%A1-2"><span class="toc-number">9.4.6.</span> <span class="toc-text">取模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">9.4.7.</span> <span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">9.5.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lowbit"><span class="toc-number">9.5.1.</span> <span class="toc-text">lowbit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B01%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">9.5.2.</span> <span class="toc-text">求二进制数1的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">9.5.3.</span> <span class="toc-text">预处理多个数的二进制1的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E9%9B%86%E5%90%88%E7%9A%84%E6%89%80%E6%9C%89%E9%9D%9E%E7%A9%BA%E5%AD%90%E9%9B%86"><span class="toc-number">9.5.4.</span> <span class="toc-text">枚举集合的所有非空子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2"><span class="toc-number">9.5.5.</span> <span class="toc-text">暴力搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0"><span class="toc-number">9.6.</span> <span class="toc-text">常用数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#int"><span class="toc-number">9.6.1.</span> <span class="toc-text">int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memset-arr-0x3f-sizeof-arr"><span class="toc-number">9.6.2.</span> <span class="toc-text">memset(arr,0x3f,sizeof(arr))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E8%B4%A8%E6%95%B0"><span class="toc-number">9.6.3.</span> <span class="toc-text">大质数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95"><span class="toc-number">9.7.</span> <span class="toc-text">一些函数用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#builtin-ctz"><span class="toc-number">9.7.1.</span> <span class="toc-text">builtin_ctz</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memset"><span class="toc-number">9.7.2.</span> <span class="toc-text">memset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#max"><span class="toc-number">9.7.3.</span> <span class="toc-text">max</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-number">9.7.4.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">9.7.5.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#max-element%E5%92%8Cmin-element"><span class="toc-number">9.7.6.</span> <span class="toc-text">max_element和min_element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#substr"><span class="toc-number">9.7.7.</span> <span class="toc-text">substr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse"><span class="toc-number">9.7.8.</span> <span class="toc-text">reverse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#islower"><span class="toc-number">9.7.9.</span> <span class="toc-text">islower</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">9.7.10.</span> <span class="toc-text">二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">9.8.</span> <span class="toc-text">预编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E5%8A%A0%E9%80%9F"><span class="toc-number">9.9.</span> <span class="toc-text">超级加速</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">9.10.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">9.11.</span> <span class="toc-text">变量命名常用规则</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 善良的xwysyy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="refresh-cache" type="button" title="刷新缓存" onclick="refreshCache()"><i class="fas fa-refresh"></i></button><button type="button" title="切换背景" onclick="toggleWinbox()"><i class="fas fa-display"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="/js/cursor.js" async></script><script src="/js/jquery.js"></script><script src="/js/foot.js"></script><script defer src="/live2d-widget-master/autoload.js"></script><script async data-pjax src="/js/txmap.js"></script><script async data-pjax src="/js/bb.js"></script><script async data-pjax src="/js/waterfall.js"></script><script src="/js/background.js"></script><script data-pjax>obcboPic()</script><script src="/js/weather.js"></script><script src="http://fw.qq.com/ipaddress"></script><script src="/js/visitor.js"></script><script src="/js/weibo.js"></script><script src="/js/rightside_button1.js"></script><script src="/js/rightside_button2.js"></script><div id="fps"></div><script async data-pjax src="/js/music1.js"></script><script async data-pjax src="/js/music2.js"></script><script async src="/js/music3.js"></script><script src="/js/refresh.js"></script><script src="/js/console.js"></script><script src="/js/pace.js"></script><script src="/js/welcome.js"></script><canvas id="universe"></canvas><script src="/js/universe.js"></script><script src="/js/nav.js"></script><script src="/js/sun_moon.js" async></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="cf题补了吗,ddl赶了吗,考试复习了吗,看完赶紧去学习,上课别看了" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="/css/aplayer.css" media="print" onload="this.media='all'"><script src="/js/aplayer.js"></script><script src="/js/meting.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()"> </div><meting-js id="8265539094" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="contact-info"><div class="option"><i class="fas fa-warning"> </i><div class="bloktop"></div><div class="text"><div class="strip"></div><div class="aside_notice"><h1>警钟长鸣</h1><br>严禁将重要信息（如：key、token、cookie）、标识性信息、隐私性信息上传 <center><h3>遵守网络法规</h3><h3>保护信息安全</h3><h3>尊重个人意愿</h3><h3>警惕隐私泄露</h3><h2>铭记：</h2><h3>源代码面前无秘密</h3><h3>网络流量面前无秘密</h3></center></div></div></div><div class="option"><i class="fas fa-cube"></i><div class="blok"></div><div class="text"><div class="strip"></div><div class="post-reward"><div class="reward-button"><i class="fa-solid fa-bolt"></i></div><div class="reward-main">
<ul class="reward-all">
<li class="reward-item"><a href="https://Li-j-z.github.io" target="_blank">
<img class="post-qr-code-img entered loaded" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64181ed4a682492fccdf27fa.jpg" alt="Li-j-z的魔方小站"></a>
<div class="post-qr-code-desc">Li-j-z的魔方小站</div></li>
<li class="reward-item"><a href="https://www.cnblogs.com/xwysyy/" target="_blank">
<img class="post-qr-code-img entered loaded" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6432d8ed0d2dde5777c73749.png" alt="xwysyy博客园"></a>
<div class="post-qr-code-desc">xwysyy博客园</div></li>
</ul></div></div></div></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:24%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/algorithm/&quot;);" href="javascript:void(0);">algorithm</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/course/&quot;);" href="javascript:void(0);">course</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/project/&quot;);" href="javascript:void(0);">project</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/tutorial/&quot;);" href="javascript:void(0);">tutorial</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/syntax/&quot;);" href="javascript:void(0);">syntax</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/note/&quot;);" href="javascript:void(0);">note</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CPP/&quot;);" href="javascript:void(0);">CPP</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.7.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a><a class="github-badge" target="_blank" href="https://cloud.tencent.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路部署于腾讯云" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-%E8%85%BE%E8%AE%AF%E4%BA%91-pink?style=flat&amp;logo=tencentqq" alt=""/></a><a class="github-badge" target="_blank" href="https://www.xwysyy.cn/" style="margin-inline:5px" data-title="rating" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/dynamic/json?logo=codeforces&amp;label=Codeforces&amp;url=https://codeforces-api.xwysyy.cn/api/codeforces/kmsgk&amp;query=%24.rating&amp;prefix=rating%20&amp;cacheSeconds=86400" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/" style="margin-inline:5px" data-title="萌ICP备20232640号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20232640-fe1384?style-flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAAByxJREFUSInl1nlwVeUZx/HPuTckkD0kQFiCEEIUlNUCAqKoSBV1AIt1ikpVLFbLONjWGUXbmWrbweJMy7hUxbbTjsUq6KCiWEvr0kE2WVK2QCKBJCxJgEASsienfxwqMob+3Zm+f93z3vM+32f5vc9z+H9bwVcfOp/YQ+1prhhEZS1VDQzqQ1MjiQmIC5Liwm3lBWpqFimrulb/7A/067vM2IsOBZ2h8MhJQW6KMDNVsKeaizKEyUlsKueqgWJ39AMJF3QpDCNYr1SaEig/lWNX2Z1h6dH5/lVyGdVIZFf7MHo9bEfh9rCg/+8NyHlN77QTsnpQ0i2y08VK+BosfhbW0cHxqmSfFd9qW+l9Pi+5WltFdGTsOBbO5dJcdh3lN5+xff0Y2zuelXjRsyYUrjOu4BVJaavlpbWIJRBLOM+J81O95AAnTtM9vNHGknut3zdT48FutJE3koWTuG4oSXH+VsInX3B9IdcVUNfCuv08t4GjO6NspOa3BNcOXx1eOugVHQnrTMkTuyWrC/BjRZO9uPYTpw7HhTWkXcLd45l9GblpHD7NWzt5ZTMXZ/OdkTy+lvR07rmcmWffq6pn9W5e/oymfcT6kJbXHiydMyVYkL/x66n+ZMcctQfjhgxl6UIGZ3Ooltd2RIZqjqKRS0ew9cFIA1cO5urlLHuPZWsZPJiZw7gqn0VT2HCIR9+jvCQhfHPrLGyE2Hng2roBxHnmJoZnc9drbD3I6QaaWkjpSVoeu4+x5XB05qMDqCenHz37UHmcFRv54ZuMeoYrB/L0DPRgZ0WfrsXVKzPX3nYykrn3dUZl8+Q0Qox/gc/L6ZlKzxQefo+UROpa6Z4VCedkPd8YyJYHI3u5T/HAShZNQxsXZfR3pCtwRW066VEeOuIUVUf77+9jTw2pycTOJml7Je1t9EgiI5X2jkgyze1fCSSdtjhBiJCkpKyuI+5oTdAtkTCgVwrbKsl8ko6QjO40tZ67EpkpdIbRf20dkbPpPTjdwsSX6I5dJYy4hoQAaZQdDy4A1iEMI613T6LtBPXJpPakrjGqc1Y6CTFq62htJp5KRwPJKWSkU3WKiiPEEqO6xgM6oZmctJhDXYH7Z59xuCyKpK6R26ZE+ys3MWYoN1/Mc5uoqmbEQJ6fTc/ulJ3i/lUc+YIfzeKhKzjVHN31A3XRHddKSrf6/6DOV3VTcw1hVKfkxOhaPDAe1UwfwmNTqT1Drxw+nE9xNXetIjHG2vnoxoT+rNrN2Of58Rp6JZ+ldKes5kjX4G7dKuikpoERfaltYnQ/DOSS3hEAFk9lXQkLnmf7Ib65lPJT3HU1+46Tm8rYvgzKYVA2h+vQIMjvewHwdSN20MiOSmZczO4a1hSzYi77T7CiiPF5JMTZexjJ5OagkwNV9M+MnJ09nKU3smgyQ3PYWoEO4fUjii4QceJmevJuMeP6csUAln4atcbSGoqOUpjD30uZNwnpHNtN3lC+NZa1xeT34pGVTJ3PL9+Ohs6GQ8gVtHZs6VLVwZhBReGwoXvt3THM/hP0SWVnCR8f4PMjkffjB/DQS8waxpHFfFgaaeHZDRRtJn0yP5tF31ymFVJ2nN27GD66KBzca2/XEWdkUpD3Fmd4tYj0FMS54Q9UnuaDUv6yE/24ewWP/DU6N/d1fvousYEs28DyLVEvGDOAt/egmSkXv2VYn3NBfpXbua6J8hMFFvy2RHsL+57gmX+w/AN651PfEDWQzLRI+afqIqOxFDJT6Rbn9Bmad3PnTH5wIxOXkJTWGiz57hCDsyqDWVldRNzeyOh+paaPfpFKnvqQX88iZwDVx0lLJqUHbe3EkZ1Odm+yUqK2GHYKmhvIG8fyeTz9IY5x67jnFPapdPDkl6jzwEF9IDjZJlgwfbG+o2u8+g4rd7D/UYI41TXnevV5K4j2q6uESckUP8rvNrH6fUH/sRXB9AlPONMSDZ8uazwoi56JjEyvdftV88jinhf4uIzmJRQOoOYgja0RKAiIBZxpjvZH5tP0c97axcLlyBXOuWZemJTYFFbUCU+1dl3j8PGSyFhnJ7EkYcWh7/njqpep5xfzWTyZZ7dEg73xOJKiGqf3YenNLBjLTz7i539COg/OvSOYO2GFo/VRG0Zwe0YX4Ns3R7NXSCxBeM8IthXfZvGf3xCWc/kkXvg2vVP4YB/rDzC1gGlDo+50/xvs2khKPrNnzAzmTH5HbzR0fkkKro93Ab5vx9kfaGgT3lLA5EyWbRpoTdHbSreOppGJV/PwlRTksK+aZz5l6z+RLBgxaau5k2cJelTKzmRQMq0d51J8UxL+23d1TDTcj7WQllZu4YwxDo+eZc22X9mwd6gN65GIFmQzampxcMOoR1xeuMbpVoqromsXdG3+wmCiekNtfSSmiUNWu2zgap+WjlZW8X11TeNkpWwICvNfCm8u3Cmxg4PN0VdmEJw7/7+0/g32RaqCbhRecAAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" style="margin-inline:5px" data-title="本网站由又拍云提供CDN加速/云存储服务" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-%E5%8F%88%E6%8B%8D%E4%BA%91-00b6ff?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAABs1JREFUSInllv2PVFcZxz/n3LfZmdmd3ZndZWGhhV0qYLaFEgzQpog12tZYbVRCSa00mLap6Q+aNERp5QcVlRhi0GjaGElromI08aU1tMRXWmspRaEVbIDtdimwy77M7uy83Xvn3nP84c7b7oD/QE8yyT13znO/z/f7nOcF3m9L1B4OnNYYEoSG165kGZkukLLjdEmXiew4yum7+4qK31u2rduLFXOgEEoQCrQs9RjepaW2f35Nu/9QqRh4Fi4jrkHCMmhTitlCBcOIoP768CoAzGt5owFLQBKfad/Yflau+Mo4qY0IE8qAUbXUgKT9ctFZVJAzqzcivLN+/JGY0H6HKD0riKGvw7gFWAFtUmMTyFPF5C+Gded2LBmBaB2BAigRyeMJ0jGPgxtiyX+MtW18/ZL1DLEMK/TER9eb+Z2GQGU1CK0b8gKy9uCYYJmQcUCgUm+U0qeGw/R2pIwAdbPvAiE0aAGux0MDc7eJAJ57V7+GZYAQjLDo8yd0z6lAqQ5bBbh+iF8JWxmP5XwSJrhCyz9NJU7mdHwwknOBWEKAAq0EuIrPrKp8d3lb+M/HT/qvlsN2pKNRSoDUXAxSN+eKlWMPD7jrFi3pZc4NeHUh4+zcNMW5q/z47dLhi4X4IHYt2hFDBBFDpUmYJXoNb+y23tzPHlgRfu2F8bZ9s4W2zdgSpap2OopbzsysPUHX85YIcdU1YnxLX5pT0+59w+X4NqwmpgIIgUCxNF4+vsaY2bsknjtq+yYTnsGhMx33H8127SFp03KTBBAT/H3U+qTIZe9ambFfagHOl0OOjJs/wjCZdwtCARI2d899Z0iP7Rkv2J0ngu49xUCvu1R2+sJS6g4MAyF11deasY5+CjBs3jE6f3KrMXlDC/Cfr0xuuegtWYIpmjwXUA7YcbP69tb2ypPfO5naPyJ7d4fKioLUDihdVxZEpI4ApGiEyoKLM8aydyx5J/CXeTE+m5PbkFZV4qpBoPlAJnh7R7rw5G8vm9+/4PfvDg0rSiMdgYraeQ0xGVZu78o9tSUx9ViK0pUGc0CbTNtdu1oYG7Geu+vFAaLbqz0+3B1sf2WKnhcvJ79MvCn21JiKiGIAt6amn9scK+4brpiskOHMKRU/jCSS2xG8ddVbVcOrM54KrBvqoERyO4YqLTaKb76ct7+JtufHfuEyYKIkeoKKpN12ySs1QF28qkJmrL8FuBwqv7HTEELC4b/Fks/EjPgcDq05TeO8EJrhSten35KLDjpmhfd8/QBNYY6clp0twC1LAmGQLJdyCF08gub/MtYCECZni+JBTyYwrKS7ML2UbrxplEwpHeoJHkk9IPO/z3QluKen/GC/MXuM8PrIQkc3+sY298hAwsIQbSvnAWuwpSq3AGesyhhh08EwZKBdHi+EDjEkyxLBm9dtNYjqXx5DTnHvsCeXFCoi1fh6VPEsEYy3ACf1zN9qlRE0whAcdzM/GCk5Hz+W1dv+U0jubFy+aqdpFsCD9en8r4ba9fDLU6mfI8wo7Zqc65Ccru3q6dQtC79EVb6AUc1lQzJakP2jOvUSZrqKUgu0QMvqNgBkyOpk7ndfXKruP+11Pf5uwdgqHYWqHwIIGTTLh88tBN7a3/3i+VF/ZtyzujAFut57a0d0A1sDpdzoUkfMdCTNs4Pm3MG1nfL1Fy7bjxwtxn6IXfOzauNDZ6w8u67Pf/7IQuDB3hSfCMtPHDoX/hTDaJKxXgzR1ca/PjnzxOL47IGgXOYG2+U9f/Gyw1Op31yYsz6LKcEEpZryyPe5d1B+dWnf4rrwdeATo+P0yfBQr53cOVHp2oIjWpo/LgwlZp/etdo78MeJ9DeO5cUmM+fflNcdy9E2ONGkoWvZIQSUFGt63ZNb+hPPzPr1S9KUTlYndizDl1Zan+qOlXNUqobVD2gPMubcyP4PlR57Ix979MhI+9fLRsfH8qJ7OYYNhkZo1dRfNATQ3ebmdq2073KFQTmgFfjG7jjprjgrMsncPb2FDXEKkwRV8BCEGbD7g2LNmdnYwLPn257Gro6kNMaixlQlwJckVXbyvszsBseJTU+VqA4JC4DdisavwNUy2Ia4sCk5OdRvzLxCBXAVj64NdvTGtbf337ETaBvMa3V9EQ2BFbgpkf/XnbHpIUuHF2YrYMqGgPNi3OxJIZQgjYmNidIdYwHfyjpZ3ZGtHN6fXXbOVfE0MebncHXMAUiL4uRHlpQP3pJW+04OC3KhST+tw8k152oJeEpQNGxWx0tP+WGeK0Xbcb3SWCYpTS80ul0lECi0EF6n8LNJOzjThvuHobj/603dTnFcORQDQcf1y937bP0Pc6b8FW3Czt0AAAAASUVORK5CYII=" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" style="margin-inline:5px" data-title="冀ICP备2023010011号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E5%86%80ICP%E5%A4%87-2023010011%E5%8F%B7-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13060602001624" style="margin-inline:5px" data-title="冀公网安备 13060602001624号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E5%86%80%E5%85%AC%E7%BD%91%E5%AE%89%E5%A4%87-13060602001624%E5%8F%B7-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;tutorial/Codeforces/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/28.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;tutorial/Codeforces/&quot;);" href="javascript:void(0);" alt="">Codeforces</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;tutorial/Codeforces/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;algorithm/xwysyy Algorithm/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;algorithm/xwysyy Algorithm/&quot;);" href="javascript:void(0);" alt="">xwysyy Algorithm</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;algorithm/xwysyy Algorithm/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;syntax/LaTeX/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;syntax/LaTeX/&quot;);" href="javascript:void(0);" alt="">LaTeX</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;syntax/LaTeX/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.xwysyy.cn/api?xwysyy",['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620'],'xwysyy')
    }
  </script><!-- hexo injector body_end end --></body></html>