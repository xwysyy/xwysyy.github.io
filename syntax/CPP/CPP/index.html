<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>CPP | 善良的xwysyy</title><meta name="author" content="善良的xwysyy"><meta name="copyright" content="善良的xwysyy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="开始   章节概要：编写一个简单的 C++程序；初识输入输出；使用 C++ 版本的 C 标准库头文件；类简介  编写一个简单的 C++程序   简单示例 &#x2F;&#x2F; 相比C代码，可以省略main(void)的voidint main()&amp;#123;    return 0;&amp;#125;   初识输入输出   程序示例 #include &lt;iostream&gt;int main()&amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP">
<meta property="og:url" content="https://vercel.xwysyy.cn/syntax/CPP/CPP/index.html">
<meta property="og:site_name" content="善良的xwysyy">
<meta property="og:description" content="开始   章节概要：编写一个简单的 C++程序；初识输入输出；使用 C++ 版本的 C 标准库头文件；类简介  编写一个简单的 C++程序   简单示例 &#x2F;&#x2F; 相比C代码，可以省略main(void)的voidint main()&amp;#123;    return 0;&amp;#125;   初识输入输出   程序示例 #include &lt;iostream&gt;int main()&amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vercel.xwysyy.cn/image/img-background/28.jpg">
<meta property="article:published_time" content="2023-07-21T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-06T16:40:38.662Z">
<meta property="article:author" content="善良的xwysyy">
<meta property="article:tag" content="CPP">
<meta property="article:tag" content="syntax">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vercel.xwysyy.cn/image/img-background/28.jpg"><link rel="shortcut icon" href="/img/%E5%A4%B4%E5%83%8F.png"><link rel="canonical" href="https://vercel.xwysyy.cn/syntax/CPP/CPP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":20,"languages":{"author":"作者: 善良的xwysyy","link":"链接: ","source":"来源: 善良的xwysyy","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CPP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-07 00:40:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="/js/echarts.min.js"></script><link rel="stylesheet" type="text/css" href="/css/asidefloat.css"><link rel="stylesheet" type="text/css" href="/css/mystyle.css"><link rel="stylesheet" type="text/css" href="/css/console.css"><link rel="stylesheet" type="text/css" href="/css/double_row.css"><link rel="stylesheet" href="/css/essay_page.css"><link rel="stylesheet" href="/css/todolist.css"><link rel="stylesheet" href="/css/guanyv.css"><link rel="stylesheet" href="/css/weibo.css"><style id="settingStyle"></style><style id="yjjs"></style><style id="themeColor"></style><link rel="stylesheet" type="text/css" href="css/_custom/heoMainColor.css"><link rel="stylesheet" type="text/css" href="css/_custom/categoryBar.css"><script async src="/js/categoryBar.js"></script><link rel="stylesheet" type="text/css" href="css/404.css"><script type="text/javascript" src="js/jquery.min.js"></script><link rel="stylesheet" href="/css/records.css"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3FeErm4Qj3nJOxIa",ck:"3FeErm4Qj3nJOxIa"})</script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="/css/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/log/"><i class="fa-fw fas fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://uptime-kuma.xwysyy.cn/status/monitor"><i class="fa-fw fas fa-shield-alt"></i><span> 监控</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-file-alt"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-chart-area"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li><li><a class="site-page child" href="/ToDoList/"><i class="fa-fw fas fa-bell"></i><span> 待办</span></a></li><li><a class="site-page child" href="/records/"><i class="fa-fw fas fa-comments"></i><span> 文字瞬间</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page child" href="/friends/"><i class="fa-fw fas fa-user-friends"></i><span> 鱼塘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Fireworks"><i class="fa-fw fa fa-fire"></i><span> 烟花</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/reference"><i class="fa-fw fa fa-code"></i><span> 参考</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about-chat/"><i class="fa-fw fas fa-comment"></i><span> 交互版</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-envelope"></i><span> 静态版</span></a></li><li><a class="site-page child" href="/essay/"><i class="fa-fw fas fa-edit"></i><span> 杂谈</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><div id="console"><div class="close-btn" onclick="heo.hideConsole()" href="javascript:void(0);"><i class="fas fa-circle-xmark"></i></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="heo.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最近评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="heo.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><span class="author-content-item-title">寻找感兴趣的领域</span></div><div class="card-tag-cloud"><a href="/tags/CPP/" style="font-size: 1em; color: #d3d3d3">CPP</a> <a href="/tags/CSS/" style="font-size: 1em; color: #d3d3d3">CSS</a> <a href="/tags/ChatGPT/" style="font-size: 1em; color: #d3d3d3">ChatGPT</a> <a href="/tags/Git/" style="font-size: 1em; color: #d3d3d3">Git</a> <a href="/tags/HTML/" style="font-size: 1em; color: #d3d3d3">HTML</a> <a href="/tags/JavaScript/" style="font-size: 1em; color: #d3d3d3">JavaScript</a> <a href="/tags/LaTeX/" style="font-size: 1em; color: #d3d3d3">LaTeX</a> <a href="/tags/MySQL/" style="font-size: 1em; color: #d3d3d3">MySQL</a> <a href="/tags/Python/" style="font-size: 1em; color: #d3d3d3">Python</a> <a href="/tags/Sublime-Text/" style="font-size: 1em; color: #d3d3d3">Sublime Text</a> <a href="/tags/Typora/" style="font-size: 1em; color: #d3d3d3">Typora</a> <a href="/tags/ai/" style="font-size: 1em; color: #d3d3d3">ai</a> <a href="/tags/algorithm/" style="font-size: 1em; color: #d3d3d3">algorithm</a> <a href="/tags/course/" style="font-size: 1em; color: #d3d3d3">course</a> <a href="/tags/project/" style="font-size: 1em; color: #d3d3d3">project</a> <a href="/tags/syntax/" style="font-size: 1em; color: #d3d3d3">syntax</a> <a href="/tags/tutorial/" style="font-size: 1em; color: #d3d3d3">tutorial</a></div></div><div class="console-card history" onclick="heo.hideConsole()"> </div></div></div><div class="button-group"><div class="console-btn-item"> <a class="darkmode_switchbutton" onclick="rm.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="fas fa-moon" style="font-size: 1rem;"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="heo.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="fas fa-arrows-alt-h"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="heo.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="fas fa-keyboard"></i></a></div><div class="console-btn-item" id="assist-open" onclick="heo.hideConsole()" title="无障碍工具栏"><a class="assist-btn"><i class="fas fa-wheelchair"></i></a></div><div class="console-btn-item" id="consoleCommentBarrage" onclick="heo.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="fa-solid fa-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="heo.musicToggle()" title="音乐开关"><a class="music-switch"><i class="fas fa-music"></i></a></div></div><div class="console-mask" onclick="heo.hideConsole()" href="javascript:void(0);"></div></div><header class="post-bg" id="page-header" style="background-image: url('/image/img-background/28.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="善良的xwysyy"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.png"/><span class="site-name">善良的xwysyy</span></a></span><div id="none_space"></div><div class="mask-name-container"><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)">PAGE_NAME</a></center></div><div id="menus"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon fas fa-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">主页</div><div class="back-menu-list"><a class="back-menu-item" href="https://index.xwysyy.cn" title="xwysyy主页" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/%E5%A4%B4%E5%83%8F.jpg"/><span class="back-menu-item-text">xwysyy主页</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客线路</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.xwysyy.cn" title="腾讯云线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube1.png"/><span class="back-menu-item-text">腾讯云主线路</span></a><a class="back-menu-item" href="https://vercel.xwysyy.cn" title="Vercel线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube2.png"/><span class="back-menu-item-text">Vercel线路</span></a><a class="back-menu-item" href="https://www.xwysyy.life" title="Github线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube4.png"/><span class="back-menu-item-text">Github线路</span></a><a class="back-menu-item" href="https://netlify.xwysyy.cn" title="Netlify线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube5.png"/><span class="back-menu-item-text">Netlify线路</span></a><a class="back-menu-item" href="https://xwysyy.pages.dev" title="Cloudflare线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube6.png"/><span class="back-menu-item-text">Cloudflare线路</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">部署项目</div><div class="back-menu-list"><a class="back-menu-item" href="https://pan.xwysyy.cn" title="xwysyy云盘" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube7.png"/><span class="back-menu-item-text">xwysyy云盘</span></a><a class="back-menu-item" href="https://cube.xwysyy.cn" title="Lijz的魔方小站" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube9.png"/><span class="back-menu-item-text">Lijz的魔方小站</span></a><a class="back-menu-item" href="https://chatgpt.xwysyy.cn" title="xwysyy ChatGPT" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube13.png"/><span class="back-menu-item-text">xwysyy ChatGPT</span></a></div></div></div></div><div class="nav-button" id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn"><i class="fas fa-arrow-up"></i><span id="percent" onclick="btf.scrollToDest(0,500)"> </span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/log/"><i class="fa-fw fas fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://uptime-kuma.xwysyy.cn/status/monitor"><i class="fa-fw fas fa-shield-alt"></i><span> 监控</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-file-alt"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-chart-area"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li><li><a class="site-page child" href="/ToDoList/"><i class="fa-fw fas fa-bell"></i><span> 待办</span></a></li><li><a class="site-page child" href="/records/"><i class="fa-fw fas fa-comments"></i><span> 文字瞬间</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page child" href="/friends/"><i class="fa-fw fas fa-user-friends"></i><span> 鱼塘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Fireworks"><i class="fa-fw fa fa-fire"></i><span> 烟花</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/reference"><i class="fa-fw fa fa-code"></i><span> 参考</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about-chat/"><i class="fa-fw fas fa-comment"></i><span> 交互版</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-envelope"></i><span> 静态版</span></a></li><li><a class="site-page child" href="/essay/"><i class="fa-fw fas fa-edit"></i><span> 杂谈</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CPP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-21T16:00:00.000Z" title="发表于 2023-07-22 00:00:00">2023-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-06T16:40:38.662Z" title="更新于 2023-10-07 00:40:38">2023-10-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CPP/">CPP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.8w</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>97分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CPP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1><strong>开始</strong></h1>
<hr>
<blockquote>
<p><strong>章节概要</strong>：编写一个简单的 C++程序；初识输入输出；使用 C++ 版本的 C 标准库头文件；类简介</p>
</blockquote>
<h2 id="编写一个简单的-C-程序"><strong>编写一个简单的 C++程序</strong></h2>
<ul>
<li>
<p><strong>简单示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相比C代码，可以省略main(void)的void</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="初识输入输出"><strong>初识输入输出</strong></h2>
<ul>
<li>
<p><strong>程序示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of them is &quot;</span> &lt;&lt; v1 + v2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>C++的 IO 机制</strong></p>
<blockquote>
<p>1、<strong>C++**包含了一个全面的**标准库</strong>来提供<strong>IO 机制</strong>。其中有<strong>从 C 语言延续而来</strong>的<code>cstdio</code>库和<strong>新的</strong><code>iostream</code>库<br>
2、<code>iostream</code>库包含<strong>两个基础类型</strong>：<code>istream</code>和<code>ostream</code>，分别表示<strong>输入流</strong>和<strong>输出流</strong><br>
3、一个<strong>流</strong>(stream)就是一个<strong>字符序列</strong>，是<strong>从 IO 设备读出</strong>或<strong>写入 IO 设备</strong>的</p>
</blockquote>
</li>
<li>
<p><strong>标准输入输出对象</strong></p>
<blockquote>
<p>1、标准库定义了 4 个<strong>IO 对象</strong><br>
2、为了<strong>处理输入</strong>，我们使用名为<code>cin</code>的<code>istream</code>类型对象，这个对象也被称为<strong>标准输入</strong><br>
3、对于<strong>处理输出</strong>，我们使用名为<code>cout</code>的<code>ostream</code>类型对象，这个对象也被称为<strong>标准输出</strong><br>
4、此外还有其他两个<code>ostream</code>类型对象，名为<code>cerr</code>和<code>clog</code>。其中<code>cerr</code>通常用来<strong>输出警告和错误信息</strong>，<code>clog</code>用来<strong>输出程序运行时的一般性信息</strong></p>
</blockquote>
</li>
<li>
<p><strong>向流写入写出</strong></p>
<blockquote>
<p>1、如果需要使用<code>iostream</code><strong>库中的对象</strong>进行<strong>输入输出</strong>，则需要用到<strong>流插入符</strong>将内容传输给<strong>流</strong><br>
2、<code>&lt;&lt;</code>为<strong>输出运算符</strong>。其<strong>接受两个运算对象</strong>，<strong>左侧</strong>必须是一个<code>ostream</code><strong>对象</strong>，<strong>右侧</strong>的运算对象是<strong>要打印的值</strong>。此运算符将<strong>给定的值写入给定的</strong><code>ostream</code><strong>对象</strong>中<br>
3、<code>&gt;&gt;</code>为<strong>输入运算符</strong>。其与<code>&gt;&gt;</code>类型，它<strong>左侧</strong>接受一个<code>istream</code><strong>对象</strong>，<strong>右侧</strong>接受一个<strong>运算对象</strong>。它从给定的<code>istream</code>中<strong>读入数据</strong>，并<strong>存入给定的对象</strong>中</p>
</blockquote>
</li>
<li>
<p><strong>endl 操纵符</strong></p>
<blockquote>
<p>1、<strong>endl</strong>是一个被称为<strong>操纵符</strong>的<strong>特殊值</strong><br>
2、<strong>endl</strong>的效果是<strong>结束当前行</strong>(有换行效果)，并将与设备关联的<strong>缓冲区</strong>的内容<strong>刷到设备中</strong><br>
3、<strong>缓冲刷新操作</strong>可以保证到目前为止<strong>程序所产生的所有输出</strong>都<strong>真正写入流中</strong>，而不是仅<strong>停留在内存</strong>中等待写入到流中</p>
</blockquote>
</li>
<li>
<p><strong>命名空间</strong></p>
<blockquote>
<p>1、示例程序中使用了<code>std::cout</code>和<code>std::endl</code>，而不是直接的<code>cout</code>和<code>endl</code>。其<strong>前缀</strong><code>std::</code>指出<strong>名字</strong><code>cout</code>和<code>endl</code>是定义在名为<code>std</code>的<strong>命名空间</strong>中的<br>
2、<strong>命名空间</strong>可以帮助我们避免<strong>不经意的名字定义冲突</strong>以及<strong>使用库中相同名字导致的冲突</strong>。<strong>标准库</strong>定义的<strong>所有名字</strong>都在<strong>命名空间</strong><code>std</code>中<br>
3、通过<strong>命名空间</strong>使用<strong>标准库</strong>有一个<strong>副作用</strong>：当使用<strong>标准库</strong>中的<strong>一个名字</strong>时，必须通过<strong>作用域运算符</strong><code>::</code>来<strong>显式声明</strong>我们想使用来自<code>std</code>中的名字，如示例<code>std::cout</code>那样(后续将给出一个更简单的访问标准库名字的方法)</p>
</blockquote>
</li>
</ul>
<h2 id="使用-C-版本的-C-标准库头文件"><strong>使用 C++版本的 C 标准库头文件</strong></h2>
<ul>
<li>
<p><strong>建议使用 C++版本标准库</strong></p>
<blockquote>
<p>1、C++标准库中<strong>兼容了 C 语言的标准库</strong>，其按照如下<strong>命名规则</strong>命名<br>
2、C 语言的头文件形如<code>name.h</code>，C++将其命名为<code>cname</code>。即<strong>去掉</strong><code>.h</code><strong>后缀</strong>，文件名前<strong>添加字母</strong><code>c</code><br>
3、因此<code>stdio.h</code>和<code>cstdio</code><strong>内容是一样的</strong>，而且<code>stdio.h</code>也能在 C++调用，但从<strong>命名规范</strong>上来讲，<code>cstdio</code>更符合 C++的要求<br>
4、特别的，在名为<code>cname</code>的<strong>头文件</strong>定义的<strong>名字</strong>从属于<strong>命名空间</strong><code>std</code>，而原本<code>.h</code>的则不然<br>
5、一般来说，C++程序<strong>应使用名为</strong><code>cname</code><strong>的头文件</strong>，因为这样<strong>标准库的名字</strong>总能在<code>std</code>找到。如果使用<code>.h</code>形式，那么程序员不得不时刻牢记哪些是从 C 语言继承过来的，哪些又是 C++独有的</p>
</blockquote>
</li>
</ul>
<h2 id="类简介"><strong>类简介</strong></h2>
<ul>
<li>
<p>我们将在之后详细学习<strong>类</strong>相关的知识，在此只<strong>简单介绍</strong></p>
</li>
<li>
<p><strong>什么是类</strong></p>
<blockquote>
<p>1、在 C++中，我们通过<strong>定义一个类</strong>来<strong>定义自己的数据结构</strong><br>
2、一个<strong>类</strong>定义了<strong>一个类型</strong>，以及<strong>与之相关的一组操作</strong><br>
3、<strong>类机制</strong>是 C++<strong>最重要的特性之一</strong>。实际上，C++最初的<strong>设计焦点</strong>就是能定义使用上像内置类型一样自然的<strong>类类型</strong></p>
</blockquote>
</li>
<li>
<p>如果要使用一个类，我们需要了解<strong>三件事情</strong>：</p>
<blockquote>
<p>1、类名是什么？<br>
2、它在哪里定义的？<br>
3、它支持什么操作？</p>
</blockquote>
</li>
</ul>
<hr>
<h1><strong>变量和基本类型</strong></h1>
<hr>
<blockquote>
<p><strong>章节概要</strong>：基本内置类型；指定字面量类型；变量；对象；列表初始化；C++关键字；复合类型；引用；指针；void* 指针；<code>const</code>限定符；<code>const</code>的引用；<code>constexpr</code>和常量表达式；处理类型；类型别名；<code>auto</code>类型说明符；<code>decltype</code>类型指示符；自定义数据结构；定义类；使用类</p>
</blockquote>
<h2 id="基本内置类型"><strong>基本内置类型</strong></h2>
<ul>
<li>
<p><strong>基本数据类型</strong></p>
<blockquote>
<p>1、C++定义了一套包括<strong>算术类型</strong>和<strong>空类型</strong>在内的<strong>基本数据类型</strong><br>
2、其中<strong>算术类型</strong>包含了<strong>整型</strong>、<strong>浮点型</strong>、<strong>字符型</strong>、<strong>布尔型</strong><br>
3、<strong>空类型 void</strong>不对应<strong>具体的值</strong>，仅用于一些<strong>特殊的场合</strong></p>
</blockquote>
</li>
<li>
<p>C++的<strong>基本数据类型</strong>与 C 语言<strong>规则相同</strong>，但 C++中<strong>直接支持</strong>了<strong>bool 类型</strong>，且<code>iostream</code>中<strong>直接支持</strong>了<strong>拓展类型</strong>(如<code>int32_t</code>等)</p>
</li>
<li>
<p><strong>指定字面量类型</strong></p>
<ul>
<li>
<p>通过添加<strong>前缀或后缀</strong>，可以改变不同类型<strong>字面量</strong>的<strong>默认类型</strong></p>
</li>
<li>
<p><strong>指定字符和字符串字面量</strong></p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>char16_t</td>
<td>Unicode 16 字符</td>
</tr>
<tr>
<td>U</td>
<td>char32_t</td>
<td>Unicode 32 字符</td>
</tr>
<tr>
<td>L</td>
<td>wchar_t</td>
<td>宽字符</td>
</tr>
<tr>
<td>u8</td>
<td>char</td>
<td>UTF-8(仅用于字符串字面常量)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>指定整型字面量</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u 或 U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l 或 L</td>
<td>long</td>
</tr>
<tr>
<td>ll 或 LL</td>
<td>long long</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>指定浮点型字面量</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>f 或 F</td>
<td>float</td>
</tr>
<tr>
<td>l 或 L</td>
<td>long double</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h2 id="变量"><strong>变量</strong></h2>
<ul>
<li>
<p><strong>变量</strong></p>
<blockquote>
<p>1、<strong>变量</strong>提供一个<strong>具名的</strong>、<strong>可供程序操作的存储空间</strong><br>
2、C++中的每个变量都有其<strong>数据类型</strong>，<strong>数据类型</strong>决定着变量所占<strong>内存空间</strong>的<strong>大小及布局方式</strong>、该空间<strong>能存储值的范围</strong>，以及变量<strong>能参与的运算</strong><br>
3、对于 C++程序员来说，<strong>变量</strong>和<strong>对象</strong>一般可以<strong>互换使用</strong></p>
</blockquote>
</li>
<li>
<p><strong>对象</strong></p>
<blockquote>
<p>1、C++程序员在很多场合都会使用<strong>对象</strong>这个名词。通常情况下，<strong>对象</strong>指一块<strong>能存储数据</strong>并<strong>具有某种类型</strong>的<strong>内存空间</strong><br>
2、一部分人对<strong>对象</strong>的定义并不相同，比如：一些人仅在<strong>与类有关</strong>的场景才使用<strong>对象</strong>这个词；另一些人把<strong>命名了的对象</strong>叫做<strong>变量</strong>；还有一些人把<strong>对象</strong>和<strong>值</strong>区分开来，<strong>对象</strong>指<strong>能被程序修改的数据</strong>，而<strong>值</strong>指<strong>只读的数据</strong></p>
</blockquote>
</li>
<li>
<p><strong>列表初始化</strong></p>
<ul>
<li>
<p>C++定义了<strong>初始化</strong>的<strong>好几种不同形式</strong>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> units_sold = &#123;<span class="number">0</span>&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="type">int</span> units_sold&#123;<span class="number">0</span>&#125;;    <span class="comment">// 列表初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>列表初始化</strong></p>
<blockquote>
<p>1、作为<strong>C++11 新标准</strong>的一部分，用<strong>花括号</strong>来<strong>初始化变量</strong>得到了全面应用。这种初始化形式被称为<strong>列表初始化</strong><br>
2、现在，无论是<strong>初始化对象</strong>还是某些时候<strong>为对象赋新值</strong>，都可以使用这样一组<strong>由花括号括起来的初始值</strong>了<br>
3、当用于<strong>内置类型</strong>变量时，这种初始化形式有一个<strong>重要特点</strong>：如果我们<strong>使用列表初始化</strong>且<strong>初始值存在丢失信息的风险</strong>，<strong>编译器将报错</strong>(如下例)<br>
4、这样的介绍看似无关紧要，因为我们不会故意<strong>用 long double 值初始化 int 变量</strong>，然而这种初始化<strong>可能在不经意间发生</strong>，因此这种赋值更加<strong>保守安全</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;, b = &#123;ld&#125;;    <span class="comment">// 报错：转换未执行，因为存在丢失信息的风险(丢失浮点精度)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>, d </span>= ld;      <span class="comment">// 正确：转换执行，且确实丢失了部分值(丢失了小数点后的浮点部分)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>C++关键字</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>关键字</th>
<th>关键字</th>
<th>关键字</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>alignas</td>
<td>continue</td>
<td>friend</td>
<td>register</td>
<td>true</td>
</tr>
<tr>
<td>alignof</td>
<td>decltype</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
</tr>
<tr>
<td>asm</td>
<td>default</td>
<td>if</td>
<td>return</td>
<td>typedef</td>
</tr>
<tr>
<td>auto</td>
<td>delete</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>do</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>double</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>dynamic_cast</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>else</td>
<td>namespace</td>
<td>static_assert</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>enum</td>
<td>new</td>
<td>static_cast</td>
<td>virtual</td>
</tr>
<tr>
<td>char16_t</td>
<td>explicit</td>
<td>noexcept</td>
<td>struct</td>
<td>void</td>
</tr>
<tr>
<td>char32_t</td>
<td>export</td>
<td>nullptr</td>
<td>switch</td>
<td>volatile</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>template</td>
<td>wchar_t</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>this</td>
<td>while</td>
</tr>
<tr>
<td>constexpr</td>
<td>float</td>
<td>protected</td>
<td>thread_local</td>
<td></td>
</tr>
<tr>
<td>const_cast</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="复合类型"><strong>复合类型</strong></h2>
<ul>
<li>
<p><strong>复合类型</strong>是指<strong>基于其他类型</strong>定义的类型。C++有几种复合类型，在此主要了解其中两种：<strong>引用</strong>和<strong>指针</strong></p>
</li>
<li>
<p><strong>引用</strong></p>
<ul>
<li>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;     <span class="comment">// 定义引用，refVal 指向 ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2;           <span class="comment">// 报错：引用必须被初始化</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*/</span></span><br><span class="line">refVal = <span class="number">2</span>;             <span class="comment">// 实际赋值给 refVal 指向的 ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal3 = refVal;  <span class="comment">// refVal3 指向 refVal 指向的 ival</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*/</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal4 = dval;    <span class="comment">// 报错：refVal4 为int类型，其指向对象必须为int类型</span></span><br><span class="line"><span class="type">int</span> &amp;refVal5 = <span class="number">10</span>;      <span class="comment">// 报错：引用只能绑定在对象上</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>引用介绍</strong></p>
<blockquote>
<p>1、<strong>引用</strong>为对象<strong>起了另外一个名字</strong>，通过将声明符写成<code>&amp;变量名</code>来<strong>定义引用类型</strong><br>
2、<strong>定义引用时</strong>，程序把<strong>引用</strong>和它的<strong>初始值</strong>绑定在一起。一旦初始化完成，<strong>引用</strong>将和它的<strong>初始值对象</strong>一直绑定在一起。因为<strong>无法</strong>令引用<strong>重新绑定另外一个对象</strong>，所以<strong>引用必须初始化</strong><br>
3、引用<strong>并非对象</strong>，它只是为一个<strong>已经存在的对象</strong>所起的<strong>另外一个名字</strong>。定义一个引用之后，<strong>对其进行的所有操作</strong>都是在<strong>与之绑定的对象</strong>上进行的<br>
4、所有<strong>引用的类型</strong>都要和<strong>与之绑定的对象</strong>严格匹配，且<strong>引用只能绑定在对象上</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>指针</strong></p>
<ul>
<li>
<p>C++的指针整体与 C 语言的指针相同，在此写出一些差异</p>
</li>
<li>
<p><strong>空指针</strong></p>
<blockquote>
<p>1、<strong>空指针</strong>不指向<strong>任何对象</strong>，下为三种<strong>生成空指针</strong>的方法<br>
2、第一种方法是使用<strong>字面值</strong><code>nullptr</code>来初始化指针。<code>nullptr</code>是一种<strong>特殊类型</strong>的字面值，它可以<strong>被转换成任意其他的指针类型</strong><br>
3、第二种方法是使用<strong>字面值 0</strong>来生成空指针(注意不是 int 值)<br>
4、第三种方法是使用<strong>NULL 预处理器变量</strong>，这个变量在头文件<code>cstdlib</code>中定义，<strong>预处理变量</strong>不属于<strong>命名空间</strong><code>std</code>。在新标准下，现在的 C++程序<strong>最好使用</strong><code>nullptr</code>，同时<strong>尽量避免使用</strong><code>NULL</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> *pt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 使用 NULL 需要调用 cstdlib 头文件</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>void* 指针</strong></p>
<blockquote>
<p>1、void* 是一种特殊的指针类型，可用于存放<strong>任意对象的地址</strong>。不同的是，我们对该地址<strong>指向对象的类型</strong>并不了解<br>
2、利用 void* 指针<strong>能做的事有限</strong>，<strong>不能直接操作</strong>其所指的对象，因为并<strong>不知道对象是什么类型</strong><br>
3、概括来说，以 void* 视角来看，<strong>内存空间</strong>也就仅仅是<strong>内存空间</strong>，<strong>没办法访问</strong>内存空间中的<strong>对象</strong></p>
</blockquote>
</li>
</ul>
<h2 id="const-限定符"><strong>const 限定符</strong></h2>
<ul>
<li>
<p><strong>简述</strong></p>
<blockquote>
<p>1、有时我们希望定义一种<strong>值不能被改变</strong>的<strong>变量</strong>(或直接称为<strong>常量</strong>)，可以用<code>const</code>关键字加以修饰<br>
2、因为<code>const</code>对象<strong>一旦创建</strong>，<strong>值就不能改变</strong>，所以<code>const</code>对象<strong>必须初始化</strong><br>
3、<code>const</code>的用法整体与 C 语言中类似</p>
</blockquote>
</li>
<li>
<p><code>const</code><strong>的引用</strong></p>
<blockquote>
<p>1、可以把<strong>引用</strong>绑定到<code>const</code><strong>对象</strong>上，我们称之为<strong>对常量的引用</strong>(或<strong>常量引用</strong>)<br>
2、<strong>常量引用</strong>仅对<strong>引用</strong>本身作出限定，对于<strong>引用的对象</strong>并未限定。如果对象本身<strong>不是常量</strong>，那么允许通过<strong>其他途径</strong>修改它的值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;      <span class="comment">// 正确：引用及其对应对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;                <span class="comment">// 错误：r1是对常量的引用</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i;            <span class="comment">// 错误：r2是对非常量的引用，不能指向常量对象</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">30</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = n;</span><br><span class="line">r1 = <span class="number">40</span>;                <span class="comment">// 错误：r1是对常量的引用</span></span><br><span class="line">n = <span class="number">40</span>;                 <span class="comment">// 正确：n本身不是常量</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>constexpr</code><strong>和常量表达式</strong></p>
<ul>
<li>
<p><strong>常量表达式</strong></p>
<blockquote>
<p>1、<strong>常量表达式</strong>指<strong>值不会改变</strong>且<strong>在编译过程中就能确定值</strong>的表达式<br>
2、一个对象是不是常量表达式，由它的<strong>数据类型</strong>和<strong>初始值</strong>共同决定</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_file = <span class="number">20</span>;          <span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = mix_file + <span class="number">1</span>;   <span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;              <span class="comment">// 不是常量表达式：数据类型只是普通 int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();        <span class="comment">// 不是常量表达式：不能在编译过程中确定值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>constexpr</code><strong>变量</strong></p>
<blockquote>
<p>1、在一个复杂系统中，很难(甚至几乎肯定不能)<strong>分辨一个初始值</strong>是不是<strong>常量表达式</strong><br>
2、<strong>C++11</strong>规定，允许将变量声明为<code>constexpr</code>类型，由<strong>编译器</strong>来验证<strong>变量的值</strong>是否为<strong>常量表达式</strong><br>
3、声明为<code>constexpr</code>的变量<strong>一定是一个常量</strong>，而且<strong>必须用常量表达式初始化</strong><br>
4、不能使用<strong>普通函数</strong>作为<code>constexpr</code><strong>初始值</strong>，允许定义一种特殊的<code>constexpr</code><strong>函数</strong>，后续介绍</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;            <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;     <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>();        <span class="comment">// 编译错误：除非 size() 是 constexpr 函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>字面值类型</strong></p>
<blockquote>
<p>1、<strong>常量表达式</strong>的值需要<strong>在编译时就得到计算</strong>，这些类型一般<strong>比较简单</strong>，值也显而易见，就把它们称为<strong>字面值类型</strong><br>
2、目前为止，<strong>算术类型</strong>、<strong>引用</strong>、<strong>指针</strong>都<strong>是</strong>字面值类型。<strong>自定义类</strong>、<strong>IO 库</strong>、<strong>string 类型</strong>都<strong>不是</strong>字面值类型，也就不能被定义为<code>constexpr</code><br>
3、尽管<strong>指针</strong>和<strong>引用</strong>都能被定义成<code>constexpr</code>，但它们的<strong>初始值受到严格限制</strong>。如<code>constexpr</code><strong>指针</strong>的初始值只能是<code>nullptr</code>或<strong>0</strong>，或存储于某个<strong>固定地址</strong>中的<strong>对象</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="处理类型"><strong>处理类型</strong></h2>
<ul>
<li>
<p><strong>类型别名</strong></p>
<blockquote>
<p>1、有两种方法可用于定义<strong>类型别名</strong>，第一种是使用<code>typedef</code><strong>关键字</strong>，与 C 语言用法相同<br>
2、新标准规定了一种新方法：使用<strong>别名声明</strong>。这种方法使用<code>using</code><strong>关键字</strong>作为<strong>别名声明</strong>的开始，其后紧跟别名和等号，作用是把<strong>等号左侧的名字</strong>规定成<strong>等号右侧的类型</strong>的别名</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;      <span class="comment">// wages 是 double 的别名</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;    <span class="comment">// base 是 wages(即double)的别名，p 是 double* 的别名</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item;     <span class="comment">// SI 是 Sales_item 的别名</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>auto</code><strong>类型说明符</strong></p>
<blockquote>
<p>1、编程时常常需要把<strong>表达式的值</strong>赋给变量，这就要求在<strong>声明变量时</strong>清楚地知道<strong>表达式的类型</strong>，然而做到这一点并不容易，甚至有时根本做不到<br>
2、<strong>C++11</strong>引入了<code>auto</code><strong>类型说明符</strong>，能让<strong>编译器</strong>替我们去<strong>分析表达式的类型</strong><br>
3、和原来<strong>只对应一种特定类型</strong>的说明符(如 double)不同，<code>auto</code>能让编译器<strong>通过初始值</strong>推算<strong>变量的类型</strong>。显然，<code>auto</code>定义的变量<strong>必须有初始值</strong><br>
4、使用<code>auto</code>也能在<strong>一条语句</strong>声明<strong>多个变量</strong>，但由于一条声明语句<strong>只能有一个基本数据类型</strong>，所以该语句中<strong>所有变量</strong>的<strong>初始基本数据类型</strong>必须<strong>都一样</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;    <span class="comment">// auto 自动判断表达式类型</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;        <span class="comment">// 正确：i 是整数，p 是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;     <span class="comment">// 错误：sz 和 pi 类型不一致</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>decltype</code><strong>类型指示符</strong></p>
<blockquote>
<p>1、有时我们希望从<strong>表达式的类型</strong>推断出要定义的<strong>变量的类型</strong>，但是不想用该表达式的值<strong>初始化变量</strong>。为此，<strong>C++11</strong>引入了<code>decltype</code><strong>说明符</strong><br>
2、<code>delctype</code>可以<strong>返回操作数的数据类型</strong>，在此过程中，<strong>编译器</strong>分析表达式并<strong>得到它的类型</strong>，但并<strong>不实际计算表达式的值</strong><br>
3、注意<code>delctype</code><strong>表达式的结果</strong>如果是<strong>加上括号的变量</strong>，则结果将是<strong>引用</strong>。即<code>decltype(())</code>(注意是双层括号)的<strong>结果永远是引用</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ci = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;         <span class="comment">// x 的类型就是 ci 的类型，即 int，值为 0</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">def</span>()) sum = x;    <span class="comment">// sum的类型就是函数 def() 的返回类型，值为 x 的值</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------*/</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) d;            <span class="comment">// 错误：d 是 int&amp; 引用类型，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;              <span class="comment">// 正确：e 是一个未初始化的 int 类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="自定义数据结构"><strong>自定义数据结构</strong></h2>
<ul>
<li>
<p><strong>什么是数据结构</strong></p>
<blockquote>
<p>1、从最基本的层面理解，<strong>数据结构</strong>是把一组<strong>相关的数据元素</strong>组织起来然后使用它们的<strong>策略和方法</strong><br>
2、举一个例子，我们想要创建一个<code>Sales_items</code><strong>类</strong>把书本的<strong>ISBN 编号</strong>、<strong>售出量</strong>、<strong>销售收入</strong>等数据组织在一起，并提供诸如<code>isbn()</code><strong>等函数</strong>，<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>+</code>、<code>+=</code><strong>等运算</strong>在内的<strong>一系列操作</strong>，<code>Sales_item</code><strong>类</strong>就是一个<strong>数据结构</strong><br>
3、C++允许用户以<strong>类的形式</strong>自定义<strong>数据类型</strong>，而<strong>库类型</strong><code>string</code>、<code>istream</code>、<code>ostream</code>等也是<strong>以类的形式定义的</strong></p>
</blockquote>
</li>
<li>
<p><strong>定义类</strong></p>
<ul>
<li><strong>简单的不含运算功能的类</strong>的定义实际就是<strong>C 的结构体</strong>定义，使用<code>struct</code>定义</li>
<li>此外，C++提供<strong>另外一个关键字</strong><code>class</code>定义自己的<strong>数据结构</strong>，后续介绍</li>
</ul>
</li>
<li>
<p><strong>使用类</strong>：简单的<strong>类</strong>的使用与<strong>C 的结构体</strong>使用规则相似，但定义<strong>类对象</strong>(结构变量)时不需要再使用<code>struct</code>再次声明</p>
</li>
</ul>
<hr>
<h1><strong>字符串、向量和数组</strong></h1>
<hr>
<blockquote>
<p><strong>章节概要</strong>：命名空间的<code>using</code>声明；标准库类型<code>string</code>；定义和初始化<code>string</code>对象；<code>string</code>对象的操作；处理<code>string</code>对象中的字符；范围 for 语句；标准库类型<code>vector</code>；模板；定义和初始化<code>vector</code>对象；向<code>vector</code>对象添加元素；其他<code>vector</code>操作；<code>vector</code>的索引；迭代器介绍；使用迭代器；泛型编程；迭代器运算；数组；<code>auto</code>与数组；指针也是迭代器；与旧代码的接口</p>
</blockquote>
<h2 id="命名空间的-using-声明"><strong>命名空间的 using 声明</strong></h2>
<ul>
<li>
<p><strong>引入</strong></p>
<blockquote>
<p>1、目前为止，我们用到的<strong>库函数</strong>基本上都属于<strong>命名空间</strong><code>std</code>，而程序也显式地将这一点标示了出来，如<code>std::cin</code><br>
2、用这种方法显得<strong>比较繁琐</strong>，然而幸运的是，通过更简单的途径也能使用到<strong>命名空间的成员</strong><br>
3、本节将介绍其中一种<strong>最安全的方法</strong>，也就是<strong>使用</strong><code>using</code><strong>声明</strong>，后续会介绍另一种方法</p>
</blockquote>
</li>
<li>
<p><code>using</code><strong>声明</strong></p>
<blockquote>
<p>1、有了<code>using</code>声明就<strong>无须专门的前缀</strong>，也能使用所需的名字了<br>
2、<code>using</code>声明具有<strong>如下形式</strong><code>using 命名空间名::名字</code>，如后示例<br>
3、按照规定，每个<code>using</code>声明只能引入<strong>命名空间</strong>中的<strong>一个成员</strong>，因此每个名字都需要<strong>独立声明</strong><br>
4、位于<strong>头文件</strong>的代码<strong>不应该使用</strong><code>using</code><strong>声明</strong>，因为引用该头文件的源代码也会<strong>引入这个声明</strong>，对于某些程序，可能会<strong>产生名字冲突</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    cin &gt;&gt; i;</span><br><span class="line">    std::cout &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="标准库类型-string"><strong>标准库类型 string</strong></h2>
<ul>
<li>
<p><strong>介绍</strong></p>
<blockquote>
<p>1、<strong>标准库类型</strong><code>string</code>表示<strong>可变长的字符序列</strong>(字符串)，使用<code>string</code>类型必须先包含<code>string</code><strong>头文件</strong><br>
2、作为<strong>标准库的一部分</strong>，<code>string</code>定义在<strong>命名空间</strong><code>std</code>中<br>
3、接下来的示例都假定已包含了下述代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>定义和初始化 string 对象</strong></p>
<blockquote>
<p>1、如何<strong>初始化类的对象</strong>是由<strong>类本身</strong>决定的，一个类可以定义<strong>很多种</strong>初始化对象的方式，但这些方式之间<strong>必须有所区别</strong>：或者是<strong>初始值数量不同</strong>，或者是<strong>初始值类型不同</strong><br>
2、下为<strong>初始化</strong><code>string</code><strong>对象</strong>的<strong>方式和示例</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s1</td>
<td>默认初始化，s1 是一个空串</td>
</tr>
<tr>
<td>string s2(s1)</td>
<td>直接初始化，s2 是 s1 的副本</td>
</tr>
<tr>
<td>string s2 = s1</td>
<td>拷贝初始化，s2 是 s1 的副本</td>
</tr>
<tr>
<td>string s3(“value”)</td>
<td>直接初始化，s3 是字符串字面值”value”的副本，空字符除外</td>
</tr>
<tr>
<td>string s3 = “value”</td>
<td>拷贝初始化，s3 是字符串字面值”value”的副本，空字符除外</td>
</tr>
<tr>
<td>string s4(n, ‘c’)</td>
<td>直接初始化，把 s4 初始化为连续 n 个字符 c 组成的字符串</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1;                    <span class="comment">// 默认初始化，s1是空字符串</span></span><br><span class="line">string s2 = s1;               <span class="comment">// s2是s1的副本</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;           <span class="comment">// s3是字面值&quot;value&quot;的副本</span></span><br><span class="line">string s3 = <span class="string">&quot;value&quot;</span>;          <span class="comment">// s3是字面值&quot;value&quot;的副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>;           <span class="comment">// 直接初始化，s4内容是 cccccccccc</span></span><br><span class="line">string s4 = <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);  <span class="comment">// 拷贝初始化，s4内容是 cccccccccc</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>string 对象的操作</strong></p>
<ul>
<li>
<p><strong>总览</strong></p>
<blockquote>
<p>1、一个<strong>类</strong>除了要规定<strong>初始化其对象的方式</strong>外，还要定义对象上<strong>能执行的操作</strong>。其中，类既能定义<strong>通过函数名调用的操作</strong>，也能定义<strong>各种运算符</strong>在<strong>该类对象</strong>上的<strong>新含义</strong><br>
2、下表列举了<strong>大部分</strong><code>string</code><strong>类的操作</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>os&lt;&lt;s</td>
<td>将 s 写入到输出流 os 中，返回 os</td>
</tr>
<tr>
<td>is&gt;&gt;s</td>
<td>从 is 中读取字符串赋给 s，字符串以空格分隔，返回 is</td>
</tr>
<tr>
<td>getline(is, s)</td>
<td>从 is 中读取一行赋给 s，返回 is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s 为空返回 true，否则返回 false</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回 s 中字符个数</td>
</tr>
<tr>
<td>s[n]</td>
<td>返回 s 中第 n 个字符的引用，位置 n 从 0 计起</td>
</tr>
<tr>
<td>s1+s2</td>
<td>返回 s1 和 s2 连接后的结果</td>
</tr>
<tr>
<td>s1=s2</td>
<td>用 s2 的副本代替 s1 中原来的字符</td>
</tr>
<tr>
<td>s1==s2</td>
<td>如果 s1 和 s2 中的字符完全一样，则它们相等，对字母的判断依据是 ASCII 码</td>
</tr>
<tr>
<td>s1!=s2</td>
<td>如果 s1 和 s2 中有一个字符不一样，则它们不相等，对字母的判断依据是 ASCII 码</td>
</tr>
<tr>
<td>&lt;,&lt;=,&gt;,&gt;=</td>
<td>对字符串从前向后依次比较字符的 ASCII 码，成立与否的依据是首个不相等字符的 ASCII 大小关系</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>读写操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本读写</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;   <span class="comment">// 遇到空格停止</span></span><br><span class="line">    cout &lt;&lt; s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getline整行读取</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);   <span class="comment">// 遇到换行符停止</span></span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C语言风格EOF读写</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="comment">// while(getline(cin, line))</span></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; word)</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>empty</code><strong>和</strong><code>size</code><strong>操作</strong></p>
<blockquote>
<p>1、<code>empty</code><strong>函数</strong>根据<code>string</code><strong>对象是否为空</strong>返回一个<strong>布尔值</strong>，<code>size</code><strong>函数</strong>返回<code>string</code><strong>对象的长度</strong><br>
2、这两个函数都是<code>string</code>的<strong>成员函数</strong>。<strong>调用该类函数</strong>的方法是，使用<strong>点操作符</strong>指明是<strong>哪个对象</strong>执行成员函数即可(<code>对象.成员函数()</code>)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))</span><br><span class="line">        <span class="comment">// 如果字符串不为空 且 字符串长度大于10</span></span><br><span class="line">        <span class="keyword">if</span>(!line.<span class="built_in">empty</span>() &amp;&amp; line.<span class="built_in">size</span>() &gt; <span class="number">10</span>)</span><br><span class="line">            cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>string::size_type</code><strong>类型</strong></p>
<blockquote>
<p>1、实际上，<code>size</code><strong>函数的返回值</strong>是一个<code>string::size_type</code><strong>类型的值</strong><br>
2、尽管我们不太清楚<code>string::size_type</code>类型的<strong>具体细节</strong>，但有一点是肯定的，它是一个<strong>无符号类型值</strong>，且<strong>足够存放任何</strong><code>string</code><strong>对象的大小</strong><br>
3、所有<strong>用于存放</strong><code>string</code><strong>类</strong>的<code>size</code><strong>函数返回值</strong>的<strong>变量</strong>，都应该是<strong>该类型</strong>(<code>auto len = line.size();</code>中<code>line</code>的类型也<strong>自动设为该类型</strong>)<br>
4、由于<strong>该类型</strong>是<strong>无符号整型</strong>，因此切记，如果在表达式中<strong>混用</strong>了<strong>无符号数和有符号数</strong>会产生意想不到的错误。如<strong>变量 n</strong>是一个<strong>具有负值的 int</strong>，则表达式<code>s.size() &lt; n</code>几乎肯定是<strong>true</strong>，因为<strong>负值 n</strong>会<strong>自动转换</strong>成一个<strong>较大的无符号值</strong></p>
</blockquote>
</li>
<li>
<p><strong>字面值和</strong><code>string</code><strong>对象相加</strong></p>
<blockquote>
<p>1、即使一种类型<strong>并非所需</strong>，我们也可以使用它，不过前提是<strong>这种类型能自动转换成所需类型</strong><br>
2、因为<strong>标准库</strong>允许把<strong>字符字面值</strong>和<strong>字符串字面值</strong>转换成<code>string</code><strong>对象</strong>，所以在<strong>需要</strong><code>string</code><strong>对象的地方</strong>就可以用<strong>这两种字面值</strong>代替<br>
3、注意：当把<code>string</code><strong>对象</strong>和<strong>这两种字面值</strong>混在一条语句中使用时，必须确保<strong>每个加法运算符</strong>的两侧的<strong>运算对象至少有一个</strong>是<code>string</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&quot;,&quot;</span> + s2 + <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">/*------------------------------*/</span></span><br><span class="line"><span class="comment">// 注意按顺序结合后结果的类型</span></span><br><span class="line">string s4 = s1 + <span class="string">&quot;,&quot;</span>;               <span class="comment">// 正确</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;,&quot;</span>;          <span class="comment">// 错误</span></span><br><span class="line">string s6 = s1 + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;world&quot;</span>;     <span class="comment">// 正确</span></span><br><span class="line">string s7 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;,&quot;</span> + s2;     <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>处理 string 对象中的字符</strong></p>
<ul>
<li>
<p><strong>引入</strong></p>
<blockquote>
<p>1、我们经常需要<strong>单独处理</strong><code>string</code><strong>对象</strong>中的<strong>字符</strong>，这类处理的关键问题是<strong>如何获取字符本身</strong>，另一个关键问题是要知道<strong>能改变某个字符的特性</strong><br>
2、对于后者，我们可以使用<strong>C 语言继承而来</strong>的<code>cctype</code>(即<code>ctype.h</code>)，对于后者，我们可以通过<strong>范围 for 语句</strong>实现</p>
</blockquote>
</li>
<li>
<p><strong>范围 for 语句</strong></p>
<blockquote>
<p>1、如果想对<code>string</code><strong>对象</strong>中的<strong>每个字符</strong>做点什么，目前最好的操作是使用<strong>C++11 标准</strong>提供的<strong>范围 for 语句</strong>(语法形式如后附)<br>
2、其中<strong>变量</strong>将被用于<strong>访问序列中的基础元素</strong>。每次<strong>迭代</strong>，<strong>变量</strong>都会被<strong>初始化</strong>为<strong>对象序列</strong>的<strong>下一个元素值</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (变量 : 对象序列)</span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>示例：统计标点数并输出标点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::getline;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))</span><br><span class="line">        &#123;</span><br><span class="line">            ct++;</span><br><span class="line">            cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;ct: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用范围 for 改变字符</strong></p>
<blockquote>
<p>1、如果想要<strong>改变</strong><code>string</code><strong>对象</strong>中<strong>字符的值</strong>，只需要把<strong>循环变量</strong>定义成<strong>引用</strong>类型即可<br>
2、记住，所谓<strong>引用</strong>只是<strong>给定对象的一个别名</strong>，因此当<strong>引用</strong>作为<strong>循环控制变量</strong>时，这个变量实际<strong>被依次绑定到</strong>序列的<strong>每个元素</strong>上<br>
3、下示例将<strong>整个字符串</strong>中的<strong>小写字母</strong>转换成<strong>大写字母</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::getline;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="built_in">toupper</span>(c);</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>只处理一部分字符</strong></p>
<blockquote>
<p>1、如果只想处理<strong>一部分</strong>字符，那么<strong>范围 for 语句</strong>则<strong>不能很好的胜任</strong>了。通常访问<code>string</code><strong>对象</strong>中的<strong>单个字符</strong>有两种方式：一种是使用<strong>下标</strong>，另一种是使用<strong>迭代器</strong>(后续介绍)<br>
2、<code>string</code><strong>对象</strong>的下标使用与<strong>C 语言字符数组</strong>规则类似，使用<strong>for 循环遍历处理</strong>。对象的下标必须<strong>大于等于 0</strong>且<strong>小于</strong><code>s.size()</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="标准库类型-vector"><strong>标准库类型 vector</strong></h2>
<ul>
<li>
<p><strong>介绍</strong></p>
<blockquote>
<p>1、标准库类型<code>vector</code>表示<strong>对象的集合</strong>，其中<strong>所有对象的类型都相同</strong><br>
2、集合中的<strong>每个对象</strong>都有一个<strong>与之对应的索引</strong>，索引用于<strong>访问对象</strong><br>
3、因为<code>vector</code><strong>容纳着</strong>其他对象，所以它也常常被称作<strong>容器</strong><br>
4、要想使用<code>vector</code>，必须包含<strong>适当的头文件</strong>。后续的例子中，都假设包含以下声明</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>模板</strong></p>
<ul>
<li>
<p><strong>模板简介</strong></p>
<blockquote>
<p>1、C++既有<strong>类模板</strong>，也有<strong>函数模板</strong>，其中<code>vector</code>是一个<strong>类模板</strong>。只要对 C++有深入了解后才能<strong>写出模板</strong>，我们将在 16 章介绍。但即使不会创建模板，我们也可以试着使用模板<br>
2、<strong>模板</strong>本身不是<strong>类或函数</strong>，相反可以将<strong>模板</strong>看做<strong>编译器生成类或函数编写</strong>的一份<strong>说明</strong>。编译器<strong>根据模板创建类或函数</strong>的过程称为<strong>实例化</strong>，当使用模板时，需要指出编译器应把类或函数<strong>实例化成何种类型</strong><br>
3、对于<strong>类模板</strong>来说，我们通过提供一些<strong>额外信息</strong>来指定模板应<strong>实例化成什么样的类</strong>，需要<strong>提供哪些信息</strong>由模板决定。<strong>提供信息的方式</strong>总是这样：在<strong>模板名字</strong>后面跟<strong>一对尖括号</strong>，在<strong>括号内</strong>放上信息，<code>模板名&lt;信息&gt;;</code></p>
</blockquote>
</li>
<li>
<p><strong>vector 模板</strong></p>
<blockquote>
<p>1、例如<code>vector</code>模板，<strong>需要提供的信息</strong>是<code>vector</code>内存放的<strong>对象类型</strong>(示例如后附代码)<br>
2、<code>vector</code>是<strong>模板</strong>而非<strong>类型</strong>，由<code>vector</code><strong>生成的类型</strong>必须包含<code>vector</code>中<strong>所存放元素的类型</strong>，例如<code>vector&lt;int&gt;</code><br>
3、<code>vector</code>能容纳<strong>绝大多数类型</strong>的<strong>对象</strong>作为其<strong>元素</strong>，但是由于<strong>引用不是对象</strong>，所以<strong>不存在包含引用的</strong><code>vector</code><br>
4、早期版本 C++中，如果<code>vector</code><strong>的元素</strong>还是<code>vector</code>，必须在<strong>外层</strong>的<strong>右尖括号</strong>和<strong>其元素类型</strong>之间添加一个<strong>空格</strong>。比如应该写成<code>vector&lt;vector&lt;int&gt; &gt;</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;               <span class="comment">// ivec保存int类型的对象</span></span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;   <span class="comment">// 保存Sales_item类型的对象</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; file;    <span class="comment">// 该向量的元素是vector对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>定义和初始化 vector 对象</strong></p>
<ul>
<li>
<p>下表列出了<strong>初始化</strong><code>vector</code><strong>对象</strong>的<strong>方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector<T> v1</td>
<td>v1 是一个空 vector，潜在元素为 T 类型，执行默认初始化</td>
</tr>
<tr>
<td>vector<T> v2(v1)</td>
<td>v2 中包含有 v1 所有元素的副本</td>
</tr>
<tr>
<td>vector<T> v2 = v1</td>
<td>同上等价</td>
</tr>
<tr>
<td>vector<T> v3(n,val)</td>
<td>v3 包含 n 个重复的元素，每个元素值都是 val</td>
</tr>
<tr>
<td>vector<T> v4(n)</td>
<td>v4 包含 n 个重复执行了值初始化的对象</td>
</tr>
<tr>
<td>vector<T> v5{a,b,c,…}</td>
<td>v5 包含了初始值个数的元素，每个元素被赋予了相应的初始值</td>
</tr>
<tr>
<td>vector<T> v5 = {a,b,c,…}</td>
<td>同上等价</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>区分<code>()</code><strong>值初始化</strong>和<code>&#123;&#125;</code><strong>列表初始化</strong>的含义</p>
<blockquote>
<p>1、<code>vector&lt;int&gt; ivec(3,-1)</code>含义是<strong>ivec</strong>存放了<strong>3 个值为 -1 的元素</strong>；而<code>vector&lt;int&gt; ivec&#123;3,-1&#125;</code>含义是<strong>ivec</strong>存放了<strong>两个元素</strong>，<strong>值</strong>分别为<strong>3 和 -1</strong><br>
2、<code>vector&lt;int&gt; ivec(10)</code>是指<strong>ivec</strong>创建了<strong>10 个执行了值初始化的元素</strong>(如 int 类型会被初始化为 0)<br>
3、简单地说，想要<strong>初始化多个相同值</strong>就使用<code>()</code><strong>值初始化</strong>，想要<strong>初始化多个不同值</strong>就使用<code>&#123;&#125;</code><strong>列表初始化</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>向 vector 对象添加元素</strong></p>
<blockquote>
<p>1、经常我们会遇到，创建一个<code>vector</code>时并<strong>不清楚</strong>实际所需<strong>元素个数</strong>，元素的<strong>值</strong>也<strong>无法确定</strong>；还有些时候元素初值已知，但这些值<strong>总量较大</strong>且<strong>各不相同</strong><br>
2、例如我们需要<code>vector</code><strong>对象</strong>存储 1-100 的数字，对此更好的办法是先创建一个<strong>空</strong><code>vector</code>，然后在<strong>运行时</strong>利用<code>vector</code>的<strong>成员函数</strong><code>push_back</code>来<strong>添加数据</strong><br>
3、<code>push_back</code>负责把<strong>一个值</strong>当成<code>vector</code><strong>对象</strong>的<strong>尾元素</strong>，添加到<strong>对象的尾端</strong>，示例如下<br>
4、注意：如果循环体内部含有<strong>向</strong><code>vector</code><strong>添加元素</strong>的语句，则不能使用<strong>范围 for 语句</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>其他 vector 操作</strong></p>
<ul>
<li>
<p><code>vector</code>提供了一些<strong>其他操作</strong>，下表列出其中比较重要的一些</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.empty()</td>
<td>如果 v 不含有任何元素，返回 true，否则返回 false</td>
</tr>
<tr>
<td>v.size()</td>
<td>返回 v 中元素的个数，返回值类型是 <code>vector\&lt;T&gt;::size_type</code> 类型</td>
</tr>
<tr>
<td>v.push_back(t)</td>
<td>将值为 t 的元素添加到 v 的尾端</td>
</tr>
<tr>
<td>v[n]</td>
<td>返回 v 中第 n 个位置上元素的引用</td>
</tr>
<tr>
<td>v1 = v2</td>
<td>用 v2 中的元素拷贝替换 v1 中的元素</td>
</tr>
<tr>
<td>v1 = {a,b,c,…}</td>
<td>用列表中的元素拷贝替换 v1 中的元素</td>
</tr>
<tr>
<td>==,!=,&lt;,&lt;=,&gt;,&gt;=</td>
<td>与 string 相同，比较字典序</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p><strong>vector 的索引</strong></p>
<blockquote>
<p>1、和<code>string</code>类似，如果需要<strong>逐个访问全部</strong><code>vector</code><strong>元素</strong>，也可以使用<strong>范围 for 语句</strong>+<strong>引用</strong><br>
2、对于需要<strong>非顺序访问</strong>，可以使用<strong>下标</strong>访问，<strong>下标</strong>同样<strong>从 0 开始计算</strong><br>
3、注意：只能对<strong>确知已存在的元素</strong>使用<strong>下标操作</strong>，因此<strong>不能使用下标添加元素</strong>，添加元素只能使用<code>push.back</code></p>
</blockquote>
</li>
</ul>
<h2 id="迭代器介绍"><strong>迭代器介绍</strong></h2>
<ul>
<li>
<p><strong>介绍</strong></p>
<blockquote>
<p>1、我们已经知道可以使用<strong>下标</strong>访问<code>string</code><strong>对象的字符</strong>和<code>vector</code><strong>对象的元素</strong>，还有另一种<strong>更通用的机制</strong>也能实现，就是<strong>迭代器</strong><br>
2、除了<code>vector</code>外，<strong>标准库</strong>还定义了<strong>其他几种容器</strong>。<strong>所有标准库容器</strong>都能使用<strong>迭代器</strong>，但只有<strong>少数几种</strong>才同时支持<strong>下标操作</strong><br>
3、类似于<strong>指针类型</strong>，迭代器也提供对<strong>对象</strong>的<strong>间接访问</strong>，同时迭代器也有<strong>有效</strong>和<strong>无效</strong>之分。<strong>有效</strong>的迭代器<strong>指向某个元素</strong>或指向<strong>容器尾元素的下一位置</strong>，其余都属于<strong>无效</strong>迭代器</p>
</blockquote>
</li>
<li>
<p><strong>使用迭代器</strong></p>
<ul>
<li>
<p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>和指针不同</strong>的是，<strong>获取迭代器</strong>不是使用<strong>取地址符</strong>，<strong>有迭代器的类型</strong>同时拥有<strong>返回迭代器的成员</strong><br>
2、比如<strong>这些类型</strong>都拥有名为<strong>begin</strong>和<strong>end</strong>的<strong>成员</strong>，其中<strong>begin 成员</strong>负责返回<strong>指向第一个元素的迭代器</strong>，<strong>end 成员</strong>负责返回<strong>指向容器尾元素下一位置的迭代器</strong><br>
3、<strong>end 成员</strong>返回的<strong>迭代器</strong>常被称作<strong>尾后迭代器</strong>，或简称为<strong>尾迭代器</strong>。这样的迭代器没什么实际含义，只是个<strong>标记</strong>而已，表示我们已经处理完了容器中所有元素。特殊情况下，如果<strong>容器为空</strong>，则<strong>begin</strong>和<strong>end</strong>返回的是<strong>同一个迭代器</strong><br>
4、一般来说，我们不清楚(也不需要在意)<strong>迭代器的准确类型</strong>是什么，通常使用<code>auto</code><strong>关键字</strong>定义变量来<strong>自动确定类型</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 表示 v 的第一个元素，e 表示 v 尾元素的下一位置</span></span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>迭代器运算符</strong></p>
<blockquote>
<p>1、下表列举了部分<strong>迭代器支持的运算</strong><br>
2、和指针类似，也能通过<strong>解引用迭代器</strong>来获取它<strong>所指示的元素</strong>，执行解引用的迭代器<strong>必须合法</strong>并<strong>确实指示着某个元素</strong><br>
3、举个例子，使用<strong>迭代器</strong>访问<code>string</code><strong>对象</strong>，将字符串的<strong>首字母大写</strong>(如下例)</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>返回迭代器 iter 所指元素的引用</td>
</tr>
<tr>
<td>iter-&gt;mem</td>
<td>解引用 iter 并获取该元素的名为 mem 的成员，等价于<code>(*iter).mem</code></td>
</tr>
<tr>
<td>++iter 或 iter++</td>
<td>令 iter 指示容器中的下一个元素</td>
</tr>
<tr>
<td>–iter 或 iter–</td>
<td>令 iter 指示容器中的上一个元素</td>
</tr>
<tr>
<td>iter1 == iter2</td>
<td>判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等</td>
</tr>
<tr>
<td>iter1 != iter2</td>
<td>判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some thing&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">begin</span>() != s.<span class="built_in">end</span>())   <span class="comment">// 确保 s 为非空字符串</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();    <span class="comment">// it 表示 s 的第一个字符</span></span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);     <span class="comment">// 改为大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>将迭代器移动到另外一个元素</strong></p>
<blockquote>
<p>1、<strong>迭代器</strong>使用<strong>递增运算符</strong><code>++</code>来移动到<strong>下一个元素</strong>，使用<strong>递减运算符</strong><code>--</code>来移动到<strong>上一个元素</strong><br>
2、因为<strong>end 返回的迭代器</strong>并不实际指示<strong>某个元素</strong>，所以<strong>不能</strong>对其进行<strong>递增</strong>或<strong>解引用</strong><br>
3、下例为使用<strong>迭代器</strong>依次访问<code>string</code><strong>对象</strong>的<strong>字符</strong>，将<strong>整个字符串的字母大写</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>迭代器类型</strong></p>
<blockquote>
<p>1、就像<strong>不知道</strong><code>string</code>和<code>vector</code>的<code>size_type</code><strong>成员</strong>到底是<strong>什么类型</strong>一样，一般来说我们也<strong>不知道</strong>(也无需知道)<strong>迭代器的精确类型</strong><br>
2、实际上，那些<strong>拥有迭代器</strong>的<strong>标准库类型</strong>使用<code>iterator</code>和<code>const_iterator</code>来表示<strong>迭代器的类型</strong>，其中<code>const_iterator</code>和<strong>常量指针</strong>差不多</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1;          <span class="comment">// it1 能读写 vector&lt;int&gt; 的元素</span></span><br><span class="line">string::iterator it2;               <span class="comment">// it2 能读写 string 对象中的字符</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;    <span class="comment">// it3 只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4;         <span class="comment">// it4 只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>cbegin</code><strong>和</strong><code>cend</code><strong>函数</strong></p>
<blockquote>
<p>1、<code>begin</code>和<code>end</code>返回的<strong>具体类型</strong>由<strong>对象是否是常量</strong>决定。如果对象<strong>是常量</strong>则返回<code>const_iterator</code>，如果<strong>不是常量</strong>在返回<code>iterator</code><br>
2、有时候这种<strong>默认的行为</strong>并非我们所要，如果对象<strong>只需读无须写</strong>最好使用<strong>常量类型</strong><br>
3、为了便于我们得到<code>const_iterator</code><strong>类型的返回值</strong>，C++11 引入了两个<strong>新函数</strong>：<code>cbegin</code>和<code>cend</code>，其返回值一定是<code>const_iterator</code>类型</p>
</blockquote>
</li>
<li>
<p><strong>组合解引用和成员访问操作</strong></p>
<blockquote>
<p>1、<strong>解引用迭代器</strong>可获得迭代器<strong>所指的对象</strong>，如果该<strong>对象的类型</strong>恰好是<strong>类</strong>，就有可能希望进一步<strong>访问它的成员</strong><br>
2、例如，对于一个由字符串组成的<code>vector</code><strong>对象</strong>，要想检查其<strong>元素是否为空</strong>，令<strong>it</strong>是该<code>vector</code>的<strong>迭代器</strong>，只要检查<strong>it 所指字符串是否为空</strong>即可：<code>(*it).empty()</code>(注意前面的括号不可省略，因为关系到运算符优先级问题)<br>
3、为了简化上述表达式，C++定义了<strong>箭头运算符</strong><code>-&gt;</code>。箭头运算符把<strong>解引用</strong>和<strong>成员访问</strong>两个操作<strong>结合在一起</strong>，也就是说，<code>it-&gt;mem</code>等效于<code>(*it).mem</code></p>
</blockquote>
</li>
<li>
<p><strong>某些对</strong><code>vector</code><strong>对象的操作会使迭代器失效</strong></p>
<blockquote>
<p>1、虽然<code>vector</code>对象可以<strong>动态地增长</strong>，但是也会有一些<strong>副作用</strong><br>
2、已知的一个限制是不能在<strong>范围 for 语句</strong>内向<code>vector</code><strong>添加元素</strong>。另外一个限制是任何一种<strong>可能改变</strong><code>vector</code><strong>对象容量</strong>的操作，比如<code>push_back</code>，都会使其<strong>迭代器失效</strong>(后续解释)<br>
3、谨记，但凡是使用了<strong>迭代器</strong>的<strong>循环体</strong>，<strong>都不要</strong>向迭代器所属容器<strong>添加元素</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>泛型编程</strong></p>
<blockquote>
<p>1、原来使用 C 或 Java 的程序员转而使用 C++ 后，会对<strong>for 循环</strong>中<strong>大量使用</strong><code>!=</code>而不是<code>&lt;</code>进行判断感到奇怪<br>
2、C++程序员<strong>习惯性使用</strong><code>!=</code>，其原因和他们<strong>更愿意用迭代器而非下标</strong>的原因一样：这种编程风格在<strong>标准库提供的所有容器</strong>上都有效<br>
3、与之类似，<strong>所有标准库容器的迭代器</strong>都定义了<code>!=</code>和<code>==</code>，但它们中的<strong>大多数没有定义</strong><code>&lt;</code><strong>运算符</strong><br>
4、因此，只要我们养成使用<strong>迭代器</strong>和<code>!=</code>的习惯，就<strong>不用太在意</strong>用的到底是<strong>哪种类型</strong></p>
</blockquote>
</li>
<li>
<p><strong>迭代器运算</strong></p>
<blockquote>
<p>1、<code>string</code>和<code>vector</code>的<strong>迭代器</strong>提供了更多额外的<strong>运算符</strong>，一方面可使得迭代器<strong>每次移动过多个元素</strong>，另外也支持迭代器进行<strong>关系运算</strong>。<br>
2、所有这些运算都被称为<strong>迭代器运算</strong>，如下表</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n</td>
<td>迭代器加上一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置</td>
</tr>
<tr>
<td>iter - n</td>
<td>迭代器减去一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置</td>
</tr>
<tr>
<td>iter += n</td>
<td>迭代器加法的复合赋值语句，将 iter 加 n 的结果赋给 iter</td>
</tr>
<tr>
<td>iter -= n</td>
<td>迭代器减法的复合赋值语句，将 iter 减 n 的结果赋给 iter</td>
</tr>
<tr>
<td>iter1 - iter2</td>
<td>两个迭代器相减的结果是它们之间的距离，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置</td>
</tr>
<tr>
<td>&gt;,&gt;=,&lt;,&lt;=</td>
<td>迭代器关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则前者小于后者，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置，类型是<code>difference_type</code>的带符号整型</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>使用迭代器运算</strong></p>
<ul>
<li>
<p>使用迭代器运算的一个<strong>经典算法</strong>是<strong>二分搜索</strong>，其从<strong>有序序列</strong>中寻找某个<strong>给定值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// text 必须是有序的，sought 是要搜索的给定值</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>(), end = text.<span class="built_in">end</span>();    <span class="comment">// beg 和 end 表示搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> mid = text.<span class="built_in">begin</span>() + (end - bag) / <span class="number">2</span>;    <span class="comment">// 初始中间点</span></span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid)                        <span class="comment">// 如果在前半部分</span></span><br><span class="line">        end = mid;                            <span class="comment">// 忽略后半部分</span></span><br><span class="line">    <span class="keyword">else</span>                                      <span class="comment">// 如果在后半部分</span></span><br><span class="line">        beg = mid + <span class="number">1</span>;                        <span class="comment">// 在mid之后寻找</span></span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>;              <span class="comment">// 新的中间点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="数组"><strong>数组</strong></h2>
<ul>
<li>
<p><strong>数组</strong>的大部分使用规则<strong>与 C 语言相同</strong></p>
</li>
<li>
<p><strong>auto 与数组</strong></p>
<blockquote>
<p>1、由于<strong>数组名</strong>是数组的<strong>首元素地址</strong>，所以使用<code>auto</code><strong>关键字</strong>时，<code>auto ia2(ia)</code>等同于<code>auto ia2(&amp;ia[0])</code><br>
2、但如果使用<code>decltype</code><strong>关键字</strong>，上述转换<strong>不会发生</strong>，<code>decltype(ia)</code><strong>返回类型</strong>是由<strong>10 个整数</strong>构成的<strong>数组</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// ia2是一个整型指针，指向ia的首元素</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;</span><br><span class="line"><span class="comment">// ia3是一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>指针也是迭代器</strong></p>
<blockquote>
<p>1、就像使用<strong>迭代器</strong>遍历<code>vector</code><strong>对象</strong>那样，使用<strong>指针</strong>也能<strong>遍历数组中的元素</strong>。不过前提是先获取到<strong>指向数组首元素的指针</strong>和<strong>指向数组尾元素下一位的指针</strong><br>
2、获取<strong>首元素地址</strong>可以使用<strong>数组名</strong>，而<strong>尾后指针</strong>可以获取<strong>尾元素后</strong>那个<strong>并不存在的元素的地址</strong>。如假设定义<code>int arr[10];</code>，则可以<code>int *end = &amp;arr[10]</code><br>
3、尽管<strong>通过计算</strong>可以得到<strong>尾后指针</strong>，但这种方法<strong>极易出错</strong>。为了让指针的使用更简单，C++11 新增了<strong>两个函数</strong>：<code>begin</code><strong>函数</strong>和<code>end</code><strong>函数</strong><br>
4、这<strong>两个函数</strong>与<strong>容器中</strong>的<strong>两个同名成员</strong>功能类似，不过<strong>数组不是类类型</strong>，所以这两个函数<strong>不是成员函数</strong>。正确使用的方法是将<strong>数组</strong>作为它们的<strong>参数</strong>，如下</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *begin = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="type">int</span> *end = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>与旧代码的接口</strong></p>
<ul>
<li>
<p><strong>引入</strong></p>
<blockquote>
<p>1、很多 C++程序在<strong>标准库出现之前</strong>就已经写成了，它们肯定没用到<code>string</code>和<code>vector</code>类型；而且有一些 C++程序实际上是<strong>与 C 语言或其他语言</strong>的<strong>接口程序</strong>，当然也无法使用<strong>C++标准库</strong><br>
2、但是，现代的 C++ 程序不得不与那些<strong>充满了数组</strong>或<strong>C 风格字符串</strong>的代码衔接。为了使这一工作<strong>简单易行</strong>，C++专门提供了一组功能</p>
</blockquote>
</li>
<li>
<p><strong>混用</strong><code>string</code><strong>对象和 C 风格字符串</strong></p>
<blockquote>
<p>1、允许使用以<code>\0</code>结束的<strong>字符数组</strong>(即 C 风格字符串)来对<code>string</code><strong>对象</strong>进行<strong>初始化</strong>和<strong>赋值</strong><br>
2、在<code>string</code><strong>对象</strong>的<strong>加法运算</strong>中允许使用<strong>C 风格字符串</strong>作为其中<strong>一个运算对象</strong>(不能两个都是)；在<code>string</code><strong>对象</strong>的<strong>复合赋值运算</strong>中允许使用<strong>C 风格字符串</strong>作为<strong>右侧运算对象</strong><br>
3、上述性质<strong>反过来</strong>就<strong>不成立</strong>了：如果程序某处需要一个<strong>C 风格字符串</strong>，不能用<code>string</code><strong>对象</strong>代替它，例如不能用<code>string</code><strong>对象</strong>初始化一个<strong>指向 char 的指针</strong><br>
4、为了完成该功能，<code>string</code>专门提供了一个名为<code>c_str</code>的<strong>成员函数</strong>：其返回<strong>一个指针</strong>，指向一个<strong>C 风格字符串</strong>，该<strong>字符串内容</strong>与<code>string</code><strong>对象</strong>一样；指针的类型是<code>const *char</code>，确保<strong>不会改变字符数组的内容</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = s;                <span class="comment">// 错误，不能用string对象初始化指向char的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>();  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用数组初始化</strong><code>vector</code><strong>对象</strong></p>
<ul>
<li>
<p>允许使用<strong>数组</strong>来<strong>初始化</strong><code>vector</code><strong>对象</strong>。要实现这一目的，只需指明要<strong>拷贝区域</strong>的<strong>首元素地址</strong>和<strong>尾后地址</strong>即可(最简单的方式是用<code>begin</code>和<code>end</code>函数)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1><strong>表达式</strong></h1>
<hr>
<blockquote>
<p><strong>章节概要</strong>：特性补充；<strong>sizeof</strong>运算符；强制类型转换</p>
</blockquote>
<h2 id="特性补充"><strong>特性补充</strong></h2>
<ul>
<li>
<p>C++的<strong>表达式</strong>和<strong>运算符</strong>与 C 大部分相同，在此<strong>补充</strong>或<strong>强调</strong>一些特性</p>
</li>
<li>
<p><strong>sizeof 运算符</strong></p>
<blockquote>
<p>1、对<code>string</code>或<code>vector</code><strong>对象</strong>执行<code>sizeof</code><strong>运算符</strong>只返回<strong>该类型固定部分</strong>的<strong>大小</strong>，<strong>不会计算</strong>对象中的元素占用了多少<strong>空间</strong><br>
2、因为<code>sizeof</code>的<strong>返回值</strong>是一个<strong>常量表达式</strong><code>constexpr size_t</code>，因此可以用<code>sizeof</code>的结果<strong>声明数组的大小</strong></p>
</blockquote>
</li>
<li>
<p><strong>强制类型转换</strong></p>
<ul>
<li>
<p>一个命名的<strong>强制类型转换</strong>具有<strong>如下形式</strong>：<code>转换模式&lt;转换类型&gt;(表达式)</code></p>
</li>
<li>
<p>其中，<strong>转换模式</strong>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code>中的一种</p>
</li>
<li>
<p><code>static_cast</code><strong>模式</strong></p>
<blockquote>
<p>1、任何具有<strong>明确定义</strong>的<strong>类型转换</strong>，只要不包含<strong>底层</strong><code>const</code>，都可以使用<code>static_cast</code>，例如：<code>double slope = static_cast&lt;double&gt;(i);</code><br>
2、<code>static_cast</code>对于<strong>编译器无法自动执行</strong>的<strong>类型转换</strong>也非常有用，例如可以<strong>找回存在于</strong><code>void*</code><strong>的指针</strong>，转换回<strong>原始的指针类型</strong>，示例如后<br>
3、但是对于<strong>存在于</strong><code>void*</code><strong>的指针</strong>，应确保<strong>指针的值保持不变</strong>，且<strong>转换后所得类型</strong>就是<strong>指针所指类型</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任何非常量对象的地址都能存入void*</span></span><br><span class="line"><span class="type">void</span>* p = &amp;d;</span><br><span class="line"><span class="comment">//将void*转换回原始的指针类型(指向double的指针)</span></span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>const_cast</code><strong>模式</strong></p>
<blockquote>
<p>1、<code>const_cast</code><strong>只能改变</strong>运算对象的<strong>底层</strong><code>const</code>，对于将<strong>常量对象</strong>转换成<strong>非常量对象</strong>的行为，称其为<strong>去掉</strong><code>const</code><strong>性质</strong><br>
2、一旦<strong>去掉了</strong>某个对象的<code>const</code><strong>性质</strong>，编译器将<strong>不再阻止</strong>我们对该对象进行<strong>写入操作</strong><br>
3、如果对象<strong>本身不是一个常量</strong>，那么强制类型转换获得<strong>写权限</strong>是<strong>合法的行为</strong>；但如果对象<strong>本身是一个常量</strong>，则再使用<code>const_cast</code>执行<strong>写操作</strong>将产生<strong>未定义的后果</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);    <span class="comment">// 正确：但是写操作是未定义的行为</span></span><br><span class="line"><span class="comment">/*-----------------------------*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cp;</span><br><span class="line"><span class="type">char</span> *q = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(cp);   <span class="comment">// 错误：static_cast不能转换掉const性质</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;string&gt;(cp);             <span class="comment">// 错误，const_cast只能改变常量属性</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;string&gt;(cp);            <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>reinterpret_cast</code><strong>模式</strong></p>
<blockquote>
<p>1、<code>reinterpret_cast</code>通常为<strong>运算对象</strong>的<strong>位模式</strong>提供<strong>较低层次</strong>上的重新解释<br>
2、如下例，我们必须牢记<strong>pc</strong>所指的<strong>真实对象是 int 而非字符</strong>，如果把<strong>pc</strong>当成普通的<strong>字符指针</strong>使用就可以在运行时发生错误<br>
3、使用<code>reinterpret_cast</code>是<strong>非常危险</strong>的，其中关键问题是<strong>类型改变了</strong>，但编译器<strong>没有给出任何警告或错误提示</strong>。下面<strong>使用 pc 时</strong>就会认定它的值是<strong>char*类型</strong>，<strong>编译器没法知道</strong>它实际存放的是<strong>指向 int 的指针</strong><br>
4、<code>reinterpret_cast</code>本质上<strong>依赖于机器</strong>。想要安全地使用，必须对<strong>涉及的类型</strong>和<strong>编译器实现转换的过程</strong>都相当了解</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip);</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(pc)</span></span>;     <span class="comment">// 错误：可能导致异常的运行时行为</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>dynamic_cast</code><strong>模式</strong>：支持<strong>运行时类型识别</strong>，后续介绍</p>
</li>
<li>
<p>此外，C 语言的<strong>旧式强制类型转换</strong>仍然支持，但与 C++ 的相比，表现形式上不那么清晰明了，<strong>出错追踪比较困难</strong>，建议使用 C++ 的转换方式</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1><strong>语句</strong></h1>
<hr>
<blockquote>
<p><strong>章节概要</strong>：<code>try</code>语句块和异常处理；C++的异常处理；<code>throw</code>表达式；<code>try</code>语句块；编写处理代码；标准异常</p>
</blockquote>
<h2 id="try-语句块和异常处理"><strong>try 语句块和异常处理</strong></h2>
<ul>
<li>
<p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>异常</strong>是指存在于<strong>运行时</strong>的<strong>反常行为</strong>，这些行为超出了<strong>函数正常功能</strong>的范畴，典型的异常包括<strong>失去数据库连接</strong>以及<strong>遇到意外输入</strong>等。处理反常行为可能是设计所有系统最难的一部分<br>
2、当<strong>程序的某部分</strong>检测到一个让它<strong>无法处理</strong>的问题时，就需要用到<strong>异常处理</strong>。如果程序中含有<strong>可能引发异常的代码</strong>，那么通常也会有<strong>专门的代码处理问题</strong><br>
3、<strong>异常处理机制</strong>为程序中<strong>异常检测</strong>和<strong>异常处理</strong>这两部分的协作提供支持。C++中，异常处理包括以下部分</p>
</blockquote>
</li>
<li>
<p><strong>C++的异常处理</strong></p>
<blockquote>
<p>1、<code>throw</code><strong>表达式</strong>：<strong>异常检测</strong>部分使用<code>throw</code><strong>表达式</strong>来表示它<strong>遇到了无法处理的问题</strong>，我们说<code>throw</code><strong>引发了异常</strong><br>
2、<code>try</code><strong>语句块</strong>：<strong>异常处理</strong>部分使用<code>try</code><strong>语句块</strong>处理异常。<code>try</code>中包含<strong>一个或多个</strong><code>catch</code><strong>子句</strong>，抛出的<strong>异常</strong>通常会<strong>被某个</strong><code>catch</code><strong>子句处理</strong>。因为<code>catch</code><strong>子句</strong>处理异常，所以它们也被称为<strong>异常处理代码</strong><br>
3、一套<strong>类异常</strong>：用于在<code>throw</code><strong>表达式</strong>和相关的<code>catch</code><strong>子句</strong>之间<strong>传递异常的具体信息</strong></p>
</blockquote>
</li>
<li>
<p><strong>throw 表达式</strong></p>
<blockquote>
<p>1、程序的<strong>异常检测</strong>部分使用<code>throw</code><strong>表达式</strong>引发一个<strong>异常</strong>，形式如<code>throw 表达式;</code>，其中的<strong>表达式类型</strong>就是<strong>抛出的异常类型</strong><br>
2、如下示例，如果书籍的 ISBN 不一样就<strong>抛出异常</strong>，该<strong>异常类型是</strong><code>runtime_error</code><strong>对象</strong>。抛出异常将<strong>终止当前的函数</strong>，并把<strong>控制权</strong>转移给<strong>能处理该异常的代码</strong><br>
3、类型<code>runtime_error</code>是<strong>标准库异常类型</strong>的一种，定义在<code>stdexcept</code><strong>头文件</strong>中，后面将介绍其他的异常类型<br>
4、我们必须<strong>初始化</strong><code>runtime_error</code><strong>对象</strong>，方式是给它提供一个<code>string</code><strong>对象</strong>或一个<strong>C 风格字符串</strong>，这个字符串中有一些关于异常的<strong>辅助信息</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>())</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;数据必须具有相同的ISBN&quot;</span>);</span><br><span class="line">cout &lt;&lt; item1 + item2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>try 语句块</strong></p>
<blockquote>
<p>1、<code>try</code><strong>语句块</strong>的通用语法形式如下<br>
2、跟在<code>try</code><strong>块</strong>之后的是<strong>一个或多个</strong><code>catch</code><strong>子句</strong>。<code>catch</code><strong>子句</strong>包括三部分：<strong>关键字</strong><code>catch</code>、括号内一个(可能未命名的)<strong>对象的声明</strong>(称作异常声明)、以及<strong>一个块</strong><br>
3、当选中了某个<code>catch</code>子句<strong>异常处理之后</strong>，执行<strong>与之对应的块</strong>。<code>catch</code><strong>一旦执行完成</strong>，会<strong>跳转到</strong><code>try</code><strong>块</strong>中<strong>最后一个</strong><code>catch</code><strong>子句之后</strong>的语句继续执行<br>
4、<code>try</code><strong>块</strong>中的<strong>程序语句</strong>组成程序的<strong>正常逻辑</strong>，像其他任何块一样，可以有包括声明在内的任意 C++ 语句</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    程序语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(异常声明)</span><br><span class="line">&#123;</span><br><span class="line">    处理语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(异常声明)</span><br><span class="line">&#123;</span><br><span class="line">    处理语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>编写处理代码</strong></p>
<blockquote>
<p>1、编写<strong>异常处理代码</strong>，上面的程序可以按如下示例处理<br>
2、将程序<strong>本来要执行的任务</strong>放在<code>try</code><strong>语句块</strong>中，因为这段代码<strong>可能抛出异常</strong><br>
3、<code>try</code>对应一个<code>catch</code><strong>子句</strong>，该子句负责<strong>处理</strong><code>runtime_error</code><strong>类型的异常</strong>。如果<code>try</code>中抛出了<strong>此类异常</strong>，则会执行该<code>catch</code>内的语句<br>
4、<code>catch</code>中输出给用户的信息中，输出了<code>err.what()</code>的返回值。从<code>catch</code><strong>小括号的定义</strong>能得到<strong>err</strong>是一个<code>runtime_error</code><strong>类的对象</strong>，<code>what</code>则是该<strong>类</strong>的一个<strong>成员函数</strong><br>
5、<code>what</code>成员函数<strong>没有参数</strong>，<strong>返回值</strong>是<strong>C 风格字符串</strong>(即<code>const char*</code>)。其中，<code>runtime_error</code>的<code>what</code><strong>成员</strong>返回的是<strong>初始化一个具体对象</strong>时所用的<code>string</code><strong>对象的副本</strong>(即<code>try</code>中初始化的字符串)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; item1 &gt;&gt; item2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;数据必须具有相同的ISBN&quot;</span>);</span><br><span class="line">        cout &lt;&lt; item1 + item2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(runtime_error err)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n 再次尝试？输入y或n&quot;</span>&lt;&lt; endl;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(!cin || c == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">              cout &lt;&lt; <span class="string">&quot;程序退出&quot;</span> &lt;&lt; endl;</span><br><span class="line">              <span class="keyword">break</span>;          <span class="comment">// 跳出 while 循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>标准异常</strong></p>
<ul>
<li>
<p><strong>标准异常类</strong></p>
<blockquote>
<p>1、C++<strong>标准库</strong>中定义了一组<strong>类</strong>，用于报告<strong>标准库函数</strong>遇到的问题。这些<strong>异常类</strong>也可以在<strong>用户编写的程序中</strong>使用，分别定义在<strong>4 个头文件</strong><br>
2、<code>exception</code>：定义了<strong>最通用的异常类</strong><code>exception</code>，它<strong>只报告异常的发生</strong>，<strong>不提供任何额外信息</strong><br>
3、<code>stdexcept</code>：定义了几种<strong>常用的异常类</strong>，详细信息见下表<br>
4、<code>new</code>：定义了<code>bad_alloc</code><strong>异常类型</strong>，后续介绍<br>
5、<code>type_info</code>：定义了<code>bad_cast</code><strong>异常类型</strong>，后续介绍</p>
</blockquote>
<table>
<thead>
<tr>
<th>stdexcept 定义的异常类</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>exception</td>
<td>最常见的错误</td>
</tr>
<tr>
<td>runtime_error</td>
<td>只有在运行时才能检测出的任务</td>
</tr>
<tr>
<td>range_error</td>
<td>运行时错误：生成的结果超出了有意义的值域范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>运行时错误：计算上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>运行时错误：计算下溢</td>
</tr>
<tr>
<td>logic_error</td>
<td>程序逻辑错误</td>
</tr>
<tr>
<td>domain_error</td>
<td>逻辑错误：参数对应的结果值不存在</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>逻辑错误：无效参数</td>
</tr>
<tr>
<td>length_error</td>
<td>逻辑错误：试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
<td>out_of_range</td>
<td>逻辑错误：使用一个超出有效范围的值</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>运算与成员</strong></p>
<blockquote>
<p>1、<strong>标准库异常类</strong>只定义了几种运算，包括<strong>创建或拷贝异常类型的对象</strong>，以及<strong>为异常类型的对象赋值</strong><br>
2、我们只能以<strong>默认初始化</strong>的方式初始化<code>exception</code>、<code>bad_alloc</code>、<code>bad_cast</code>对象，<strong>不允许</strong>为这些对象<strong>提供初始值</strong><br>
3、<strong>其他异常类型</strong>的行为恰好相反，应该使用<code>string</code><strong>对象</strong>或者<strong>C 风格字符串</strong>初始化这些类型的对象，<strong>不允许</strong>使用<strong>默认初始化</strong>的方式。创建此类对象时，<strong>必须提供初始值</strong>，该值含有<strong>错误相关信息</strong><br>
4、<strong>异常类型</strong>之定义了一个名为<code>what</code>的<strong>成员函数</strong>，返回值是<strong>C 风格字符串</strong>，字符串的目的是<strong>提供关于异常的一些文本信息</strong>。对于其他<strong>无初始值的异常类型</strong>，<code>what</code>返回的内容由<strong>编译器决定</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h1><strong>函数</strong></h1>
<hr>
<blockquote>
<p><strong>章节概要</strong>：含有可变形参的函数；<code>initializer_list</code>形参；函数的返回值；不要返回局部对象的引用或指针；返回数组指针的函数；函数重载；定义重载函数；重载和<code>const</code>形参；<code>const_cast</code>和重载；特殊用途语言特性；默认实参；内联函数；<code>constexpr</code>函数</p>
</blockquote>
<h2 id="含有可变形参的函数"><strong>含有可变形参的函数</strong></h2>
<ul>
<li>
<p><strong>简介</strong></p>
<blockquote>
<p>1、有时我们<strong>无法提前预知</strong>应该向函数<strong>传递几个实参</strong>。为了编写<strong>能处理不同数量实参</strong>的函数，C++11 提供了以下几种方法<br>
2、如果所有的<strong>实参类型相同</strong>，可以传递一个名为<code>initializer_list</code>的<strong>标准库类型</strong><br>
3、如果<strong>实参类型不同</strong>，可以编写一种特殊的函数——<strong>可变参数模板</strong>，将在后续介绍<br>
4、此外还有一种从<strong>C 标准库</strong><code>stdarg.h</code>继承而来的<strong>省略符形参</strong><code>...</code>，但有了一些限制</p>
</blockquote>
</li>
<li>
<p><strong>initializer_list 形参</strong></p>
<ul>
<li>
<p><strong>简介</strong></p>
<blockquote>
<p>1、<code>initializer_list</code>是一种<strong>标准库类型</strong>，用于表示<strong>某种特定类型的值的数组</strong>，其定义在<code>initializer_list</code><strong>头文件</strong>中<br>
2、和<code>vector</code>一样，<strong>该类型</strong>也是一种<strong>模板类型</strong>，这意味着<strong>定义对象</strong>时，也必须说明列表中<strong>所含元素的类型</strong>：<code>initializer_list&lt;int&gt; li;</code><br>
3、和<code>vector</code>不同的是，该类型对象中的<strong>元素永远是常量值</strong>，我们<strong>无法改变</strong>该类型对象中<strong>元素的值</strong></p>
</blockquote>
</li>
<li>
<p><strong>使用</strong></p>
<blockquote>
<p>1、我们可以使用<strong>该类型</strong>作为函数的<strong>形参</strong>，使用<strong>迭代器</strong>访问<strong>列表中的元素</strong><br>
2、使用函数时，如果想向<code>initializer_list</code><strong>形参</strong>中<strong>传递一个值的序列</strong>，则必须把<strong>序列</strong>放在一对<strong>花括号</strong>内<br>
3、含有<code>initializer_list</code><strong>形参</strong>的函数也<strong>可以同时拥有其他形参</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(<span class="type">int</span> error_code, initializer_list&lt;string&gt; i1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;error code:&quot;</span> &lt;&lt; error_code;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> beg = i1.<span class="built_in">begin</span>(); beg != i1.<span class="built_in">end</span>(); beg++)</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传参使用</span></span><br><span class="line"><span class="type">int</span> error_number = <span class="number">15</span>;</span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;error1&quot;</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">&quot;error2&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">error_msg</span>(error_number, &#123;<span class="string">&quot;function&quot;</span>, s1, s2&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>省略号形参</strong><code>...</code></p>
<blockquote>
<p>1、<strong>省略号形参</strong><code>...</code>沿用自<strong>C 语言的</strong><code>stdarg.h</code><strong>库</strong>，为了便于<strong>C++程序</strong>访问某些特殊的<strong>C 代码</strong><br>
2、但省略符形参应该<strong>仅仅用于 C 和 C++ 通用的类型</strong>。特别应该注意，C++的大多数<strong>类类型的对象</strong>传递时都<strong>无法正确拷贝</strong></p>
</blockquote>
</li>
</ul>
<h2 id="函数的返回值"><strong>函数的返回值</strong></h2>
<ul>
<li>
<p><strong>不要返回局部对象的引用或指针</strong></p>
<blockquote>
<p>1、函数完成后，所占用的<strong>内存空间</strong>也会<strong>随之释放</strong>。由此，<strong>局部变量的引用</strong>和<strong>指向局部变量的指针</strong>将指向<strong>不再有效的内存区域</strong><br>
2、如下示例，对于两条<code>return</code>语句，都将返回<strong>未定义的值</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数返回值类型是const string &amp;，即一个引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ret;</span><br><span class="line">    <span class="keyword">if</span> (!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret;       <span class="comment">// 错误：返回了局部对象的引用，返回的引用将指向无效区域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>;       <span class="comment">// 错误：Empty也是一个局部临时量，返回的引用将指向无效区域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>返回数组指针的函数</strong></p>
<ul>
<li>
<p><strong>直接声明</strong></p>
<blockquote>
<p>1、如果我们想定义一个<strong>返回数组指针的函数</strong>，则<strong>数组的下标数</strong>必须<strong>跟在函数名后</strong>。而函数的<strong>形参列表</strong>也跟在<strong>函数名后</strong>，且应该<strong>先于数组的下标数</strong><br>
2、因此，<strong>返回数组指针的函数</strong>形式如：<code>类型 (* 函数名(形参列表))[数组下标数]</code>，具体的例子和解读如下(可以参考<a target="_blank" rel="noopener" href="https://www.shengqibaozao.eu.org/2022/08/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99/">类型声明黄金法则</a>)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/*---------------------*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解读：</span></span><br><span class="line"><span class="comment">func(int i)             ：表示函数需要一个int类型形参</span></span><br><span class="line"><span class="comment">(*func(int i))          ：返回类型是一个指针</span></span><br><span class="line"><span class="comment">(*func(int i))[10]      ：指针指向一个大小是10的数组</span></span><br><span class="line"><span class="comment">int (*func(int i))[10]  ：指向的是一个含有10个int值的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用尾置返回类型</strong></p>
<blockquote>
<p>1、在 C++11 新标准中还有一种可以<strong>简化上述声明</strong>的方法，就是使用<strong>尾置返回类型</strong><br>
2、<strong>任何函数的定义</strong>都能使用<strong>尾置返回</strong>，但这种形式对于<strong>返回类型比较复杂</strong>的函数最有效，比如返回类型是<strong>数组的指针</strong>或者<strong>数组的引用</strong><br>
3、<strong>尾置返回类型</strong>跟在<strong>形参列表</strong>后面并以一个<code>-&gt;</code><strong>符号开头</strong>。为了表示函数<strong>真正的返回类型</strong>跟在<strong>形参列表后</strong>，原先<strong>标识返回值的地方</strong>改为<code>auto</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数返回一个指针，指向含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用</strong><code>decltype</code><strong>获取类型</strong></p>
<blockquote>
<p>1、还有一种情况，<strong>如果知道</strong>函数返回的<strong>指针将指向哪个数组</strong>，可以使用<code>decltype</code>来<strong>声明返回类型</strong>，如下例<br>
2、<code>decltype(odd)</code>标识了<strong>返回类型</strong>是一个<strong>含有 5 个 int 值的数组</strong>，<code>*</code>标识了<strong>返回类型</strong>是一个<strong>指针</strong><br>
3、有一个地方要注意，<code>decltype</code>并<strong>不负责</strong>把数组类型<strong>转换成</strong>相应的<strong>指针</strong>，所以如果需要返回<strong>指向数组的指针</strong>的函数，需要像下例中<strong>声明时</strong>加一个<code>*</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// 使用 decltype(odd) 获取类型</span></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;  <span class="comment">// 返回一个指向数组的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="函数重载"><strong>函数重载</strong></h2>
<ul>
<li>
<p><strong>简介</strong></p>
<blockquote>
<p>1、如果<strong>同一作用域</strong>内的几个函数<strong>名字相同</strong>但<strong>形参列表不同</strong>，我们称之为<strong>重载函数</strong>。如下例<br>
2、这些函数接受的<strong>形参类型不同</strong>，但是执行的<strong>操作非常相似</strong>，使用<strong>函数重载</strong>可以在一定程度上减轻起名记名的负担<br>
3、当<strong>调用这些函数</strong>时，编译器会<strong>根据传递的实参</strong>判断具体想要执行的是<strong>哪个函数</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *cp)</span></span>;               <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *beg, <span class="type">int</span> *end)</span></span>;     <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span>;  <span class="comment">// 3</span></span><br><span class="line"><span class="comment">/*--------------------------------------*/</span></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="type">int</span> j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>);         <span class="comment">// 调用 1</span></span><br><span class="line"><span class="built_in">print</span>(j, <span class="built_in">end</span>(j) - <span class="built_in">begin</span>(j));  <span class="comment">// 调用 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">begin</span>(j), <span class="built_in">end</span>(j));      <span class="comment">// 调用 2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>定义重载函数</strong></p>
<blockquote>
<p>1、对于定义的<strong>重载函数</strong>来说，它们至少应该在<strong>形参数量</strong>或<strong>形参类型</strong>上<strong>有所不同</strong><br>
2、假设有两个函数，他们的<strong>返回类型不同</strong>但<strong>形参列表相同</strong>，这种声明不是<strong>重载函数</strong>，是<strong>错误的</strong><br>
3、有时候两个<strong>形参列表看起来不一样</strong>，但实际是<strong>相同</strong>的。比如<strong>省略了形参名</strong>，或使用<strong>类型别名</strong><br>
4、<strong>不能重载</strong><code>main()</code><strong>函数</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许两个函数除了返回类型不同其余都相同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;    <span class="comment">// 错误</span></span><br><span class="line"><span class="comment">/*--------------------------------*/</span></span><br><span class="line"><span class="comment">// 形参列表相同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Account &amp;acct)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;    <span class="comment">// 相同，省略了形参名</span></span><br><span class="line"><span class="keyword">typedef</span> Phone Telno;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Phone&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Telno&amp;)</span></span>;      <span class="comment">// 相同，使用了类型别名</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>重载和 const 形参</strong></p>
<blockquote>
<p>1、<strong>顶层</strong><code>const</code>不影响传入函数的<strong>对象</strong>，一个拥有<strong>顶层</strong><code>const</code><strong>的形参</strong>无法和另一个<strong>没有顶层</strong><code>const</code><strong>的形参</strong>区分开来<br>
2、如果<strong>形参</strong>是某种类型的<strong>指针或引用</strong>，则通过<strong>区分</strong>其<strong>指向</strong>的是<strong>常量对象</strong>还是<strong>非常量对象</strong>可以实现<strong>函数重载</strong>，注意此时的<code>const</code><strong>是底层的</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone)</span></span>;       <span class="comment">// 重复声明了void lookup(Phone)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Phone* <span class="type">const</span>)</span></span>;      <span class="comment">// 重复声明了void lookup(Phone*)，顶层const</span></span><br><span class="line"><span class="comment">/*------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;          <span class="comment">// 作用于Account的引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;    <span class="comment">// 新函数，作用于常量引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(Account*)</span></span>;          <span class="comment">// 作用于指向Account的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account*)</span></span>;    <span class="comment">// 新函数，作用于指向常量的指针，底层const</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>const_cast 和重载</strong></p>
<blockquote>
<p>1、<code>const_cast</code>在<strong>重载函数</strong>的情境中最有用，如下例<br>
2、<strong>原函数</strong>的<strong>参数</strong>和<strong>返回类型</strong>都是<code>const string</code><strong>的引用</strong>。虽然我们可以对两个<strong>非常量的</strong><code>string</code>调用这个函数，但<strong>返回结果</strong>仍是<code>const string</code>，我们并<strong>不希望返回的是常量</strong><br>
3、此时我们需要一种<strong>新的函数</strong>，当它的<strong>实参不是常量</strong>时，得到的结果是一个<strong>非常量引用</strong>，使用<code>const_cast</code>可以很方便做到这一点<br>
4、<strong>新函数</strong>内通过<code>const_cast</code>把参数先转为<strong>常量</strong>，调用<strong>原函数</strong>，再将<strong>原函数结果</strong>转为<strong>非常量</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原函数，返回 const string 的引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载函数，返回非 const 的引用</span></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1), <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="特殊用途语言特性"><strong>特殊用途语言特性</strong></h2>
<ul>
<li>
<p><strong>默认实参</strong></p>
<blockquote>
<p>1、可以将<strong>函数</strong>的<strong>形参列表</strong>中的值赋予初始值，这便是<strong>默认实参</strong>。当<strong>函数调用</strong>时，如果<strong>没有给定这个值的实参</strong>，便会使用<strong>默认实参</strong><br>
2、我们可以为<strong>一个或多个形参</strong>赋予默认值。但要注意，一旦某个形参被赋予了默认值，它<strong>后面的所有形参</strong>都<strong>必须有默认值</strong><br>
3、<strong>函数调用</strong>时，实参按照<strong>位置顺序</strong>解析，<strong>默认实参</strong>负责填补函数调用<strong>缺少的尾部实参</strong>(即靠右侧位置的形参)。即<strong>不能省略前面的参数值</strong>，<strong>只能省略尾部的参数值</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认实参函数定义</span></span><br><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">24</span>, <span class="type">char</span> background = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">string window;</span><br><span class="line">window = <span class="built_in">screen</span>();            <span class="comment">// screen(24, 80, &#x27; &#x27;)</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="number">66</span>);          <span class="comment">// screen(66, 80, &#x27; &#x27;)</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>,<span class="string">&#x27;#&#x27;</span>)   <span class="comment">// screen(66, 256, &#x27;#&#x27;)</span></span><br><span class="line"><span class="comment">// 错误调用</span></span><br><span class="line">window = <span class="built_in">screen</span>(, , <span class="string">&#x27;?&#x27;</span>);     <span class="comment">// 错误</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="string">&#x27;?&#x27;</span>);         <span class="comment">// 错误，screen(&#x27;?&#x27;, 80, &#x27; &#x27;)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>内联函数</strong></p>
<blockquote>
<p>1、使用<code>inline</code>将函数指定为<strong>内联函数</strong>，通常就是将它在<strong>每个调用点</strong>上<strong>内联地展开</strong>，可以<strong>避免函数调用的开销</strong>。说明如下示例<br>
2、<strong>内联</strong>只是向<strong>编译器</strong>发出的<strong>一个请求</strong>，<strong>编译器</strong>可以选择<strong>忽略这个请求</strong><br>
3、一般来说，<strong>内联机制</strong>用于<strong>优化规模较小</strong>、<strong>流程直接</strong>、<strong>调用频繁</strong>的函数。很多编译器不支持<strong>内联递归函数</strong>，而且一个<strong>大于 75 行</strong>的函数也不大可能在<strong>调用点内联展开</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原函数即程序调用</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line">string s1 = <span class="string">&quot;abcde&quot;</span>, s2 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">shorterString</span>(s1, s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在编译过程中，函数调用将直接展开成下面形式，从而不经过shorterString，减少了函数调用的开销</span></span><br><span class="line">cout &lt;&lt; (s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>constexpr 函数</strong></p>
<blockquote>
<p>1、<code>constexpr</code><strong>函数</strong>是指能用于<strong>常量表达式</strong>的函数。定义的方法与其他函数类似，但<strong>有如下规定</strong>：函数的<strong>返回类型</strong>及<strong>所有形参</strong>都必须是<strong>字面值类型</strong>，而且函数体中必须<strong>有且仅有一条</strong><code>return</code><strong>语句</strong><br>
2、执行<strong>初始化任务</strong>时，<strong>编译器</strong>把<strong>对</strong><code>constexpr</code><strong>函数的调用</strong>都替换成其<strong>结果值</strong>。为了能在编译过程中<strong>随时展开</strong>，<code>constexpr</code><strong>函数</strong>被<strong>隐式指定为内联函数</strong><br>
3、<code>constexpr</code><strong>函数</strong>不一定返回常量表达式</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> ct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * ct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];      <span class="comment">// 正确，编译时 scale(2) 将被内联展开为 6</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)];       <span class="comment">// 错误，i不是常量表达式</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1><strong>类</strong></h1>
<hr>
<blockquote>
<p><strong>章节概要</strong>：定义抽象数据类型；设计<code>Sales_data</code>类；定义<code>Sales_data</code>类；分析与设计；<code>this</code>参数；<code>const</code>成员函数；返回<code>this</code>对象的函数；该类相关的非成员函数；构造函数；合成的默认构造函数；合成的默认构造函数的局限性；定义构造函数；<code>= default</code>的含义；构造函数初始值列表；类外定义构造函数；拷贝、赋值和析构；访问控制与封装；<code>public</code>和<code>private</code>；<code>class</code>和<code>struct</code>；友元；类的其他特性；类成员再探；<code>mutable</code>可变数据成员；返回<code>*this</code>的成员函数；从<code>const</code>成员函数返回<code>*this</code>；基于<code>const</code>的重载；友元再探；类之间的友元关系；令函数成员作为友元；友元函数重载和作用域；类的作用域；名字查找与类作用域；构造函数再探；委托构造函数；隐式类类型转换；<code>explicit</code>抑制构造函数隐式转换；聚合类；字面值常量类；<code>constexpr</code>构造函数；类的静态成员；声明、使用、定义静态成员；静态成员的类内初始化；静态成员与普通成员的区别</p>
</blockquote>
<h2 id="定义抽象数据类型"><strong>定义抽象数据类型</strong></h2>
<ul>
<li>
<p><strong>抽象数据类型</strong></p>
<blockquote>
<p>1、如果一个类，我们可以通过它的<strong>接口</strong>(例如描述的操作)来<strong>使用该类的对象</strong>，但<strong>不能访问该类的数据成员</strong>(甚至不知道该类有哪些数据成员)，我们称<strong>这样的类</strong>为<strong>抽象数据类型</strong><br>
2、反之，如果一个类<strong>允许用户</strong>直接<strong>访问它的数据成员</strong>，并要求<strong>用户</strong>来<strong>编写操作</strong>，<strong>这样的类</strong>不是一个抽象数据类型<br>
3、对于一个<strong>普通的数据类型</strong>(非抽象数据类型)，如果想把它变成<strong>抽象数据类型</strong>，我们需要<strong>定义一些操作</strong>供类的用户使用。一旦<strong>定义了自己的操作</strong>，我们就可以<strong>封装它的数据成员</strong>了</p>
</blockquote>
</li>
<li>
<p><strong>设计 Sales_data 类</strong></p>
<ul>
<li>
<p><strong>引入</strong></p>
<blockquote>
<p>1、为了方便图书管理，我们需要<strong>设计一个类</strong>便于<strong>信息存储</strong>与<strong>操作</strong>，需要先<strong>分析满足下列操作</strong>：<br>
2、类中需要有<strong>能读写的数据对象</strong>，需要对这些对象<strong>支持一些操作</strong><br>
3、<strong>操作包括</strong>一个名为<code>isbn</code>的<strong>成员函数</strong>，并且支持<code>+</code>、<code>=</code>、<code>+=</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code><strong>运算符</strong><br>
4、我们将在后续学习<strong>重载运算符</strong>，现在对于<strong>运算符运算</strong>，我们先定义为<strong>普通函数</strong>的形式<br>
5、由于特殊的原因(后续重载运算符介绍)，执行<strong>加法</strong>和<strong>IO 的函数</strong>不作为<strong>类的成员</strong>，我们将其定义成<strong>普通函数</strong></p>
</blockquote>
</li>
<li>
<p><strong>该类应包含的操作</strong></p>
<blockquote>
<p>1、一个<code>isbn</code><strong>成员函数</strong>，返回<strong>对象的 ISBN 编号</strong><br>
2、一个<code>combine</code><strong>成员函数</strong>，用于将一个<code>Sales_data</code><strong>对象加到另一个对象上</strong><br>
3、一个<code>add</code><strong>函数</strong>，执行两个<code>Sales_data</code>对象的<strong>加法</strong><br>
4、一个<code>read</code><strong>函数</strong>，将数据从<code>istream</code><strong>读入到</strong><code>Sales_data</code><strong>对象中</strong><br>
5、一个<code>print</code><strong>函数</strong>，将<code>Sales_data</code><strong>对象的值输出到</strong><code>ostream</code>中</p>
</blockquote>
</li>
<li>
<p><strong>使用类的接口</strong>(先不考虑如何实现该类，首先看看应该如何使用这些接口函数)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data total;             <span class="comment">// 保存当前求和结果的变量</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(cin, total))          <span class="comment">// 读入第一笔交易</span></span><br><span class="line">&#123;</span><br><span class="line">    Sales_data trans;         <span class="comment">// 保存下一条交易数据的变量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(cin, trans))   <span class="comment">// 读入剩余的交易</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(total.<span class="built_in">isbn</span>() == trans.<span class="built_in">isbn</span>())    <span class="comment">// 检查 isbn</span></span><br><span class="line">          total.<span class="built_in">combine</span>(trans);             <span class="comment">// 更新变量 total 当前的值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">print</span>(cout, total) &lt;&lt; endl;     <span class="comment">// 输出结果</span></span><br><span class="line">            total = trans;                  <span class="comment">// 处理下一本书</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(cout, total) &lt;&lt; endl; <span class="comment">// 输出最后一条交易</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                            <span class="comment">// 如果没有输入</span></span><br><span class="line">&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;No data?&quot;</span> &lt;&lt; endl; <span class="comment">// 通知用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>定义 Sales_data 类</strong></p>
<ul>
<li>
<p><strong>分析与设计</strong></p>
<blockquote>
<p>1、该类的<strong>数据成员</strong>有：<code>string</code>类型的<strong>bookNo</strong>，表示 ISBN 编号；<code>unsigned</code>类型的<strong>units_sold</strong>，表示某书的销量；<code>double</code>类型的<strong>revenue</strong>，表示这本书的总销售收入<br>
2、类中将包含<code>combine</code>和<code>isbn</code>两个<strong>成员函数</strong>，此外，我们还需要另一个<strong>成员函数</strong><code>avg_price</code>返回售出书籍的平均价格。由于<code>avg_price</code>的<strong>目的并非通用</strong>，所以它应该属于<strong>类的实现的一部分</strong>，而不是<strong>接口的一部分</strong><br>
3、<strong>定义</strong>和<strong>声明</strong>一个<strong>成员函数</strong>的方法与普通函数差不多。<strong>成员函数的声明</strong>必须在<strong>类的内部</strong>，而它的<strong>定义可以在外部</strong>。作为<strong>接口组成部分</strong>的<strong>非成员函数</strong><code>add</code>、<code>read</code>、<code>print</code>等，它们的<strong>定义和声明</strong>都在<strong>类的外部</strong><br>
4、定义在<strong>类内部的函数</strong>是<strong>隐式的内联函数</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;)</span></span>;    <span class="comment">// 将在类外定义</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;                   <span class="comment">// 将在类外定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>this</code><strong>参数</strong></p>
<blockquote>
<p>1、<code>isbn</code><strong>成员函数</strong>是如何获得<strong>bookNo 成员</strong>所依赖的<strong>对象</strong>的呢？<br>
2、观察对<code>isbn</code>的<strong>调用</strong>：<code>total.isbn()</code>。我们使用了<strong>点运算符</strong>来访问<strong>total 对象</strong>中的<code>isbn</code><strong>成员函数</strong>并调用它<br>
3、还有一种<strong>例外的形式</strong>，当我们<strong>调用成员函数</strong>时，实际上是在<strong>替某个对象调用它</strong>。如果<code>isbn</code>指向<code>Sales_data</code>的<strong>成员</strong>(如 bookNo)，则它<strong>隐式地</strong>指向<strong>调用该函数的对象的成员</strong>。在上例中，当<code>isbn</code>返回<strong>bookNo</strong>时，实际上它<strong>隐式地</strong>返回<strong>total.bookNo</strong><br>
4、<strong>成员函数</strong>通过名为<code>this</code>的<strong>额外的隐式参数</strong>来访问和调用它的那个对象，当我们<strong>调用成员函数</strong>时，会用<strong>请求该函数的对象地址</strong>初始化<code>this</code>。例如调用<code>total.isbn()</code>时，<strong>编译器</strong>负责把<strong>total 的地址</strong>传递给<code>isbn</code>的<strong>隐式形参</strong><code>this</code><br>
5、在<strong>成员函数体</strong>内部，也可以直接使用<strong>调用该函数的对象的成员</strong>，而无须通过<strong>成员访问运算符</strong>，因为<code>this</code>所指的<strong>正是这个对象</strong>。任何对<strong>类成员</strong>的<strong>直接访问</strong>都被看作<code>this</code>的<strong>隐式引用</strong><br>
6、对于我们来说，<code>this</code><strong>形参</strong>是<strong>隐式定义</strong>的，我们可以在<strong>成员函数体</strong>内部使用<code>this</code>。尽管没有必要，但我们还是可以把<code>isbn</code>的<strong>函数体写为</strong><code>return this-&gt;bookNo;</code><br>
7、因为<code>this</code><strong>总是指向这个对象</strong>，所以<code>this</code>是一个<strong>常量指针</strong>，<strong>不允许修改</strong><code>this</code>中保存的地址</p>
</blockquote>
</li>
<li>
<p><code>const</code><strong>成员函数</strong></p>
<blockquote>
<p>1、<code>isbn</code>函数的另一个<strong>关键之处</strong>是<strong>参数列表后的</strong><code>const</code>，这里，<code>const</code>的作用是<strong>修改隐式</strong><code>this</code><strong>指针的类型</strong><br>
2、默认情况下，<code>this</code>的类型是<strong>指向类类型</strong>的<strong>非常量版本</strong>的<strong>常量指针</strong>，例如<code>Sales_data</code><strong>成员函数</strong>中，<code>this</code>的类型是<code>Sales_data *const</code>。这意味着，我们不能把<code>this</code>绑定到一个<strong>常量对象</strong>上，这使得不能在一个<strong>常量对象</strong>上调用<strong>普通的成员函数</strong><br>
3、如果<code>isbn</code>是一个<strong>普通函数</strong>且<code>this</code>是一个<strong>普通指针形参</strong>，则我们<strong>应该把</strong><code>this</code><strong>声明成</strong><code>const Sales_data *const</code><strong>类型</strong>，毕竟<code>isbn</code>函数体内<strong>不会改变</strong><code>this</code><strong>所指的对象</strong><br>
4、然而，<code>this</code><strong>是隐式的</strong>而且不会出现在<strong>形参列表</strong>中，在哪将<code>this</code>声明成<strong>指向常量的指针</strong>？C++的做法是把<code>const</code>放在成员函数的<strong>参数列表后</strong><br>
5、紧跟在<strong>参数列表后</strong>的<code>const</code>表示<code>this</code>是一个<strong>指向常量的指针</strong>，而像这样使用<code>const</code>的<strong>成员函数</strong>称作<strong>常量成员函数</strong></p>
</blockquote>
</li>
<li>
<p><strong>在类的外部定义成员函数</strong></p>
<blockquote>
<p>1、前面提过<strong>成员函数的定义可以在类外</strong>，我们的<code>avg_price</code>和<code>combine</code><strong>成员函数</strong>就打算通过这种方式定义<br>
2、要注意，<strong>类外部定义的成员的名字</strong>必须包含<strong>所属的类名</strong>，通过<strong>作用域运算符</strong>来告知<strong>编译器</strong>定义的这个函数是<strong>类内的成员函数</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>返回</strong><code>this</code><strong>对象的函数</strong></p>
<blockquote>
<p>1、函数<code>combine</code>的设计初衷类似于<strong>复合赋值运算符</strong><code>+=</code>，其定义如下<br>
2、当程序调用<code>total.combine(trans);</code>时，<code>this</code>指针绑定了<strong>total 的地址</strong>，<strong>rhs 引用</strong>绑定了<strong>实参 trans</strong><br>
3、该函数值得关注的是它的<strong>返回类型</strong>和<strong>返回语句</strong>。模仿标准的<strong>赋值运算符</strong>把它的<strong>左侧运算对象</strong>当做<strong>左值</strong>返回，因此<code>combine</code><strong>必须返回引用</strong>，而<strong>左侧运算对象</strong>又是<code>Sales_data</code><strong>对象</strong>，因此返回类型是<code>Sales_data&amp;</code><br>
4、如前所述，我们需要<strong>把该对象当做左值返回</strong>。我们无须使用隐式的<code>this</code>指针访问<strong>函数调用者</strong>的<strong>某个具体成员</strong>，而是要把<strong>调用函数的对象</strong>当做一个整体来访问，即<code>return *this;</code>，该调用<strong>返回 total 的引用</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 把 rhs 的成员加到 this 的成员上</span></span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="comment">// 返回调用该函数的对象</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>该类相关的非成员函数</strong></p>
<ul>
<li>
<p><code>read</code>和<code>print</code>函数</p>
<blockquote>
<p>1、<code>read</code>和<code>print</code>函数分别接受一个<strong>各自 IO 类型的引用</strong>作为其参数，是因为<strong>IO 类</strong>属于<strong>不能被拷贝的类型</strong>，因此只能<strong>通过引用传递</strong>。而且，读取和写入的操作<strong>会改变流的内容</strong>，所以使用<strong>普通引用</strong>而不是<code>const</code><strong>引用</strong><br>
2、<code>print</code><strong>函数不负责换行</strong>。一般来说，<strong>执行输出任务的函数</strong>应该尽量<strong>减少对格式的控制</strong>，这样可以确保<strong>由用户代码决定</strong>是否换行</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入的交易信息包括 ISBN、售出总数、售出单价</span></span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; item.revenue &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>add</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rsh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sales_data sum = lhs; <span class="comment">// 把 lhs 的数据成员拷贝给 sum</span></span><br><span class="line">    sum.<span class="built_in">combine</span>(rsh);     <span class="comment">// 把 rsh 的数据成员添加到 sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;           <span class="comment">// 返回新的 Sales_data 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>构造函数</strong></p>
<ul>
<li>
<p><strong>介绍</strong></p>
<blockquote>
<p>1、每个<strong>类</strong>都分别定义了它的<strong>对象被初始化的方式</strong>，<strong>类</strong>通过一个或几个<strong>特殊的成员函数</strong>控制其对象的初始化过程，<strong>这些函数</strong>被称为<strong>构造函数</strong><br>
2、<strong>构造函数</strong>的任务是<strong>初始化类对象</strong>的<strong>数据成员</strong>，无论何时只要<strong>有类的对象被创建</strong>，<strong>就会执行构造函数</strong><br>
3、构造函数的<strong>名字和类名相同</strong>。和其他函数不同的是，构造函数<strong>没有返回类型</strong>，且不能被声明成<code>const</code>。类可以包含<strong>多个构造函数</strong>，和其他<strong>重载函数</strong>类似<br>
4、当我们创建类的一个<code>const</code><strong>对象</strong>时，直到<strong>构造函数完成初始化</strong>过程，对象才真正取得了<strong>常量属性</strong>。因此<strong>构造函数</strong>在<code>const</code><strong>对象</strong>的构造过程中<strong>可以向其写值</strong></p>
</blockquote>
</li>
<li>
<p><strong>合成的默认构造函数</strong></p>
<blockquote>
<p>1、我们的<code>Sales_data</code>类并没有定义任何<strong>构造函数</strong>，可是之前<strong>使用了</strong><code>Sales_data</code><strong>对象</strong>的程序却没有异常，它们是如何初始化的？<br>
2、我们没有为这些对象<strong>提供初始值</strong>，它们执行了<strong>默认初始化</strong>。<strong>类</strong>通过一个<strong>特殊的构造函数</strong>来控制<strong>默认初始化过程</strong>，这个函数叫做<strong>默认构造函数</strong>，其<strong>无须任何实参</strong><br>
3、如我们所见，<strong>默认构造函数</strong>在很多方面都有其<strong>特殊性</strong>。其中之一是，如果我们的类<strong>没有显式定义构造函数</strong>，编译器会为我们<strong>隐式定义一个默认构造函数</strong>，这样的函数有称为<strong>合成的默认构造函数</strong><br>
4、对于大多数类来说，这个<strong>合成的默认构造函数</strong>将按照<strong>如下规则</strong>初始化数据：使用<strong>类内的初始值</strong>(如果有的话)<strong>初始化</strong>成员，否则<strong>默认初始化该成员</strong></p>
</blockquote>
</li>
<li>
<p><strong>合成的默认构造函数的局限性</strong></p>
<blockquote>
<p>1、<strong>合成的默认构造函数</strong>只适合<strong>非常简单</strong>的类，对于一个<strong>普通的类</strong>来说，<strong>必须</strong>定义它自己的<strong>默认构造函数</strong>，原因有三：<br>
2、首先，编译器只有在发现<strong>类不包含任何构造函数时</strong>才会替我们生成默认构造函数，一旦我们<strong>定义了一些其他构造函数</strong>，除非我们<strong>再定义</strong>一个<strong>默认生成函数</strong>，否则类将<strong>没有默认构造函数</strong>。如果一个类需要<strong>在某种情况下控制初始化</strong>，那么该类很可能<strong>在所有情况下都需要控制</strong><br>
3、其次，对于某些类来说，<strong>合成的默认构造函数</strong>可能执行<strong>错误的操作</strong>。如果定义在<strong>块中的内置类型</strong>或数组指针这类的<strong>复合类型的对象</strong>被<strong>默认初始化</strong>，它们的值是<strong>未定义</strong>的。因此这样的类应该在<strong>类内初始化</strong>这些成员，或定义一个自己的<strong>默认构造函数</strong><br>
4、最后，有时候<strong>编译器</strong>不能为<strong>某些类</strong>合成默认构造函数。对这样的类来说，<strong>必须</strong>自定义<strong>默认构造函数</strong>，否则该类将没有可用的<strong>默认构造函数</strong></p>
</blockquote>
</li>
<li>
<p><strong>定义构造函数</strong></p>
<ul>
<li>
<p><strong>示例</strong></p>
<blockquote>
<p>1、对于我们的<code>Sales_data</code>类，我们将使用<strong>下面的参数</strong>定义 4 个不同的<strong>构造函数</strong><br>
2、一个<code>istream&amp;</code>，从中读取一条交易信息<br>
3、一个<code>const string&amp;</code>，表示 ISBN 编号；一个<code>unsigned</code>，表示图书数量；一个<code>double</code>，表示售出单价<br>
4、一个<code>const string&amp;</code>，表示 ISBN 编号，编译器将赋予其他成员默认值<br>
5、一个<strong>空参数列表</strong>(即默认构造函数)，如刚刚介绍，既然<strong>已定义其他构造函数</strong>，那么也<strong>必须</strong>定义一个<strong>默认构造函数</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 新增的构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p * n)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);   <span class="comment">// 将在类外定义</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>= default</code>的含义</p>
<blockquote>
<p>1、我们首先解释<strong>默认构造函数</strong>：<code>Sales_data() = default;</code><br>
2、首先请明确：因为该构造函数<strong>不接受任何实参</strong>，所以它是<strong>默认构造函数</strong>。我们定义它只是因为我们既需要<strong>其他形式的构造函数</strong>，又需要<strong>默认的构造函数</strong>，我们希望它的作用完全等同于<strong>合成的默认构造函数</strong><br>
3、在 C++11 中，如果我们需要<strong>默认的行为</strong>，可以通过在<strong>参数列表后</strong>写上<code>= default</code>来<strong>要求编译器生成构造函数</strong>。其中<code>= default</code>既可以和声明一起<strong>出现在类内</strong>，也可以作为定义<strong>出现在类外</strong><br>
4、和其他函数一样，如果<code>= default</code>在<strong>类内</strong>，则默认构造函数<strong>是内联的</strong>；反之则<strong>不是内联的</strong></p>
</blockquote>
</li>
<li>
<p><strong>构造函数初始值列表</strong></p>
<blockquote>
<p>1、之后的两个构造函数中，出现了<strong>新的部分</strong>，即<strong>冒号</strong>及<strong>冒号和花括号之间</strong>的代码。其中<strong>花括号</strong>定义了<strong>空的函数体</strong>，我们把<strong>新出现的部分</strong>称为<strong>构造函数初始值列表</strong><br>
2、这部分负责为<strong>新创建的对象</strong>的一个或几个<strong>数据成员</strong>赋初值。<strong>构造函数初始值</strong>是<strong>成员名字</strong>的一个列表，每个名字后紧跟<strong>括号括起来的</strong>或者<strong>在花括号内的</strong>成员初始值。不同成员初始化通过<strong>逗号分隔</strong><br>
3、例如，上例含有三个参数的<strong>构造函数</strong>分别用<strong>前两个参数</strong>初始化了成员<strong>bookNo</strong>和<strong>units_sold</strong>，而<strong>revenue</strong>的初始值则通过<code>revenue(p * n)</code>使用计算后的值作为初始值<br>
4、需要注意，这两个<strong>构造函数</strong>的<strong>函数体是空的</strong>是因为这些构造函数的<strong>唯一目的</strong>就是<strong>为成员赋值</strong>，没有其他任务需要执行</p>
</blockquote>
</li>
<li>
<p><strong>类外定义构造函数</strong></p>
<blockquote>
<p>1、我们将在<strong>类外定义</strong>以<code>istream</code>为参数的构造函数。该函数需要<strong>执行一些实际操作</strong>，所以在函数体内，调用了之前定义的<code>read</code><strong>函数</strong>给<strong>数据成员赋值</strong><br>
2、<code>Sales_data::Sales_data</code>的含义是，我们定义的是<code>Sales_data</code><strong>类的成员</strong>，其<strong>成员名</strong>是<code>Sales_data</code><br>
3、这个<strong>构造函数</strong>的<strong>初始值列表为空</strong>，但是由于执行了<strong>构造函数体</strong>，所以<strong>对象的成员</strong>依然能被初始化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data::<span class="built_in">Sales_data</span>(std::istream &amp;is)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>拷贝、赋值和析构</strong></p>
<blockquote>
<p>1、除了定义类的对象<strong>如何初始化</strong>外，类还需要控制<strong>拷贝</strong>、<strong>赋值</strong>和<strong>销毁对象时发生的行为</strong><br>
2、如果我们不<strong>主动定义</strong>这些操作，编译器将替我们<strong>合成它们</strong>。一般来说，编译器生成的版本将对对象的<strong>每个成员</strong>执行<strong>拷贝</strong>、<strong>赋值</strong>和<strong>销毁操作</strong><br>
3、我们将在 13 章介绍如何<strong>自定义上述操作</strong></p>
</blockquote>
</li>
<li>
<p><strong>完整的类与使用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 新增的构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p * n)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 把 rhs 的成员加到 this 的成员上</span></span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="comment">// 返回调用该函数的对象</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入的交易信息包括 ISBN、售出总数、售出单价</span></span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; item.revenue &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rsh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sales_data sum = lhs; <span class="comment">// 把 lhs 的数据成员拷贝给 sum</span></span><br><span class="line">    sum.<span class="built_in">combine</span>(rsh);     <span class="comment">// 把 rsh 的数据成员添加到 sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;           <span class="comment">// 返回新的 Sales_data 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(std::istream &amp;is)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sales_data total;          <span class="comment">// 保存当前求和结果的变量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(std::cin, total)) <span class="comment">// 读入第一笔交易</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sales_data trans;             <span class="comment">// 保存下一条交易数据的变量</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">read</span>(std::cin, trans)) <span class="comment">// 读入剩余的交易</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (total.<span class="built_in">isbn</span>() == trans.<span class="built_in">isbn</span>()) <span class="comment">// 检查 isbn</span></span><br><span class="line">                total.<span class="built_in">combine</span>(trans);         <span class="comment">// 更新变量 total 当前的值</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">print</span>(std::cout, total) &lt;&lt; std::endl; <span class="comment">// 输出结果</span></span><br><span class="line">                total = trans;                        <span class="comment">// 处理下一本书</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(std::cout, total) &lt;&lt; std::endl; <span class="comment">// 输出最后一条交易</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果没有输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No data?&quot;</span> &lt;&lt; std::endl; <span class="comment">// 通知用户</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="访问控制与封装"><strong>访问控制与封装</strong></h2>
<ul>
<li>
<p><strong>public 和 private</strong></p>
<blockquote>
<p>1、对目前为止，我们已经为类<strong>定义了接口</strong>，但没有任何机制<strong>强制用户使用这些接口</strong>。我们的类<strong>还没有封装</strong>，也就是说，用户可以<strong>直达</strong><code>Sales_data</code><strong>对象内部</strong>并<strong>控制它的具体细节</strong><br>
2、C++中，我们使用<strong>访问说明符</strong>来加强类的<strong>封装性</strong>，如下说明。我们可以使用这些说明符再次定义<code>Sales_data</code>类，如后示例程序<br>
3、<code>public</code><strong>说明符</strong>：定义在<code>publib</code>后的成员<strong>可以在整个程序内被访问</strong>，<code>public</code>成员<strong>定义类的接口</strong><br>
4、<code>private</code><strong>说明符</strong>：定义在<code>private</code>后的成员<strong>只可以被类的成员函数访问</strong>，不能被使用该类的代码访问，<code>private</code>部分封装了<strong>类的实现细节</strong><br>
5、通常<strong>构造函数</strong>和<strong>部分成员函数</strong>跟在<code>public</code>后，而<strong>数据成员</strong>和<strong>作为实现部分的函数</strong>跟在<code>private</code>后<br>
6、一个类可以包含<strong>任意数量</strong>的<strong>访问说明符</strong>，每个<strong>访问说明符</strong>指定了接下来的<strong>成员访问级别</strong>，其<strong>有效范围</strong>直到出现<strong>下一个访问说明符</strong>或<strong>类的结尾</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p * n)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bookNo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> units_sold ? revenue / units_sold : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">        std::string bookNo;</span><br><span class="line">        <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>class 和 struct</strong></p>
<blockquote>
<p>1、上例我们使用了<code>class</code>而非<code>struct</code><strong>定义类</strong>，这种变化只是<strong>形式上有所不同</strong>，可以<strong>任意选择</strong>。<strong>唯一区别</strong>是它们的<strong>默认访问权限不一样</strong><br>
2、类可以在它<strong>第一个访问说明符前</strong>定义成员，这种成员的<strong>访问权限</strong>依赖于<strong>类定义的方式</strong><br>
3、使用<code>struct</code>则这种成员<strong>默认是</strong><code>public</code>的，而<code>class</code>这种成员<strong>默认是</strong><code>private</code>的</p>
</blockquote>
</li>
<li>
<p><strong>友元</strong></p>
<blockquote>
<p>1、既然<code>Sales_data</code>的<strong>数据成员</strong>是<code>private</code>的，那么我们的<code>add</code>、<code>print</code>、<code>add</code>函数就<strong>无法正常编译</strong>了。这是因为这几个函数虽然<strong>是类接口的一部分</strong>，但<strong>不是类的成员</strong><br>
2、类可以允许<strong>其他类或函数</strong>访问它的<strong>非公有成员</strong>，方法是令它们成为该类的<strong>友元</strong>。对于函数，只需要增加一条<code>friend</code><strong>关键字</strong>开头的<strong>函数声明</strong>即可<br>
3、<strong>友元声明</strong>只能出现在<strong>类定义内部</strong>，但友元<strong>不是类的成员</strong>也<strong>不受访问控制的约束</strong><br>
4、<strong>友元声明</strong>仅仅指定了<strong>访问权限</strong>，而非一个通常意义上的<strong>函数声明</strong>。如果我们希望<strong>类的用户</strong>能够调用某个<strong>友元函数</strong>，就必须在<strong>友元声明外</strong>再次专门进行一次<strong>函数声明</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类的其他特性"><strong>类的其他特性</strong></h2>
<ul>
<li>
<p><strong>类成员再探</strong></p>
<ul>
<li>
<p>为了展示这些新特性，我们需要定义<strong>一对相互关联的类</strong>：<code>Screen</code>和<code>Window_mgr</code></p>
</li>
<li>
<p><strong>定义类型成员</strong></p>
<blockquote>
<p>1、假设<code>Screen</code>表示显示器中的<strong>一个窗口</strong>，该类中包含一个用于<strong>保存内容</strong>的<code>string</code>成员和分别用于表示<strong>光标位置</strong>、<strong>屏幕的高和宽</strong>的<code>string::size_type</code>成员<br>
2、除了定义<strong>数据和函数成员</strong>外，类还可以<strong>自定义某种类型</strong>在类中的<strong>别名</strong>。这种<strong>类型别名</strong>与其他成员一样存在<strong>访问限制</strong>，可以是<code>public</code>或<code>private</code>的一种<br>
3、如下我们在<code>public</code>部分定义了<code>pos</code><strong>别名</strong>，这样用户就可以使用这个名字。<code>Screen</code>的用户不应该知道该类使用<code>string</code><strong>对象</strong>来<strong>存放数据</strong>，因此通过把<code>pos</code>定义成<code>public</code>可以<strong>隐藏</strong><code>Screen</code>的<strong>实现细节</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        pos cursor = <span class="number">0</span>;</span><br><span class="line">        pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">        std::string contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Screen</code><strong>类的成员函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">        <span class="built_in">Screen</span>() = <span class="keyword">default</span>; <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="built_in">Screen</span>(pos ht, pos wd, <span class="type">char</span> c)</span><br><span class="line">            : <span class="built_in">height</span>(ht), <span class="built_in">width</span>(wd), <span class="built_in">contents</span>(ht * wd, c) <span class="comment">// 构造函数，cursor 会被类内初始值初始化为 0</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// 读取光标处的字符</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> contents[cursor]; <span class="comment">// 隐式内联</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重载成员函数 get</span></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>; <span class="comment">// 显式内联</span></span><br><span class="line">        <span class="function">Screen &amp;<span class="title">move</span><span class="params">(pos r, pos c)</span></span>;            <span class="comment">// 能在之后被设置为内联</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        pos cursor = <span class="number">0</span>;</span><br><span class="line">        pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">        std::string contents;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类内声明为 inline</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Screen::get</span><span class="params">(pos r, pos c)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = r * width;      <span class="comment">// 计算行的位置</span></span><br><span class="line">    <span class="keyword">return</span> contents[row + c]; <span class="comment">// 返回给定列的字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在定义处指定 inline</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = r * width; <span class="comment">// 计算行的位置</span></span><br><span class="line">    cursor = row + c;    <span class="comment">// 在行内将光标移动到指定列</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        <span class="comment">// 以左值形式返回对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>mutable</code><strong>可变数据成员</strong></p>
<blockquote>
<p>1、有时我们希望能<strong>修改类的某个数据成员</strong>，即使是在一个<code>const</code><strong>成员函数</strong>里，对此可以通过在<strong>变量的声明</strong>中加入<code>mutable</code><strong>关键字</strong>声明一个<strong>可变数据成员</strong><br>
2、一个<strong>可变数据成员</strong>永远不会是<code>const</code>，即使它是<code>const</code><strong>对象的成员</strong>。因此，一个<code>const</code><strong>成员函数</strong>可以改变一个可变成员的值<br>
3、例如，我们将给<code>Screen</code>添加一个<strong>access_ctr 可变成员</strong>，以跟纵成员函数被调用了多少次，如下例。尽管<code>some_member</code>是一个<code>const</code><strong>成员函数</strong>，但依然可以改变<strong>access_ctr</strong>的值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++access_ctr; <span class="comment">// 保存一个计数值，用于记录成员函数被调用的次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr; <span class="comment">// 即使在一个 const 对象内也能被修改</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类数据成员的初始值</strong></p>
<blockquote>
<p>1、定义好<code>Screen</code>后，我们将继续定义一个<strong>窗口管理类</strong>并用它来表示显示器上的<strong>一组</strong><code>Screen</code>。这个类将包含一个<code>Screen</code><strong>类型的</strong><code>vector</code>，<strong>每个元素</strong>表示一个特定的<code>Screen</code><br>
2、默认情况下，我们希望<code>Window_mgr</code>类开始时总是<strong>拥有一个默认初始化的</strong><code>Screen</code>。C++11 中，最好的办法是把这个<strong>默认值</strong>声明成一个<strong>类内初始值</strong>，由<code>Screen</code>的<strong>构造函数初始化</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 默认情况下，一个 Window_mgr 包含一个标准尺寸的空白 Screen，通过类内初始值和 Screen 的构造函数实现</span></span><br><span class="line">        std::vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>, <span class="number">80</span>, <span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>返回 *this 的成员函数</strong></p>
<ul>
<li>
<p><strong>继续改进</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 添加两个新的成员函数</span></span><br><span class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(pos, pos, <span class="type">char</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    contents[cursor] = c; <span class="comment">// 设置当前光标所在位置的新值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;         <span class="comment">// 将 this 作为左值返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(pos r, pos col, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    contents[r * width + col] = ch; <span class="comment">// 设置给定位置的新值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                   <span class="comment">// 将 this 作为左值返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>返回</strong><code>*this</code><strong>的意义</strong></p>
<blockquote>
<p>1、和<code>move</code>操作一样，<code>set</code>的<strong>返回值</strong>也是<strong>调用</strong><code>set</code><strong>对象的引用</strong>，意味着这些函数<strong>返回的是对象本身</strong>而不是<strong>对象的副本</strong><br>
2、如果我们把<strong>一系列操作</strong>连在<strong>一条表达式</strong>：<code>myScreen.move(4,0).set('#');</code>，这些操作将会<strong>在同一个对象上执行</strong><br>
3、更直观的，我们将这条<strong>语句的含义拆解</strong>，如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果返回 Screen &amp;，其等价于：</span></span><br><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回 Screen，其等价于：</span></span><br><span class="line">Screen temp = myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);     <span class="comment">// 对返回值进行拷贝</span></span><br><span class="line">temp.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);                        <span class="comment">// 不会改变 myScreen 的 contents</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>从</strong><code>const</code><strong>成员函数返回</strong><code>*this</code></p>
<blockquote>
<p>1、下面我们要添加一个<code>display</code><strong>操作</strong>，负责<strong>打印</strong><code>Screen</code><strong>的内容</strong>。我们希望这个函数能和<code>move</code>、<code>set</code><strong>出现在同一序列</strong>，因此该函数也应该<strong>返回它的对象的引用</strong><br>
2、从逻辑上说，<strong>显示</strong>并不需要<strong>改变对象内容</strong>，因此我们令<code>display</code>是一个<code>const</code>成员。此时<code>this</code>将是一个<strong>指向</strong><code>const</code><strong>的指针</strong>，而<code>*this</code>就是<code>const</code><strong>对象</strong><br>
3、由此推断，<code>display</code>的<strong>返回类型</strong>是<code>const Screen&amp;</code>。然而，如果真的<strong>返回一个</strong><code>const</code><strong>的引用</strong>，那我们就<strong>不能</strong>将其<strong>嵌入到一组动作的序列</strong>里(如后示例)<br>
4、即使<strong>myScreen</strong>是个<strong>非常量对象</strong>，对<code>set</code>的调用也<strong>不能通过编译</strong>。问题在于<code>display</code>的<code>const</code>版本返回了<strong>常量引用</strong>，我们无权<code>set</code>一个<strong>常量对象</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Screen myScreen;</span><br><span class="line"><span class="comment">// 如果 display 返回常量引用，set 将无权更改常量对象的数据，因而报错</span></span><br><span class="line">myScreen.<span class="built_in">display</span>(cout).<span class="built_in">set</span>(<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>基于</strong><code>const</code><strong>的重载</strong></p>
<blockquote>
<p>1、通过区分<strong>成员函数</strong>是否是<code>const</code>的，我们可以对其<strong>进行重载</strong>，其原因主要如下<br>
2、首先，<strong>非常量版本</strong>的函数对于<strong>常量对象</strong>是不可用的，所以我们只能在<strong>常量对象</strong>上调用<code>const</code><strong>成员函数</strong>。其次，虽然可以在<strong>非常量对象</strong>上使用<strong>常量版本</strong>的函数，但显然此时<strong>非常量版本</strong>是一个<strong>更好的匹配</strong><br>
3、如下例，我们将声明一个<code>do_display</code><strong>私有成员</strong>，用于负责打印。<strong>所有的</strong><code>display</code><strong>操作</strong>都将<strong>调用这个函数</strong>，然后<strong>返回自己的类型的对象</strong><br>
4、当<code>do_display</code>执行完成后，这<strong>非常量版本</strong>的<code>display</code>函数<strong>返回普通引用</strong>，而<strong>常量版本</strong>的<code>display</code>函数<strong>返回常量引用</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 普通版本 display</span></span><br><span class="line">        <span class="function">Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">do_display</span>(os);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// const 版本 display</span></span><br><span class="line">        <span class="function"><span class="type">const</span> Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">do_display</span>(os);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os &lt;&lt; contents;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>完整的 Screen 类</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Screen</span>() = <span class="keyword">default</span>; <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="built_in">Screen</span>(pos ht, pos wd, <span class="type">char</span> c)</span><br><span class="line">            : <span class="built_in">height</span>(ht), <span class="built_in">width</span>(wd), <span class="built_in">contents</span>(ht * wd, c) <span class="comment">// 构造函数，cursor 会被类内初始值初始化为 0</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// 读取光标处的字符</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> contents[cursor]; <span class="comment">// 隐式内联</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>; <span class="comment">// 显式内联</span></span><br><span class="line">        <span class="function">Screen &amp;<span class="title">move</span><span class="params">(pos r, pos c)</span></span>;            <span class="comment">// 能在之后被设置为内联</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ++access_ctr; <span class="comment">// 保存一个计数值，用于记录成员函数被调用的次数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(pos, pos, <span class="type">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通版本 display</span></span><br><span class="line">        <span class="function">Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">do_display</span>(os);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// const 版本 display</span></span><br><span class="line">        <span class="function"><span class="type">const</span> Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">do_display</span>(os);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr; <span class="comment">// 即使在一个 const 对象内也能被修改</span></span><br><span class="line">        pos cursor = <span class="number">0</span>;</span><br><span class="line">        pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">        std::string contents;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os &lt;&lt; contents;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类内声明为 inline</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Screen::get</span><span class="params">(pos r, pos c)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = r * width;      <span class="comment">// 计算行的位置</span></span><br><span class="line">    <span class="keyword">return</span> contents[row + c]; <span class="comment">// 返回给定列的字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在定义处指定 inline</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = r * width; <span class="comment">// 计算行的位置</span></span><br><span class="line">    cursor = row + c;    <span class="comment">// 在行内将光标移动到指定列</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        <span class="comment">// 以左值形式返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    contents[cursor] = c; <span class="comment">// 设置当前光标所在位置的新值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;         <span class="comment">// 将 this 作为左值返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(pos r, pos col, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    contents[r * width + col] = ch; <span class="comment">// 设置给定位置的新值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                   <span class="comment">// 将 this 作为左值返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>友元再探</strong></p>
<ul>
<li>
<p>先前我们的<code>Sales_data</code>类把三个普通的<strong>非成员函数</strong>定义成了<strong>友元</strong>，类还可以把<strong>其他的类</strong>定义成<strong>友元</strong>，还可以把<strong>其他类的成员函数</strong>定义成<strong>友元</strong></p>
</li>
<li>
<p><strong>类之间的友元关系</strong></p>
<blockquote>
<p>1、假设我们的<code>Window_mgr</code>类的<strong>某些成员</strong>可能需要访问它管理的<code>Screen</code>类的<strong>内部数据</strong>。例如我们需要为<code>Window_mgr</code>添加一个<strong>clear 成员</strong>，用于把指定的<code>Screen</code><strong>内容设为空白</strong><br>
2、此时<strong>clear</strong>需要访问<code>Screen</code>的<strong>私有成员</strong>，而要使这种<strong>访问合法</strong>，<code>Screen</code>需要把<code>Window_mgr</code>指定成它的<strong>友元</strong><br>
3、如果一个类指定了<strong>友元类</strong>，则<strong>友元类</strong>的<strong>成员函数</strong>可以访问此类包括<strong>私有成员在内</strong>的<strong>所有成员</strong><br>
4、需要注意的是，<strong>友元关系不存在传递性</strong>。即如果<code>Window_mgr</code>有它自己的友元，这些友元<strong>不能理所当然地访问</strong><code>Screen</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;</span><br><span class="line">    <span class="comment">// 此处省略先前的类对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 窗口中每个屏幕的编号</span></span><br><span class="line">        <span class="keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;</span><br><span class="line">        <span class="comment">// 按照编号将指定的 Screen 重置为空白</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(ScreenIndex i)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// s 是一个 Screen 的引用，指向我们想清空的屏幕</span></span><br><span class="line">            Screen &amp;s = screens[i];</span><br><span class="line">            s.contents = std::<span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>, <span class="number">80</span>, <span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>令函数成员作为友元</strong></p>
<blockquote>
<p>1、除了令<strong>整个类</strong>作为<strong>友元</strong>外，还可以<strong>只为 clear 提供访问权限</strong>。当把一个成员<strong>函数声明</strong>称友元时，必须<strong>明确指出</strong>成员函数<strong>属于哪个类</strong><br>
2、但要想令某个<strong>成员函数</strong>作为<strong>友元</strong>，必须要按照如下方式设计程序：<br>
3、首先定义<code>Window_mgr</code>类，其中声明<strong>clear</strong>函数，但<strong>不能定义</strong>它。在<strong>clear</strong>使用<code>Screen</code>成员之前必须<strong>先声明</strong><code>Screen</code>；接下来定义<code>Screen</code>，包含对于<strong>clear</strong>的友元声明；最后定义<strong>clear</strong>，此时它才可以使用<code>Screen</code>成员</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>友元函数重载和作用域</strong></p>
<blockquote>
<p>1、尽管<strong>重载函数</strong>的名字相同，但它们仍是<strong>不同的函数</strong>。因此如果一个类想把<strong>一组重载函数声明</strong>成<strong>友元</strong>，则需要对每一个函数<strong>分别声明</strong><br>
2、<strong>类</strong>和<strong>非成员函数</strong>的<strong>声明</strong>不是必须在它们的<strong>友元声明之前</strong>，当一个名字<strong>第一个出现</strong>在一个<strong>友元声明</strong>中，我们<strong>隐式假定该名字在当前作用域中可见</strong>，然而友元本身不一定真的声明在当前作用域。甚至就算在<strong>类内定义该函数</strong>，我们也必须在<strong>类外提供相应的声明</strong>，从而使得<strong>函数可见</strong><br>
3、重点在于理解<strong>友元声明本身的作用</strong>是<strong>影响访问权限</strong>，而不是<strong>普通意义上的声明</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 友元函数可以定义在类内，但不是真正的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">X</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">f</span>();      <span class="comment">// 调用 f() 函数，错误：f 还没有被声明</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(); <span class="comment">// 调用 f() 函数，错误：f 还没有被声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;       <span class="comment">// 声明定义在 X 中的函数 f，从此时 f 才被真正声明可用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(); <span class="comment">// 正确：现在 f 的声明在作用域中了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="类的作用域"><strong>类的作用域</strong></h2>
<ul>
<li>
<p><strong>类的作用域</strong></p>
<ul>
<li>
<p><strong>引入</strong></p>
<blockquote>
<p>1、每个类都会定义<strong>它自己的作用域</strong>。在<strong>类的作用域外</strong>，<strong>普通数据</strong>和<strong>函数成员</strong>只能由对象、引用、指针使用<strong>成员访问运算符</strong>来访问；对于<strong>类类型成员</strong>则使用<strong>作用域运算符</strong>来访问<br>
2、不论哪种情况，跟在<strong>运算符后的名字</strong>都必须是<strong>对应类的成员</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Screen::pos ht = <span class="number">24</span>, wd = <span class="number">80</span>;   <span class="comment">// 使用 Screen 定义的 pos 类型</span></span><br><span class="line"><span class="function">Screen <span class="title">scr</span><span class="params">(ht, wd, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">Screen *p = &amp;scr;</span><br><span class="line"><span class="type">char</span> c = scr.<span class="built_in">get</span>();             <span class="comment">// 访问 scr 对象的 get 成员</span></span><br><span class="line">c = p -&gt; <span class="built_in">get</span>();                 <span class="comment">// 访问 p 所指向的 scr 的 get 成员</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>作用域和定义在类外的成员</strong></p>
<blockquote>
<p>1、一个<strong>类</strong>就是一个<strong>作用域</strong>很好的说明了为什么我们在<strong>类外定义成员函数</strong>时需要提供<code>类名::函数名</code>。在类外，<strong>成员的名字被隐藏了</strong><br>
2、一旦遇到了<strong>类名</strong>，定义的<strong>剩余部分</strong>就在<strong>类的作用域内</strong>了，这里的剩余部分包括<strong>参数列表</strong>和<strong>函数体</strong>，因而我们可以<strong>直接使用类的其他成员</strong>而无须再次授权<br>
3、<code>Window_mgr</code>类的<strong>clear 成员</strong>用到了<strong>该类中定义的</strong><code>ScreenIndex</code><strong>类型</strong>：<code>void Window_mgr::clear(ScreenIndex i);</code>。这里使用<code>ScreenIndex</code>时已经在<strong>该类的作用域下</strong>(因为在<code>Window_mgr::</code>后)，所以<strong>不需要额外说明</strong><br>
4、有时由于<strong>返回类型</strong>出现在<strong>类名前</strong>，此时想要使用<code>ScreenIndex</code>作为<strong>返回类型</strong>，必须明确<strong>指定哪个类定义了它</strong>，如下</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用域::返回类型 类名::函数名(形参列表)</span></span><br><span class="line"><span class="function">window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>名字查找与类作用域</strong></p>
<ul>
<li>
<p><strong>用于类成员声明的名字查找</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line">std::string bal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Money <span class="title">balance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1、<strong>编译器</strong>看到<code>balance</code>函数的声明语句时，将先在<code>Account</code><strong>类内查找 Money 的声明</strong>，没找到就到<strong>类外的作用域</strong>去查找，找到<strong>Money</strong>的<code>typedef</code>语句<br>
2、<code>balance</code>函数体由于在<strong>整个类可见后</strong>才被处理，因此其<code>return</code>语句返回<strong>名为 bal 的成员</strong>而不是外层的<code>string</code>对象</p>
</blockquote>
</li>
<li>
<p><strong>类型名要特殊处理</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Money <span class="title">balance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bal;             <span class="comment">// 已经使用了外层作用域的 Money</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">double</span> Money;       <span class="comment">// 错误：不能重新定义 Money</span></span><br><span class="line">        Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1、一般来说，<strong>内层作用域</strong>可以重新定义<strong>外层作用域</strong>的名字，即使该名字已经在<strong>内层作用域</strong>中使用过<br>
2、然而<strong>在类中</strong>，如果<strong>成员使用了外层作用域中的名字</strong>，而该名字<strong>代表一种类型</strong>，则类<strong>不能在之后重新定义</strong>该名字<br>
3、尽管<strong>重新定义类型名字</strong>是一种错误的行为，但是<strong>编译器并不为此负责</strong>，一些编译器将顺利通过这样的代码</p>
</blockquote>
</li>
<li>
<p><strong>成员定义中的普通块作用域的名字查找</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> height; <span class="comment">// 定义了一个名字，稍后将在 Screen 中使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">dummy_fcn</span><span class="params">(pos height)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cursor = width * height; <span class="comment">// 使用的是函数的形参 height</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        pos cursor = <span class="number">0</span>;</span><br><span class="line">        pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1、该例中，<strong>编译器</strong>处理函数中的<strong>乘法表达式</strong>时，它首先在<strong>函数作用域</strong>内查找名字，即先查找<strong>形参列表</strong>的<strong>同名形参</strong>。因此该例使用的是<strong>形参 height</strong>而非<strong>成员 height</strong>或<strong>全局 height</strong><br>
2、如果要在这种情况下单独使用<strong>其他作用域的名字</strong>，可以使用<code>::height</code>调用<strong>全局 height</strong>，使用<code>this -&gt; height</code>或<code>Screen::height</code>调用<strong>成员 height</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="构造函数再探"><strong>构造函数再探</strong></h2>
<ul>
<li>
<p><strong>委托构造函数</strong></p>
<blockquote>
<p>1、C++11 新标准拓展了<strong>构造函数初始值</strong>的功能，使得我们可以定义所谓的<strong>委托构造函数</strong>。一个<strong>委托构造函数</strong>，使用它<strong>所属类的其他构造函数</strong>执行它自己的初始化过程<br>
2、和其他构造函数一样，一个<strong>委托构造函数</strong>也有一个<strong>成员初始值列表</strong>和一个<strong>函数体</strong>。与其他成员初始值一样，<strong>类名后面</strong>紧跟圆括号括起来的<strong>参数列表</strong>，<strong>列表必须与类中另一个构造函数匹配</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">        <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> ct, <span class="type">double</span> price) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(ct), <span class="built_in">revenue</span>(ct * price)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其余构造函数全部委托给另一个构造函数</span></span><br><span class="line">        <span class="built_in">Sales_data</span>() : <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Sales_data</span>(std::string s) : <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Sales_data</span>(std::istream &amp;is) : <span class="built_in">Sales_data</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(is, *<span class="keyword">this</span>); <span class="comment">// 之前上文类中定义过的函数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string bookNo;</span><br><span class="line">        <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>隐式类类型转换</strong></p>
<ul>
<li>
<p><strong>介绍</strong></p>
<blockquote>
<p>1、在类中，如果<strong>构造函数</strong>只接受<strong>一个实参</strong>，则它实际上定义了<strong>转换为此类类型</strong>的<strong>隐式转换机制</strong>，有时我们把这种构造函数称为<strong>转换构造函数</strong><br>
2、在先前的<code>Sales_data</code>类中，接受<code>string</code>的和接受<code>istream</code>的<strong>构造函数</strong>分别定义了<strong>这两种类型向</strong><code>Sales_data</code><strong>隐式转换</strong>的规则。也就是说，在需要使用<code>Sales_data</code>的地方，可以使用<code>string</code>或<code>istream</code><strong>代替</strong><br>
3、如下例，我们用一个<code>string</code><strong>实参</strong>调用了<code>combine</code><strong>成员函数</strong>。该调用合法，<strong>编译器</strong>用给定的<code>string</code>自动创建了一个<strong>临时</strong><code>Sales_data</code><strong>对象</strong>，这个新生成的<strong>临时对象</strong>被传递给了<code>combine</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;</span><br><span class="line"><span class="comment">// 构造一个临时的 Sales_data 对象，该对象的 units_sold 和 revenue 都为 0，bookNo 等于 null_book</span></span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>只允许一步类类型转换</strong></p>
<blockquote>
<p>1、<strong>编译器</strong>只会自动地<strong>执行一步类型转换</strong>，因此下面代码隐式使用了<strong>两种转换规则</strong>是错误的<br>
2、如果我们想完成上述调用，可以主动进行一步<strong>显式转换</strong>，如后例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误：需要用户定义的两种转换，但编译器只转换一次</span></span><br><span class="line"><span class="comment">// 1 把 字符串字面量 转换成 string</span></span><br><span class="line"><span class="comment">// 2 把 string 转换成 Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;9-999-99999-9&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：显式转换成 string，隐式转换成 Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));</span><br><span class="line"><span class="comment">// 正确：隐式转换成 string，显式转换成 Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>explicit</code><strong>抑制构造函数隐式转换</strong></p>
<blockquote>
<p>1、我们可以通过将只有一个实参的<strong>构造函数</strong>声明为<code>explicit</code>来<strong>阻止隐式转换</strong>(多个实参的构造函数不能用于执行隐式转换，所以无须指定)，此时将<strong>不能通过</strong>指定了<code>explicit</code>的<strong>构造函数</strong>来<strong>隐式创建类对象</strong><br>
2、<strong>只能在类内声明构造函数时</strong>使用<code>explicit</code>，在类外定义时不应重复<br>
3、<code>explicit</code><strong>构造函数</strong>只能用于<strong>直接初始化</strong>，当我们执行<strong>拷贝初始化</strong>(<code>=</code>)不能使用<code>explicit</code>构造函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span>: bookNo(s)</span></span><br><span class="line"><span class="function">        &#123;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 错误：类外定义时不要重复使用 explicit</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data::Sales_data</span><span class="params">(std::istream &amp;is)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误：不能使用拷贝初始化</span></span><br><span class="line">Sales_data item = null_book;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>聚合类</strong></p>
<blockquote>
<p>1、<strong>聚合类</strong>使得用户可以<strong>直接访问其成员</strong>，当一个类满足<strong>如下条件</strong>时，我们说它是<strong>聚合</strong>的：<br>
2、<strong>所有成员</strong>都是<code>public</code>的；没有定义任何<strong>构造函数</strong>；没有<strong>类内初始值</strong>；没有<strong>基类</strong>，也没有<code>virtual</code><strong>函数</strong>(这部分后续介绍)<br>
3、我们可以提供一个<strong>花括号括起来</strong>的<strong>成员初始值列表</strong>来初始化聚合类的<strong>数据成员</strong>，顺序必须与声明的顺序一致</p>
</blockquote>
</li>
<li>
<p><strong>字面值常量类</strong></p>
<ul>
<li>
<p><strong>介绍</strong></p>
<blockquote>
<p>1、之前我们提到过<code>constexpr</code><strong>函数</strong>的<strong>参数</strong>和<strong>返回值</strong>都必须是<strong>字面值类型</strong>。除了算术类型、引用、指针外，<strong>某些类也是字面值类型</strong><br>
2、和其他类不同，这样的类可能含有<code>constexpr</code><strong>构造函数</strong>，这样的成员必须<strong>符合</strong><code>constexpr</code><strong>函数的所有要求</strong>，它们是<strong>隐式</strong><code>const</code>的<br>
3、<strong>数据成员都是字面值类型</strong>的<strong>聚合类</strong>都是<strong>字面值常量类</strong>，此外，如果一个类满足<strong>以下要求</strong>，也是一个<strong>字面值常量类</strong>：<br>
4、<strong>数据成员</strong>都必须是<strong>字面值类型</strong>；类必须包含<strong>至少一个</strong><code>constexpr</code><strong>函数</strong>；数据成员的<strong>类内初始值</strong>必须是<strong>常量表达式</strong>，如果成员属于某种类类型，<strong>初始值</strong>必须使用成员自己的<code>constexpr</code><strong>构造函数</strong>；类必须使用<strong>析构函数</strong>的<strong>默认定义</strong>，该成员负责销毁类的对象</p>
</blockquote>
</li>
<li>
<p><code>constexpr</code><strong>构造函数</strong></p>
<blockquote>
<p>1、<code>constexpr</code><strong>构造函数</strong>可以声明成<code>=default</code>。否则，该函数就必须既满足<strong>构造函数的要求</strong>(不包含返回语句)，又满足<code>constexpr</code><strong>函数的要求</strong>(唯一可执行的语句就是返回语句)<br>
2、综合这两点，<code>constexpr</code><strong>构造函数体</strong>一般来说是<strong>空的</strong><br>
3、<code>constexpr</code><strong>构造函数</strong>必须<strong>初始化所有数据成员</strong>，<strong>初始值</strong>要么使用<code>constexpr</code><strong>构造函数</strong>，要么是<strong>一条常量表达式</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b = <span class="literal">true</span>)</span> : hw(b), io(b), other(b)</span></span><br><span class="line"><span class="function">        &#123;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> h, <span class="type">bool</span> i, <span class="type">bool</span> o)</span> : hw(h), io(i), other(o)</span></span><br><span class="line"><span class="function">        &#123;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">any</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hw || io || other;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">bool</span> hw;</span><br><span class="line">        <span class="type">bool</span> io;</span><br><span class="line">        <span class="type">bool</span> other;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="类的静态成员"><strong>类的静态成员</strong></h2>
<ul>
<li>
<p><strong>引入</strong></p>
<blockquote>
<p>1、有的时候类需要它的<strong>一些成员</strong>与<strong>类本身</strong>直接相关，而不是与类的<strong>各个对象</strong>保持关联<br>
2、例如，一个<strong>银行账户类</strong>可能需要一个<strong>数据成员</strong>来表示当前的<strong>基准利率</strong>，我们希望<strong>利率与类关联</strong>，没必要<strong>每个对象</strong>都<strong>存储利率信息</strong><br>
3、一旦利率浮动，我们希望<strong>所有的对象</strong>都能<strong>使用新值</strong></p>
</blockquote>
</li>
<li>
<p><strong>声明静态成员</strong></p>
<blockquote>
<p>1、我们通过在<strong>成员的声明前</strong>加上关键字<code>static</code>使其<strong>与类关联在一起</strong>。下例为我们模拟实现的银行账户类<br>
2、<strong>静态成员</strong>存在于任何对象之外，对象中<strong>不包含</strong>任何<strong>与数据成员有关</strong>的数据<br>
3、<strong>静态成员函数</strong>也<strong>不与任何对象绑定</strong>在一起，它们<strong>不包含</strong><code>this</code><strong>指针</strong>，且静态成员函数<strong>不能声明成</strong><code>const</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            amount += amount * interesRate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> interesRate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string owner;</span><br><span class="line">        <span class="type">double</span> amount;</span><br><span class="line">        <span class="type">static</span> <span class="type">double</span> interesRate;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用静态成员</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用作用域运算符直接访问静态成员</span></span><br><span class="line"><span class="type">double</span> r;</span><br><span class="line">r = Account::<span class="built_in">rate</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类的对象、引用或指针来访问静态成员</span></span><br><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line">r = ac1.<span class="built_in">rate</span>();</span><br><span class="line">r = ac2 -&gt; <span class="built_in">rate</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数不通过作用域运算符就能直接使用静态成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ammout += amount * interestRate;    <span class="comment">// 直接使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>定义静态成员</strong></p>
<blockquote>
<p>1、和其他<strong>成员函数</strong>一样，我们在<strong>类内和类外</strong>都可以定义<strong>静态成员函数</strong>。当在<strong>类外定义时</strong>，不要重复<code>static</code>关键字<br>
2、因为<strong>静态数据成员</strong>不属于类的任何一个对象，所以它们并不是在<strong>创建类的时候</strong>被定义的，这意味着它们<strong>不是由构造函数初始化的</strong><br>
3、我们<strong>不能在类内初始化静态成员</strong>，相反，我们必须<strong>在类外定义和初始化</strong>每个静态成员</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类外定义静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Account::rate</span><span class="params">(<span class="type">double</span> newRate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    interestRate = newRate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并初始化一个静态成员</span></span><br><span class="line"><span class="type">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>静态成员的类内初始化</strong></p>
<blockquote>
<p>1、通常情况下，类的<strong>静态成员</strong>不应该在类内初始化<br>
2、然而，我们可以为<strong>静态成员</strong>提供<code>const</code><strong>整型</strong>的<strong>类内初始值</strong>，不过要求<strong>静态成员</strong>必须是<strong>字面值常量类型</strong>的<code>constexpr</code><br>
3、如果在<strong>类内提供了一个初始值</strong>，则静态成员的定义<strong>不能再指定一个初始值</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> interestRate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>; <span class="comment">// period 是常量表达式</span></span><br><span class="line">        <span class="type">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>静态成员与普通成员的区别</strong></p>
<blockquote>
<p>1、<strong>静态成员</strong>能用于<strong>某些场景</strong>，而<strong>普通成员不能</strong>。静态成员<strong>独立于任何对象</strong>，因此，在某些<strong>普通成员可能非法</strong>的场合，<strong>静态成员</strong>可以<strong>正常使用</strong>。比如<strong>静态数据成员</strong>可以是<strong>不完全类型</strong>(后续介绍)<br>
2、特别的，<strong>静态数据成员的类型</strong>可以是它<strong>所属的类类型</strong>，而<strong>普通成员</strong>只能声明成它<strong>所属类的指针或引用</strong><br>
3、此外，我们可以使用<strong>静态成员</strong>作为<strong>默认实参</strong>，而<strong>普通成员不能</strong>，这是因为<strong>普通成员的值</strong>本身<strong>属于对象的一部分</strong></p>
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.shengqibaozao.eu.org">圣奇保枣</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.shengqibaozao.eu.org">https://www.shengqibaozao.eu.org</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">https://www.shengqibaozao.eu.org</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPP/">CPP</a><a class="post-meta__tags" href="/tags/syntax/">syntax</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/course/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/41.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构</div></div></a></div><div class="next-post pull-right"><a href="/course/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8B%EF%BC%89/" title="离散数学(下)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">离散数学(下)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/algorithm/xwysyy%20Algorithm/" title="xwysyy Algorithm"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/38.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="title">xwysyy Algorithm</div></div></a></div><div><a href="/tutorial/Codeforces/" title="Codeforces"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-11</div><div class="title">Codeforces</div></div></a></div><div><a href="/syntax/CPP/multiset(cf-1862-round894-g)/" title="multiset(cf-1862-round894-g)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/44.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="title">multiset(cf-1862-round894-g)</div></div></a></div><div><a href="/syntax/CPP/C++%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="C++ Lambda表达式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-19</div><div class="title">C++ Lambda表达式</div></div></a></div><div><a href="/syntax/Git/" title="Git"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-02</div><div class="title">Git</div></div></a></div><div><a href="/syntax/CSS%E7%AC%94%E8%AE%B0/" title="CSS笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="title">CSS笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="cols"><div class="col"><div class="container"><div class="front avatarPanel"><div class="inner"><div class="player-title">Attributes</div><div class="player-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></div></div><div class="back attributesPanel"><div class="inner"><div class="player-lv">LV.3</div><div class="player-name">善良的xwysyy</div><div class="attributes-value"><div class="attributes-value-item"><a href="/archives/"><div class="attributes">文章</div><div class="value-bar"><div class="value-bar-fill" style="width:24.00%"><div class="value-bar-fill-in" style="background: rgba(89, 230, 54,0.6)"></div></div></div><span>24/100</span></a></div><div class="attributes-value-item"><a href="/tags/"><div class="attributes">标签</div><div class="value-bar"><div class="value-bar-fill" style="width:17.00%"><div class="value-bar-fill-in" style="background: rgba(224, 20, 20, 0.6)"></div></div></div><span>17/100</span></a></div><div class="attributes-value-item"><a href="/categories/"><div class="attributes">分类</div><div class="value-bar"><div class="value-bar-fill" style="width:7.00%"><div class="value-bar-fill-in" style="background: rgba(30, 97, 226, 0.6)"></div></div></div><span>7/100</span></a></div></div></div></div></div></div><div class="col"><div class="container"><div class="front descriptionPanel"><div class="inner"><div class="player_description"><p>一念净心 花开遍世界<br>每临绝境 峰回路又转<br>但凭净信 自在出乾坤<br>恰似如梦初醒 归途在眼前</p></div><div class="play-bottom"></div></div></div><div class="back buttonPanel"><div class="inner"><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xwysyy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xwysyy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_73844376" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:xwysyy@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><div class="play-bottom"></div></div></div></div></div></div></div><div class="card-widget card-announcement"><div id="welcome-info"></div><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>welcome</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">开始</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-C-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">编写一个简单的 C++程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.</span> <span class="toc-text">初识输入输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-C-%E7%89%88%E6%9C%AC%E7%9A%84-C-%E6%A0%87%E5%87%86%E5%BA%93%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">使用 C++版本的 C 标准库头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.</span> <span class="toc-text">类简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">基本内置类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">复合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">const 限定符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">处理类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.</span> <span class="toc-text">自定义数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">字符串、向量和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84-using-%E5%A3%B0%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">命名空间的 using 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-string"><span class="toc-number">3.2.</span> <span class="toc-text">标准库类型 string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-vector"><span class="toc-number">3.3.</span> <span class="toc-text">标准库类型 vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.</span> <span class="toc-text">迭代器介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.5.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E8%A1%A5%E5%85%85"><span class="toc-number">4.1.</span> <span class="toc-text">特性补充</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#try-%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">try 语句块和异常处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">含有可变形参的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">6.2.</span> <span class="toc-text">函数的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">6.3.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">特殊用途语言特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">定义抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">7.2.</span> <span class="toc-text">访问控制与封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">7.3.</span> <span class="toc-text">类的其他特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">7.4.</span> <span class="toc-text">类的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2"><span class="toc-number">7.5.</span> <span class="toc-text">构造函数再探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">7.6.</span> <span class="toc-text">类的静态成员</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 善良的xwysyy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="refresh-cache" type="button" title="刷新缓存" onclick="refreshCache()"><i class="fas fa-refresh"></i></button><button type="button" title="切换背景" onclick="toggleWinbox()"><i class="fas fa-display"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="/js/cursor.js" async></script><script src="/js/jquery.js"></script><script src="/js/foot.js"></script><script defer src="/live2d-widget-master/autoload.js"></script><script async data-pjax src="/js/txmap.js"></script><script async data-pjax src="/js/bb.js"></script><script async data-pjax src="/js/waterfall.js"></script><script src="/js/background.js"></script><script data-pjax>obcboPic()</script><script src="/js/weather.js"></script><script src="http://fw.qq.com/ipaddress"></script><script src="/js/visitor.js"></script><script src="/js/weibo.js"></script><script src="/js/rightside_button1.js"></script><script src="/js/rightside_button2.js"></script><div id="fps"></div><script async data-pjax src="/js/music1.js"></script><script async data-pjax src="/js/music2.js"></script><script async src="/js/music3.js"></script><script src="/js/refresh.js"></script><script src="/js/console.js"></script><script src="/js/pace.js"></script><script src="/js/welcome.js"></script><canvas id="universe"></canvas><script src="/js/universe.js"></script><script src="/js/nav.js"></script><script src="/js/sun_moon.js" async></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="cf题补了吗,ddl赶了吗,考试复习了吗,看完赶紧去学习,上课别看了" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="/css/aplayer.css" media="print" onload="this.media='all'"><script src="/js/aplayer.js"></script><script src="/js/meting.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()"> </div><meting-js id="8265539094" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="contact-info"><div class="option"><i class="fas fa-warning"> </i><div class="bloktop"></div><div class="text"><div class="strip"></div><div class="aside_notice"><h1>警钟长鸣</h1><br>严禁将重要信息（如：key、token、cookie）、标识性信息、隐私性信息上传 <center><h3>遵守网络法规</h3><h3>保护信息安全</h3><h3>尊重个人意愿</h3><h3>警惕隐私泄露</h3><h2>铭记：</h2><h3>源代码面前无秘密</h3><h3>网络流量面前无秘密</h3></center></div></div></div><div class="option"><i class="fas fa-cube"></i><div class="blok"></div><div class="text"><div class="strip"></div><div class="post-reward"><div class="reward-button"><i class="fa-solid fa-bolt"></i></div><div class="reward-main">
<ul class="reward-all">
<li class="reward-item"><a href="https://Li-j-z.github.io" target="_blank">
<img class="post-qr-code-img entered loaded" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64181ed4a682492fccdf27fa.jpg" alt="Li-j-z的魔方小站"></a>
<div class="post-qr-code-desc">Li-j-z的魔方小站</div></li>
<li class="reward-item"><a href="https://www.cnblogs.com/xwysyy/" target="_blank">
<img class="post-qr-code-img entered loaded" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6432d8ed0d2dde5777c73749.png" alt="xwysyy博客园"></a>
<div class="post-qr-code-desc">xwysyy博客园</div></li>
</ul></div></div></div></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.7.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a><a class="github-badge" target="_blank" href="https://cloud.tencent.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路部署于腾讯云" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-%E8%85%BE%E8%AE%AF%E4%BA%91-pink?style=flat&amp;logo=tencentqq" alt=""/></a><a class="github-badge" target="_blank" href="https://www.xwysyy.cn/" style="margin-inline:5px" data-title="rating" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/dynamic/json?logo=codeforces&amp;label=Codeforces&amp;url=https://codeforces-api.xwysyy.cn/api/codeforces/kmsgk&amp;query=%24.rating&amp;prefix=rating%20&amp;cacheSeconds=86400" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/" style="margin-inline:5px" data-title="萌ICP备20232640号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20232640-fe1384?style-flat&amp;logo=data:image/png;base64,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" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" style="margin-inline:5px" data-title="本网站由又拍云提供CDN加速/云存储服务" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-%E5%8F%88%E6%8B%8D%E4%BA%91-00b6ff?style=flat&amp;logo=data:image/png;base64,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" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" style="margin-inline:5px" data-title="冀ICP备2023010011号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E5%86%80ICP%E5%A4%87-2023010011%E5%8F%B7-e1d492?style=flat&amp;logo=data:image/png;base64,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" alt=""/></a><a class="github-badge" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13060602001624" style="margin-inline:5px" data-title="冀公网安备 13060602001624号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E5%86%80%E5%85%AC%E7%BD%91%E5%AE%89%E5%A4%87-13060602001624%E5%8F%B7-e1d492?style=flat&amp;logo=data:image/png;base64,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" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;tutorial/Codeforces/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;tutorial/Codeforces/&quot;);" href="javascript:void(0);" alt="">Codeforces</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;tutorial/Codeforces/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;algorithm/xwysyy Algorithm/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/38.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;algorithm/xwysyy Algorithm/&quot;);" href="javascript:void(0);" alt="">xwysyy Algorithm</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;algorithm/xwysyy Algorithm/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;syntax/LaTeX/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/14.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;syntax/LaTeX/&quot;);" href="javascript:void(0);" alt="">LaTeX</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;syntax/LaTeX/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:24%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/note/&quot;);" href="javascript:void(0);">note</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/course/&quot;);" href="javascript:void(0);">course</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/algorithm/&quot;);" href="javascript:void(0);">algorithm</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/project/&quot;);" href="javascript:void(0);">project</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/syntax/&quot;);" href="javascript:void(0);">syntax</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/tutorial/&quot;);" href="javascript:void(0);">tutorial</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CPP/&quot;);" href="javascript:void(0);">CPP</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax src="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.xwysyy.cn/api?xwysyy",['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620'],'xwysyy')
    }
  </script><!-- hexo injector body_end end --></body></html>