<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Python | 善良的xwysyy</title><meta name="author" content="善良的xwysyy"><meta name="copyright" content="善良的xwysyy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Python 起源 1. Python 简史  Python 创始人 Python 理念 Python 名字由来 Python 之禅   1.1 Python 创始人 Python 的创始人为吉多·范罗苏姆（Guido van Rossum），1989年开始编写，并在1991年正式发布Python编译器。 1.2 Python 的理念 Guido 在工作中负责 ABC 语言的开发，ABC语言是">
<meta property="og:type" content="article">
<meta property="og:title" content="Python">
<meta property="og:url" content="https://vercel.xwysyy.cn/syntax/Python/index.html">
<meta property="og:site_name" content="善良的xwysyy">
<meta property="og:description" content="一、Python 起源 1. Python 简史  Python 创始人 Python 理念 Python 名字由来 Python 之禅   1.1 Python 创始人 Python 的创始人为吉多·范罗苏姆（Guido van Rossum），1989年开始编写，并在1991年正式发布Python编译器。 1.2 Python 的理念 Guido 在工作中负责 ABC 语言的开发，ABC语言是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vercel.xwysyy.cn/image/img-background/30.jpg">
<meta property="article:published_time" content="2023-04-21T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-24T10:07:11.552Z">
<meta property="article:author" content="善良的xwysyy">
<meta property="article:tag" content="syntax">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vercel.xwysyy.cn/image/img-background/30.jpg"><link rel="shortcut icon" href="/img/%E5%A4%B4%E5%83%8F.png"><link rel="canonical" href="https://vercel.xwysyy.cn/syntax/Python/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":20,"languages":{"author":"作者: 善良的xwysyy","link":"链接: ","source":"来源: 善良的xwysyy","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-24 18:07:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="/js/echarts.min.js"></script><link rel="stylesheet" type="text/css" href="/css/asidefloat.css"><link rel="stylesheet" type="text/css" href="/css/mystyle.css"><link rel="stylesheet" type="text/css" href="/css/console.css"><link rel="stylesheet" type="text/css" href="/css/double_row.css"><link rel="stylesheet" href="/css/essay_page.css"><link rel="stylesheet" href="/css/todolist.css"><link rel="stylesheet" href="/css/guanyv.css"><link rel="stylesheet" href="/css/weibo.css"><style id="settingStyle"></style><style id="yjjs"></style><style id="themeColor"></style><link rel="stylesheet" type="text/css" href="css/_custom/heoMainColor.css"><link rel="stylesheet" type="text/css" href="css/_custom/categoryBar.css"><script async src="/js/categoryBar.js"></script><link rel="stylesheet" type="text/css" href="css/404.css"><script type="text/javascript" src="js/jquery.min.js"></script><link rel="stylesheet" href="/css/records.css"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3FeErm4Qj3nJOxIa",ck:"3FeErm4Qj3nJOxIa"})</script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="/css/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/log/"><i class="fa-fw fas fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://uptime-kuma.xwysyy.cn/status/monitor"><i class="fa-fw fas fa-shield-alt"></i><span> 监控</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-file-alt"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-chart-area"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li><li><a class="site-page child" href="/ToDoList/"><i class="fa-fw fas fa-bell"></i><span> 待办</span></a></li><li><a class="site-page child" href="/records/"><i class="fa-fw fas fa-comments"></i><span> 文字瞬间</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page child" href="/friends/"><i class="fa-fw fas fa-user-friends"></i><span> 鱼塘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Fireworks"><i class="fa-fw fa fa-fire"></i><span> 烟花</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/reference"><i class="fa-fw fa fa-code"></i><span> 参考</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about-chat/"><i class="fa-fw fas fa-comment"></i><span> 交互版</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-envelope"></i><span> 静态版</span></a></li><li><a class="site-page child" href="/essay/"><i class="fa-fw fas fa-edit"></i><span> 杂谈</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><div id="console"><div class="close-btn" onclick="heo.hideConsole()" href="javascript:void(0);"><i class="fas fa-circle-xmark"></i></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="heo.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最近评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="heo.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><span class="author-content-item-title">寻找感兴趣的领域</span></div><div class="card-tag-cloud"><a href="/tags/CPP/" style="font-size: 1em; color: #d3d3d3">CPP</a> <a href="/tags/CSS/" style="font-size: 1em; color: #d3d3d3">CSS</a> <a href="/tags/ChatGPT/" style="font-size: 1em; color: #d3d3d3">ChatGPT</a> <a href="/tags/Git/" style="font-size: 1em; color: #d3d3d3">Git</a> <a href="/tags/HTML/" style="font-size: 1em; color: #d3d3d3">HTML</a> <a href="/tags/JavaScript/" style="font-size: 1em; color: #d3d3d3">JavaScript</a> <a href="/tags/LaTeX/" style="font-size: 1em; color: #d3d3d3">LaTeX</a> <a href="/tags/MySQL/" style="font-size: 1em; color: #d3d3d3">MySQL</a> <a href="/tags/Python/" style="font-size: 1em; color: #d3d3d3">Python</a> <a href="/tags/Sublime-Text/" style="font-size: 1em; color: #d3d3d3">Sublime Text</a> <a href="/tags/Typora/" style="font-size: 1em; color: #d3d3d3">Typora</a> <a href="/tags/ai/" style="font-size: 1em; color: #d3d3d3">ai</a> <a href="/tags/algorithm/" style="font-size: 1em; color: #d3d3d3">algorithm</a> <a href="/tags/course/" style="font-size: 1em; color: #d3d3d3">course</a> <a href="/tags/project/" style="font-size: 1em; color: #d3d3d3">project</a> <a href="/tags/syntax/" style="font-size: 1em; color: #d3d3d3">syntax</a> <a href="/tags/tutorial/" style="font-size: 1em; color: #d3d3d3">tutorial</a></div></div><div class="console-card history" onclick="heo.hideConsole()"> </div></div></div><div class="button-group"><div class="console-btn-item"> <a class="darkmode_switchbutton" onclick="rm.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="fas fa-moon" style="font-size: 1rem;"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="heo.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="fas fa-arrows-alt-h"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="heo.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="fas fa-keyboard"></i></a></div><div class="console-btn-item" id="assist-open" onclick="heo.hideConsole()" title="无障碍工具栏"><a class="assist-btn"><i class="fas fa-wheelchair"></i></a></div><div class="console-btn-item" id="consoleCommentBarrage" onclick="heo.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="fa-solid fa-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="heo.musicToggle()" title="音乐开关"><a class="music-switch"><i class="fas fa-music"></i></a></div></div><div class="console-mask" onclick="heo.hideConsole()" href="javascript:void(0);"></div></div><header class="post-bg" id="page-header" style="background-image: url('/image/img-background/30.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="善良的xwysyy"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.png"/><span class="site-name">善良的xwysyy</span></a></span><div id="none_space"></div><div class="mask-name-container"><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)">PAGE_NAME</a></center></div><div id="menus"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon fas fa-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">主页</div><div class="back-menu-list"><a class="back-menu-item" href="https://index.xwysyy.cn" title="xwysyy主页" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/%E5%A4%B4%E5%83%8F.jpg"/><span class="back-menu-item-text">xwysyy主页</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客线路</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.xwysyy.cn" title="腾讯云线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube1.png"/><span class="back-menu-item-text">腾讯云主线路</span></a><a class="back-menu-item" href="https://vercel.xwysyy.cn" title="Vercel线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube2.png"/><span class="back-menu-item-text">Vercel线路</span></a><a class="back-menu-item" href="https://www.xwysyy.life" title="Github线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube4.png"/><span class="back-menu-item-text">Github线路</span></a><a class="back-menu-item" href="https://netlify.xwysyy.cn" title="Netlify线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube5.png"/><span class="back-menu-item-text">Netlify线路</span></a><a class="back-menu-item" href="https://xwysyy.pages.dev" title="Cloudflare线路" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube6.png"/><span class="back-menu-item-text">Cloudflare线路</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">部署项目</div><div class="back-menu-list"><a class="back-menu-item" href="https://pan.xwysyy.cn" title="xwysyy云盘" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube7.png"/><span class="back-menu-item-text">xwysyy云盘</span></a><a class="back-menu-item" href="https://cube.xwysyy.cn" title="Lijz的魔方小站" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube9.png"/><span class="back-menu-item-text">Lijz的魔方小站</span></a><a class="back-menu-item" href="https://chatgpt.xwysyy.cn" title="xwysyy ChatGPT" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-icon/cube13.png"/><span class="back-menu-item-text">xwysyy ChatGPT</span></a></div></div></div></div><div class="nav-button" id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn"><i class="fas fa-arrow-up"></i><span id="percent" onclick="btf.scrollToDest(0,500)"> </span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/log/"><i class="fa-fw fas fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://uptime-kuma.xwysyy.cn/status/monitor"><i class="fa-fw fas fa-shield-alt"></i><span> 监控</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-file-alt"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-chart-area"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li><li><a class="site-page child" href="/ToDoList/"><i class="fa-fw fas fa-bell"></i><span> 待办</span></a></li><li><a class="site-page child" href="/records/"><i class="fa-fw fas fa-comments"></i><span> 文字瞬间</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page child" href="/friends/"><i class="fa-fw fas fa-user-friends"></i><span> 鱼塘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Fireworks"><i class="fa-fw fa fa-fire"></i><span> 烟花</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/reference"><i class="fa-fw fa fa-code"></i><span> 参考</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://xwysyy.github.io/Music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about-chat/"><i class="fa-fw fas fa-comment"></i><span> 交互版</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-envelope"></i><span> 静态版</span></a></li><li><a class="site-page child" href="/essay/"><i class="fa-fw fas fa-edit"></i><span> 杂谈</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-21T16:00:00.000Z" title="发表于 2023-04-22 00:00:00">2023-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-24T10:07:11.552Z" title="更新于 2023-08-24 18:07:11">2023-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/syntax/">syntax</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.4w</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>126分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>一、Python 起源</h1>
<h2 id="1-Python-简史">1. Python 简史</h2>
<ul>
<li>Python 创始人</li>
<li>Python 理念</li>
<li>Python 名字由来</li>
<li>Python 之禅</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/1.jpg" alt="img"></p>
<h3 id="1-1-Python-创始人">1.1 Python 创始人</h3>
<p>Python 的创始人为吉多·范罗苏姆（Guido van Rossum），1989年开始编写，并在1991年正式发布Python编译器。</p>
<h3 id="1-2-Python-的理念">1.2 Python 的理念</h3>
<p>Guido 在工作中负责 ABC 语言的开发，ABC语言是一种教学语言，降低了编程的学习门槛。通过 ABC 语言的启发，创建了Python，而Python语言是为了让更多非计算机专业的普通人也能简单易懂的编程。</p>
<h3 id="1-3-Python-名字的由来">1.3 Python 名字的由来</h3>
<p>因为喜欢 Monty Python’s Flying Circus 的情景喜剧，所以任性的将这门自己开发的编程语言叫做了 Python。</p>
<h3 id="1-4-Python-之禅">1.4 Python 之禅</h3>
<p>因为是受到 ABC 语言的影响，所以 Python 的编程思想也是越简单、越容易理解越好。Python 之禅是由Tim Peters 在递交邮件给 Guido 的时候发表的一个针对 Python 编程设计的19条编程理念</p>
<p>Python之禅作为一个信息条款被录入Python增强建议（PEP）的第20条，在Python语言的官方网站也能找到。它还作为复活节彩蛋被包含在Python解释器中。如果输入 <code>import this</code> 就会在Python的编程环境中显示。</p>
<blockquote>
<p><strong>PEP 20 – The Zen of Python</strong><br>
Beautiful is better than ugly.<br>
Explicit is better than implicit.<br>
Simple is better than complex.<br>
Complex is better than complicated.<br>
Flat is better than nested.<br>
Sparse is better than dense.<br>
Readability counts.<br>
Special cases aren’t special enough to break the rules.<br>
Although practicality beats purity.<br>
Errors should never pass silently.<br>
Unless explicitly silenced.<br>
In the face of ambiguity, refuse the temptation to guess.<br>
There should be one-- and preferably only one --obvious way to do it.<br>
Although that way may not be obvious at first unless you’re Dutch.<br>
Now is better than never.<br>
Although never is often better than <em>right</em> now.<br>
If the implementation is hard to explain, it’s a bad idea.<br>
If the implementation is easy to explain, it may be a good idea.<br>
Namespaces are one honking great idea – let’s do more of those!</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/2.jpg" alt="img"></p>
<p>Life is short, You need Python.</p>
<p>人生苦短，我用Python</p>
<p>加油吧，少年！</p>
<h2 id="2-Python-的特点">2. Python 的特点</h2>
<h3 id="2-1-Python-优缺点">2.1 Python 优缺点</h3>
<p><strong>Python 优点</strong>：</p>
<ol>
<li>简单明了，学习曲线低，相对于很多其他编程语言来说，更容易上手。</li>
<li>开放源代码，可扩展性强，拥有强大的社区和生态圈，尤其是在数据分析和机器学习领域。</li>
<li>解释型语言，天生具有平台可移植性，代码可以工作于不同的操作系统。</li>
<li>对两种主流的编程方式（面向对象编程和函数式编程）都提供了支持。</li>
<li>代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。</li>
</ol>
<p><strong>Python 缺点：</strong></p>
<ol>
<li>效率低，运行速度慢是解释型语言的通病，Python 也不例外。</li>
<li>代码加密困难（虽然有pyc、pyo等加密方式，但是同样也有解密工具）</li>
</ol>
<h3 id="2-2-Python-可以做什么？">2.2 Python 可以做什么？</h3>
<p>1999年的一份报纸</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/3.jpg" alt="image-20210110154335461"></p>
<ol>
<li>Web 应用开发</li>
<li>自动化运维</li>
<li>网络爬虫</li>
<li>数据分析</li>
<li>金融量化</li>
<li>科学计算</li>
<li>人工智能</li>
<li>游戏开发</li>
<li>桌面应用</li>
</ol>
<h2 id="3-解释器">3. 解释器</h2>
<p>计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为编译器。</p>
<p><strong>进制</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/4.jpg" alt="二进制、八进制、十进制、十六进制的转换"></p>
<p>开关</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/5.jpg" alt="img"></p>
<p>我的世界打造的计算机</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/6.jpg" alt="img"></p>
<p>机器语言：1011011000000000 代表 1+2</p>
<p>汇编语言：ADD 1,2</p>
<p>220.181.38.148 -&gt; <a target="_blank" rel="noopener" href="http://baidu.com">baidu.com</a></p>
<p><strong>机器语言/汇编语言/高级语言：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/7.jpg" alt="img"></p>
<p>编译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译时间点的不同。当编译器以解释方式运行的时候，也称之为解释器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/8.jpg" alt="img"></p>
<p><strong>编译型语言（如C）</strong>，只能在单平台上运行，运行前需要将所有代码进行编译器进行编译，生成可执行文件，然后直接由CPU行，只能针对同平台运行。速度快</p>
<p><strong>解释型语言（Python）</strong>，由于可以在不同平台安装解释器，所以跨平台效果比较好，因为逐行解释，所以速度较慢。</p>
<h2 id="4-Python-的安装">4. Python 的安装</h2>
<p>官网地址：<a target="_blank" rel="noopener" href="https://www.python.org">https://www.python.org</a><br>
下载 3.x 版本，新命令已经和2.x版本不兼容了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/9.jpg" alt="img"></p>
<blockquote>
<p>注意： 需要勾选加入环境变量</p>
</blockquote>
<p>如果忘记勾选加入系统变量可以在 Windows 中设置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/10.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/11.jpg" alt="img"></p>
<blockquote>
<p>注意：Install for all user ，路径最好安装在根目录，避免权限问题</p>
</blockquote>
<p>Python 默认路径PATH：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\用户名\AppData\Local\Programs\Python\Python38-32\</span><br><span class="line">C:\Users\用户名\AppData\Local\Programs\Python\Python38-32\Scripts\</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意自己的用户名和Python版本</p>
</blockquote>
<h2 id="5-运行环境">5. 运行环境</h2>
<h3 id="5-1-交互式-Python">5.1 交互式 Python</h3>
<p>交互式方式进入方法就是在 shell 中输入python，进入python环境</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/12.jpg" alt="img"></p>
<p><strong>退出方式：</strong></p>
<ol>
<li>直接输入 exit()</li>
<li>CTRL+Z</li>
</ol>
<p>像这类交互式 Python 还有 ipython、Jupyter Notebook 等。</p>
<h3 id="5-2-集成开发环境">5.2 集成开发环境</h3>
<p><strong>IDLE</strong></p>
<p>IDLE 是 Python 软件包自带的一个集成开发环境，初学者可以利用它方便地创建、运行、测试和调试Python程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/13.jpg" alt="img"></p>
<p>进入 IDLE 后，因为只是 Shell 所以每句python命令只是单行逐步执行，CTRL+N 新建文件后可以输入多行命令，然后保存后，按F5执行即可。</p>
<p><strong>快捷键</strong></p>
<blockquote>
<p>Alt + N 上一条命令<br>
Alt + P 下一条命令</p>
</blockquote>
<p><strong>Pycharm</strong></p>
<p>pyCharm - 目前比较流行的像Visual Studio一样集成IDE环境。IDE（Integrated Development Environment）</p>
<p>官方网站：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/14.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ctrl+ j</code></td>
<td>显示可用的代码模板</td>
</tr>
<tr>
<td><code>ctrl+ b</code></td>
<td>查看函数、类、方法的定义</td>
</tr>
<tr>
<td><code>ctrl + space</code></td>
<td>万能代码提示快捷键，一下不行按两下</td>
</tr>
<tr>
<td>ctrl+ alt + l`</td>
<td>格式化代码</td>
</tr>
<tr>
<td><code>alt + enter</code></td>
<td>万能代码修复快捷键</td>
</tr>
<tr>
<td><code>ctrl + /</code></td>
<td>注释/反注释代码</td>
</tr>
<tr>
<td><code>shift + shift</code></td>
<td>万能搜索快捷键</td>
</tr>
<tr>
<td>ctrl+ d<code>/</code>ctrl+ y`</td>
<td>复制/删除一行代码</td>
</tr>
<tr>
<td>ctrl+ shift + -<code>/</code>ctrl+ shift + +`</td>
<td>折叠/展开所有代码</td>
</tr>
<tr>
<td><code>F2</code></td>
<td>快速定位到错误代码</td>
</tr>
<tr>
<td><code>ctrl+ alt + F7</code></td>
<td>查看哪些地方用到了指定的函数、类、方法</td>
</tr>
</tbody>
</table>
<h2 id="6-Python-命名规则">6. Python 命名规则</h2>
<p><strong>驼峰命名法</strong></p>
<p>小驼峰命名法：除第一个单词之外，其他单词首字母大写，例如：myFirstName、myLastName。常用于变量名，函数名。</p>
<p>大驼峰命名法 (又称为帕斯卡命名法)：相比小驼峰法，大驼峰法把第一个单词的首字母也大写了，例如：DataBaseUser。常用于类名，属性，命名空间等。</p>
<p><strong>下划线命名法</strong></p>
<p>名称中的每一个逻辑断点都用一个下划线来标记，例如：print_employee。下划线命名法是随着C语言的出现流行起来的，在UNIX/LIUNX这样的环境，以及GNU代码中使用非常普遍。</p>
<h3 id="6-1-文件项目命名规则">6.1 文件项目命名规则</h3>
<ul>
<li>建议只使用小写字母、数字和下划线</li>
<li>文件名不能以数字开始</li>
</ul>
<p>下划线更容易辨识，并且搜索的时候不会因为大小写而查找不到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a_variable_name = 1</span><br><span class="line">aVariableName = 1</span><br></pre></td></tr></table></figure>
<h3 id="6-2-Python-手册命名规范">6.2 Python 手册命名规范</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/15.jpg" alt="img"></p>
<blockquote>
<p>除了不能以数字开始做为变量名，Python 关键字也不能做为变量名</p>
<p>新版的 Python 已经可以支持中文变量名，但是不推荐使用。</p>
</blockquote>
<p><strong>Python 关键字查看方法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(dir(__builtins__))</span><br></pre></td></tr></table></figure>
<p>关键字列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;ArithmeticError&#x27;, &#x27;AssertionError&#x27;, &#x27;AttributeError&#x27;, &#x27;BaseException&#x27;, &#x27;BlockingIOError&#x27;, &#x27;BrokenPipeError&#x27;, &#x27;BufferError&#x27;, &#x27;BytesWarning&#x27;, &#x27;ChildProcessError&#x27;, &#x27;ConnectionAbortedError&#x27;, &#x27;ConnectionError&#x27;, &#x27;ConnectionRefusedError&#x27;, &#x27;ConnectionResetError&#x27;, &#x27;DeprecationWarning&#x27;, &#x27;EOFError&#x27;, &#x27;Ellipsis&#x27;, &#x27;EnvironmentError&#x27;, &#x27;Exception&#x27;, &#x27;False&#x27;, &#x27;FileExistsError&#x27;, &#x27;FileNotFoundError&#x27;, &#x27;FloatingPointError&#x27;, &#x27;FutureWarning&#x27;, &#x27;GeneratorExit&#x27;, &#x27;IOError&#x27;, &#x27;ImportError&#x27;, &#x27;ImportWarning&#x27;, &#x27;IndentationError&#x27;, &#x27;IndexError&#x27;, &#x27;InterruptedError&#x27;, &#x27;IsADirectoryError&#x27;, &#x27;KeyError&#x27;, &#x27;KeyboardInterrupt&#x27;, &#x27;LookupError&#x27;, &#x27;MemoryError&#x27;, &#x27;ModuleNotFoundError&#x27;, &#x27;NameError&#x27;, &#x27;None&#x27;, &#x27;NotADirectoryError&#x27;, &#x27;NotImplemented&#x27;, &#x27;NotImplementedError&#x27;, &#x27;OSError&#x27;, &#x27;OverflowError&#x27;, &#x27;PendingDeprecationWarning&#x27;, &#x27;PermissionError&#x27;, &#x27;ProcessLookupError&#x27;, &#x27;RecursionError&#x27;, &#x27;ReferenceError&#x27;, &#x27;ResourceWarning&#x27;, &#x27;RuntimeError&#x27;, &#x27;RuntimeWarning&#x27;, &#x27;StopAsyncIteration&#x27;, &#x27;StopIteration&#x27;, &#x27;SyntaxError&#x27;, &#x27;SyntaxWarning&#x27;, &#x27;SystemError&#x27;, &#x27;SystemExit&#x27;, &#x27;TabError&#x27;, &#x27;TimeoutError&#x27;, &#x27;True&#x27;, &#x27;TypeError&#x27;, &#x27;UnboundLocalError&#x27;, &#x27;UnicodeDecodeError&#x27;, &#x27;UnicodeEncodeError&#x27;, &#x27;UnicodeError&#x27;, &#x27;UnicodeTranslateError&#x27;, &#x27;UnicodeWarning&#x27;, &#x27;UserWarning&#x27;, &#x27;ValueError&#x27;, &#x27;Warning&#x27;, &#x27;WindowsError&#x27;, &#x27;ZeroDivisionError&#x27;, &#x27;__build_class__&#x27;, &#x27;__debug__&#x27;, &#x27;__doc__&#x27;, &#x27;__import__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;abs&#x27;, &#x27;all&#x27;, &#x27;any&#x27;, &#x27;ascii&#x27;, &#x27;bin&#x27;, &#x27;bool&#x27;, &#x27;breakpoint&#x27;, &#x27;bytearray&#x27;, &#x27;bytes&#x27;, &#x27;callable&#x27;, &#x27;chr&#x27;, &#x27;classmethod&#x27;, &#x27;compile&#x27;, &#x27;complex&#x27;, &#x27;copyright&#x27;, &#x27;credits&#x27;, &#x27;delattr&#x27;, &#x27;dict&#x27;, &#x27;dir&#x27;, &#x27;divmod&#x27;, &#x27;enumerate&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;exit&#x27;, &#x27;filter&#x27;, &#x27;float&#x27;, &#x27;format&#x27;, &#x27;frozenset&#x27;, &#x27;getattr&#x27;, &#x27;globals&#x27;, &#x27;hasattr&#x27;, &#x27;hash&#x27;, &#x27;help&#x27;, &#x27;hex&#x27;, &#x27;id&#x27;, &#x27;input&#x27;, &#x27;int&#x27;, &#x27;isinstance&#x27;, &#x27;issubclass&#x27;, &#x27;iter&#x27;, &#x27;len&#x27;, &#x27;license&#x27;, &#x27;list&#x27;, &#x27;locals&#x27;, &#x27;map&#x27;, &#x27;max&#x27;, &#x27;memoryview&#x27;, &#x27;min&#x27;, &#x27;next&#x27;, &#x27;object&#x27;, &#x27;oct&#x27;, &#x27;open&#x27;, &#x27;ord&#x27;, &#x27;pow&#x27;, &#x27;print&#x27;, &#x27;property&#x27;, &#x27;quit&#x27;, &#x27;range&#x27;, &#x27;repr&#x27;, &#x27;reversed&#x27;, &#x27;round&#x27;, &#x27;set&#x27;, &#x27;setattr&#x27;, &#x27;slice&#x27;, &#x27;sorted&#x27;, &#x27;staticmethod&#x27;, &#x27;str&#x27;, &#x27;sum&#x27;, &#x27;super&#x27;, &#x27;tuple&#x27;, &#x27;type&#x27;, &#x27;vars&#x27;, &#x27;zip&#x27;]</span><br></pre></td></tr></table></figure>
<h2 id="7-Python-注释方法">7. Python 注释方法</h2>
<p><strong>代码注释的作用：</strong></p>
<p>1、给阅读代码的人一个解释性说明。注意看代码的人包括你自己。让看你代码的人可以快速的浏览你的代码，不需要把所有代码看完，才能明白你写的什么。</p>
<p>2、为接下来要实现的功能写出一个指导性的算法思路。类似于提纲。比如说：</p>
<ul>
<li>
<p># 注册功能</p>
</li>
<li>
<p># 登录功能</p>
</li>
<li>
<p># 发帖功能</p>
</li>
</ul>
<p>3、调试代码</p>
<h3 id="7-1-单行注释">7.1 单行注释</h3>
<p>以 <code>#</code> 开头，<code>#</code> 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用<br>
示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是第一个单行注释</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>为了保证代码的可读性，<code>#</code> 后面建议先添加一个空格，然后再编写相应的说明文字</p>
<p>在代码后面增加的单行注释</p>
<p>在程序开发时，同样可以使用 <code>#</code> 在代码的后面（旁边）增加说明性的文字<br>
但是，需要注意的是，为了保证代码的可读性，注释和代码之间要有两个空格</p>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)  <span class="comment"># 输出 hello world</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-多行注释">7.2 多行注释</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是一个多行注释</span></span><br><span class="line"><span class="string">在多行注释之间，可以写很多很多的内容……</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello python&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 PyCharm 里的快捷键，选上需要注释的块，然后按 CTRL + /</p>
</blockquote>
<h3 id="7-3-添加任务列表">7.3 添加任务列表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TODO(负责人) 注释</span></span><br></pre></td></tr></table></figure>
<p><strong>代码注释原则：</strong></p>
<p>1、能够帮助读者更好的了解代码逻辑与结构</p>
<p>2、特别的或不容易理解的写法可以解释说明</p>
<p>3、特殊标记注释：如 TODO、FIXME 等有特殊含义的标记</p>
<p>4、文件注释：部分规定会要求在文件头部书写固定格式的注释，如注明作者、协议等信息</p>
<p>5、文档类注释：部分规定要求 API类、函数等使用文档类注释（如 jsdoc 风格，RESTFUL 风格）</p>
<p>6、遵循统一的风格规范，如一定的空格、空行，以保证注释自身的可读性</p>
<h2 id="8-小技巧">8. 小技巧</h2>
<h3 id="8-1-shebang">8.1 shebang</h3>
<p>在脚本中, 第一行以<code> #!</code> 开头的代码, 在计算机行业中叫做 <code>shebang</code>, 也叫做 sha-bang / hashbang / pound-bang / hash-pling, 其作用是&quot;指定由哪个解释器来执行脚本&quot;。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>举个例子, 很多人在系统中同时安装了 Python2 和 Python3, 但是 2 和 3 是不兼容的, 所以执行脚本时必须指定解释器.</p>
</blockquote>
<h3 id="8-2-Python-2-x-兼容中文：">8.2 Python 2.x 兼容中文：</h3>
<p>Python3 已经默认 UTF-8 编码，支持了中文，但是如果你的程序在老版本的 Python 中运行的话，那么如果你的代码中有特殊字符（比如中文，就会无法执行）需要在 py 文件头部声明一下编码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上三种写法都是合法有效的<br>
<strong>但是, <code>coding</code> 和 <code>=</code>之间, 或者<code>coding</code> 和 <code>:</code>之间, 不能有空格!</strong></p>
</blockquote>
<p>关于 ASCII、GBK、UTF-8 等一些说明：</p>
<p><strong>ASCII</strong>(American Standard Code for Information Interchange，美国标准信息交换代码)是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。</p>
<p><strong>GBK编码****由于</strong>ASCII编码不支持中文，因此，当中国人用到计算机时，就需要寻求一种编码方式来支持中文。于是，国人就定义了一套编码规则。加了7000多个汉字进去，当时叫做 GB2312，BIG5 后来又扩展了一下增加了繁体和更多汉字，作为一个扩展，这套字符编码叫做 GBK。</p>
<p><strong>Unicode 字符集</strong>是当时 ISO （国际标准化组织） 为了国际化，将世界上所有文字、字符整合起来，形成的这么一套编码集。</p>
<p><strong>UTF-8</strong> 是因为 Unicode 传输起来太慢了，所以开发的这么一个编码，类似的还有 UTF-16</p>
<h1>二、数据类型</h1>
<p><code>变量</code>这个概念来源于数学，是计算机语言中能储存计算结果或能表示值的抽象概念。可以将变量想象成一个容器，比如说箱子、柜子之类的容器，我们在箱子中存放的衣服、杂物等等就可以看做是数据。</p>
<p>计算机运行程序示意图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/16.jpg" alt="20200325142821755"></p>
<p>如何定义一个变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量名 = 数据</span><br></pre></td></tr></table></figure>
<blockquote>
<p>= 是赋值运算符，可以看做将右侧的数据赋值给左侧的变量名</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/17.jpg" alt="See the source image"></p>
<p>但是在原理上，其实是将数值在内存中的地址给了变量，如果外部（也就是说我们程序）需要使用这个数据的话，就需要使用引用（变量名）</p>
<h2 id="1-数据类型">1. 数据类型</h2>
<ul>
<li>Numbers（数字）</li>
<li>Boolean（布尔型）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
<li>Set （集合）</li>
</ul>
<p><strong>Numbers 数字类型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># int - 整型（包含二进制、八进制、十进制、十六进制）</span></span><br><span class="line"></span><br><span class="line">number0 = <span class="number">50</span>  <span class="comment"># 十进制 Decimal</span></span><br><span class="line">number1 = <span class="number">0b11</span>  <span class="comment"># 二进制 Bianry</span></span><br><span class="line">number2 = <span class="number">0O10</span>  <span class="comment"># 八进制 Octal</span></span><br><span class="line">number3 = <span class="number">0x1A</span>  <span class="comment"># 十六进制 Hexadecimal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># float - 浮点型（小数）</span></span><br><span class="line">float_number = <span class="number">3.145</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：像 12.0 这样的数字，看起来是个整数，但是只要有小数点就属于浮点型数据。</p>
</blockquote>
<p>进制转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dec(obj)  <span class="comment"># 十进制</span></span><br><span class="line"><span class="built_in">bin</span>(obj)  <span class="comment"># 二进制</span></span><br><span class="line"><span class="built_in">oct</span>(obj)  <span class="comment"># 八进制</span></span><br><span class="line"><span class="built_in">hex</span>(obj)  <span class="comment"># 十六进制</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不转换的话，那么输出的数字类型变量还是会以十进制来显示。</p>
</blockquote>
<h4 id="id-函数">id() 函数</h4>
<p>查看变量内存地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">id</span>(a)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 140704293193392</span></span><br><span class="line"><span class="comment"># 0x7ff8456a06b0  # 一般内存用16进制表示</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 id() 函数，我们可以看出变量在内存中的存储方式</p>
</blockquote>
<p>有些人认为，将一个数据赋值给一个变量在内存中就会多出一个数据，其实不是的。只要内存中有这个数据，那么变量只需要改变引用就可以达到看似是改变值的目的，（其实是改变引用的内存地址）而不是在内存中添加一个相同的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/18.jpg" alt="image-20210309173814464"></p>
<p><strong>布尔型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># boolean - 布尔型（注意大小写）</span></span><br><span class="line"><span class="comment"># 可以用 bool() 来查看变量转换成布尔型之后的值</span></span><br><span class="line">i = <span class="literal">True</span></span><br><span class="line">b = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>整数值0、浮点数值0.0等、空字符串都为假</strong></li>
<li><strong>None为假</strong></li>
<li><strong>空数据对象都是假，比如[]、{}、()等</strong></li>
</ul>
</blockquote>
<p><strong>String 字符串类型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># str - 字符串</span></span><br><span class="line">string = <span class="string">&quot;This is a string&quot;</span></span><br><span class="line">string = <span class="string">&quot;50&quot;</span></span><br><span class="line">string = <span class="string">&quot;True&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在字符串中包含双引号</span></span><br><span class="line">string = <span class="string">&quot;he said \&quot;ok\&quot;&quot;</span></span><br><span class="line">string = <span class="string">&#x27;he said &quot;ok&quot;&#x27;</span></span><br><span class="line">string = <span class="string">&quot;I&#x27;m OK&quot;</span></span><br><span class="line">string = <span class="string">&quot;I&#x27;m \&quot;OK\&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行字符串</span></span><br><span class="line">string = <span class="string">&quot;&quot;&quot;第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行字符串</span></span><br><span class="line">string = <span class="string">&quot;第一行\n第二行\n第三行&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决转义字符 (\n)在字符串的问题</span></span><br><span class="line">path = <span class="string">&quot;C:\new&quot;</span></span><br><span class="line">path = <span class="string">&quot;C:\\new&quot;</span></span><br><span class="line">path = <span class="string">r&quot;C:\new&quot;</span></span><br><span class="line">path = <span class="string">&quot;C:/new&quot;</span></span><br></pre></td></tr></table></figure>
<p>字符串变量拼接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串变量与其他变量联合使用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字是&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串变量使用 + 拼接字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;string1&quot;</span> + <span class="string">&quot;string2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 * 重复拼接相同字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：数字型变量和字符串变量不能进行运算，需要将其他类型的变量用 str() 转换成字符串变量。</p>
</blockquote>
<h2 id="2-type-查看数据类型">2. type() 查看数据类型</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看变量a的数据类型</span></span><br><span class="line">a = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-isinstance-判断数据类型">3. isinstance() 判断数据类型</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断数据类型</span></span><br><span class="line">a = <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a,<span class="built_in">str</span>))  <span class="comment"># 判断a是否是字符串型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="4-数据类型的转换">4. 数据类型的转换</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转整形</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&quot;20&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转浮点型</span></span><br><span class="line"><span class="built_in">float</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转字符串</span></span><br><span class="line"><span class="built_in">str</span>(<span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转布尔型</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>
<p>int(), float(), str(), bool() 这几个转换数据类型的函数，不会改变原来变量的类型，只是在内存中生成了一个新的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_a = <span class="number">4.1</span></span><br><span class="line">num_b = <span class="number">5.2</span></span><br><span class="line"><span class="built_in">int</span>(num_a)  <span class="comment"># 没有改变原来的 num_a，只是 int(num_a) 这个整体是整型</span></span><br><span class="line">num_b = <span class="built_in">int</span>(num_b)  <span class="comment"># 重新将变量赋值，所以数据类型已经改变</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num_a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num_b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考一下，如果 num_a, num_b 都是1.5的情况，用 id() 函数看一下他们转换后地址的变化。</p>
<ul>
<li>num_a 内存地址</li>
<li>num_b 内存地址</li>
<li>int(num_a) 内存地址</li>
<li>int(num_b) 内存地址</li>
<li>num_b 被重新赋值后的内存地址</li>
</ul>
</blockquote>
<h1>三、 Print 输出函数</h1>
<p>print 函数的作用，可以把 <code>&quot;&quot;</code> 内部的内容，输出到屏幕上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)  <span class="comment"># 可以输出文字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>+<span class="number">3</span>)  <span class="comment"># 可以计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Well&quot;</span> + <span class="string">&quot;Done&quot;</span>)  <span class="comment"># 可以连接字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Abc&quot;</span> + <span class="string">&quot; 456&quot;</span>)  <span class="comment"># 带空格连接</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.01</span> ** <span class="number">365</span>)  <span class="comment"># 输出1.01的365次方</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ABC&quot;</span> *<span class="number">8</span>)  <span class="comment"># 重复打印8遍ABC</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ABC\n&quot;</span> *<span class="number">8</span>)  <span class="comment"># 重复打印8遍ABC带换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c:\\new_file.py&quot;</span>)  <span class="comment"># 用\来转义字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;he said &quot;OK&quot;&#x27;</span>)  <span class="comment"># 或直接用单引号来引用整个带符号的字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：字符串和数字不能同时输出，需要将数字转换为字符串如：</span></span><br><span class="line"><span class="built_in">print</span>(name + <span class="string">&quot; is &quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot; years old&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要将字符串类型的数字与整形或浮点型数据进行运算的话，也同样需要对字符串数据进行转换。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;68&quot;</span>) + <span class="number">32</span>)</span><br></pre></td></tr></table></figure>
<p>在默认情况下 print 函数输出内容之后，会自动在内容末尾增加换行，如果不希望在末尾增加换行，可以在 print 函数输出内容的后面增加， <code>end=&quot;&quot;</code></p>
<p>其中 “” 中间可以指定 print 函数输出内容之后，继续希望显示的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print 函数输出后不换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只输出空行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考题：print(“\n”) 会输出什么？</p>
</blockquote>
<h1>四、Input 输入函数</h1>
<p>使用 input 函数，可以将用户在控制台输入的数据传入变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&quot;这里的字符会在控制台中显示，并且等待用户输入字符&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：所有利用 input 函数所输入的变量都是字符串变量。</p>
</blockquote>
<p>可以直接给 input 输入的数据赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp1=<span class="built_in">input</span>(<span class="string">&quot;随便输入一个数字:&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1>练习：</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算各种水果的价格，</span><br><span class="line">可输入变量1：水果名称</span><br><span class="line">可输入变量2：水果价格</span><br><span class="line">可输入变量3：水果数量</span><br><span class="line">可输入变量4：姓名</span><br><span class="line">最后输出结果例：张三买了3个苹果，每个苹果价格是10元，总共花了30元。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算各种水果的价格，</span></span><br><span class="line"><span class="comment"># 可输入变量1：水果名称</span></span><br><span class="line">fruit_name = <span class="built_in">input</span>(<span class="string">&quot;水果名称:&quot;</span>)</span><br><span class="line"><span class="comment"># 可输入变量2：水果价格</span></span><br><span class="line">fruit_price = <span class="built_in">input</span>(<span class="string">&quot;水果价格:&quot;</span>)</span><br><span class="line"><span class="comment"># 可输入变量3：水果数量</span></span><br><span class="line">fruit_quantity = <span class="built_in">input</span>(<span class="string">&quot;水果数量:&quot;</span>)</span><br><span class="line"><span class="comment"># 可输入变量4：姓名</span></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;姓名:&quot;</span>)</span><br><span class="line"><span class="comment"># 最后输出结果例：张三买了3个苹果，每个苹果价格是10元，总共花了30元。</span></span><br><span class="line">result = name + <span class="string">&quot;买了&quot;</span> + fruit_quantity + <span class="string">&quot;个&quot;</span> + fruit_name + <span class="string">&quot;，每个&quot;</span> + fruit_name + <span class="string">&quot;价格是&quot;</span> + \</span><br><span class="line">         fruit_price + <span class="string">&quot;元，总共花了&quot;</span> + <span class="built_in">str</span>(<span class="built_in">float</span>(fruit_price) * <span class="built_in">float</span>(fruit_quantity)) + <span class="string">&quot;元。&quot;</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<h1>五、帮助文档</h1>
<p>内置函数，英文为 Bulit-in functions，是 Python 中自带的一些基本函数，像之前学的 print() , input() , id() , type()  这些都是 BIF。虽然有些函数也是 Python 自带的，不过是以包的方式存在，需要 import 语句导入才可以使用。比如：re 正则的包</p>
<p>在 Python 或 IDLE 中，或者 Pycharm 中输入 <code>print(dir(__builtins__))</code>可以看到 Python 提供的内置方法列表（注意，builtins 前后是两个下划线）其中小写的就是 BIF。如果想具体查看某个 BIF 的功能，比如 input()，可以在 Python 环境中输入 help(input)，就会得到这个 BIF 的功能描述。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(__builtins__))  <span class="comment"># 查看 Python 提供的内置方法列表</span></span><br><span class="line"><span class="built_in">help</span>(<span class="built_in">input</span>)  <span class="comment"># 查看 input 命令功能描述</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__doc__)  <span class="comment"># 查看 str 函数文档</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>help() 会比 <code>__doc__</code> 文档更详细一些</p>
</blockquote>
<h1>六、运算符</h1>
<h2 id="1-数学计算符">1. 数学计算符</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+ - * / %  <span class="comment"># 加、减、乘、除、求余</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%  <span class="comment"># 求余数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> % <span class="number">2</span>)  <span class="comment"># 结果为1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//  <span class="comment"># 取整数 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">9</span> // <span class="number">2</span>)  <span class="comment"># 结果为4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">**  <span class="comment"># 幂运算，又称作次方</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> ** <span class="number">3</span>)  <span class="comment"># 求2的3次方，结果为8</span></span><br></pre></td></tr></table></figure>
<h2 id="2-比较运算符">2. 比较运算符</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;  <span class="comment"># 小于号</span></span><br><span class="line">&gt;  <span class="comment"># 大于号</span></span><br><span class="line">&lt;=  <span class="comment"># 小于等于</span></span><br><span class="line">&gt;=  <span class="comment"># 大于等于</span></span><br><span class="line">==  <span class="comment"># 相等</span></span><br><span class="line">!=  <span class="comment"># 不等</span></span><br></pre></td></tr></table></figure>
<h2 id="3-逻辑运算符">3. 逻辑运算符</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span>	 <span class="comment"># 逻辑与</span></span><br><span class="line"><span class="keyword">or</span>	 <span class="comment"># 逻辑或</span></span><br><span class="line"><span class="keyword">not</span>	 <span class="comment"># 逻辑非</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 20</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">逻辑表达式</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">and</td>
<td style="text-align:left">x and y</td>
<td style="text-align:left">布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td>
<td style="text-align:left">(a and b) 返回 20。</td>
</tr>
<tr>
<td style="text-align:left">or</td>
<td style="text-align:left">x or y</td>
<td style="text-align:left">布尔&quot;或&quot; - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</td>
<td style="text-align:left">(a or b) 返回 10。</td>
</tr>
<tr>
<td style="text-align:left">not</td>
<td style="text-align:left">not x</td>
<td style="text-align:left">布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td style="text-align:left">not(a and b) 返回 False</td>
</tr>
</tbody>
</table>
<p>逻辑运算会出现短路问题</p>
<p>短路是指如果在进行前面的表达式的运算过程，通过判断已经明确的知道整个表达式的结果，那么就不会进行后面表达式的运算判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">表达式<span class="number">1</span> <span class="keyword">and</span> 表达式<span class="number">2</span> <span class="keyword">and</span> 表达式<span class="number">3</span>  <span class="comment"># 当表达式1为False的时候，则整个表达式结果为False，则不会对表达式2、表达式3进行运算</span></span><br><span class="line">表达式<span class="number">1</span> <span class="keyword">or</span> 表达式<span class="number">2</span> <span class="keyword">or</span> 表达式<span class="number">3</span>  <span class="comment"># 当表达式1为True的时候，则整个表达式结果为True，则不会对表达式2、表达式3进行运算</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># and 短路例子</span></span><br><span class="line"><span class="number">3</span>&gt;<span class="number">4</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># or 短路例子</span></span><br><span class="line"><span class="number">2</span>&gt;=<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="4-赋值运算符">4. 赋值运算符</h2>
<p><strong>多个变量赋值</strong></p>
<p>Python允许你同时为多个变量赋值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = b = c = 1</span><br><span class="line">a, b, c = 1, 2, &quot;john&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = i + <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span> <span class="comment"># 也可以写成</span></span><br></pre></td></tr></table></figure>
<p>同样的写法还有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">=</span><br><span class="line">+=</span><br><span class="line">-=</span><br><span class="line">*=</span><br><span class="line">/=</span><br><span class="line">//=</span><br><span class="line">%=</span><br><span class="line">**=</span><br></pre></td></tr></table></figure>
<h2 id="5-运算符优先级">5. 运算符优先级</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/19.jpg" alt="img"></p>
<h2 id="6-字符串的常用操作">6. 字符串的常用操作</h2>
<p>在 ipython3 中定义一个字符串，例如：<code>hello_str = &quot;&quot;</code><br>
输入 <code>hello_str.</code> 按下 TAB 键，ipython 会提示字符串能够使用的方法如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/20.jpg" alt="img"></p>
<h3 id="6-1-字符串大小写转换">6.1 字符串大小写转换</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将字符串转换成小写</span></span><br><span class="line">string.lower()</span><br><span class="line"></span><br><span class="line"><span class="comment">#  将字符串转换为大写</span></span><br><span class="line">string.upper()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字符串字母的大小写进行反转</span></span><br><span class="line">string.swapcase()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将首字母转换成大写</span></span><br><span class="line">string.capitalize()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串中每个“单词”首字母大写。</span></span><br><span class="line">string.title()</span><br></pre></td></tr></table></figure>
<p>方法可以连起来使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换大写后进行判断</span></span><br><span class="line"><span class="built_in">print</span>(string.upper().isupper())</span><br></pre></td></tr></table></figure>
<h3 id="6-2-判断字符串内容">6.2 判断字符串内容</h3>
<p>判断内容是字母</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string.isalnum()  <span class="comment"># 如果 string 至少有一个字符并且所有字符都是字母或数字则返回True</span></span><br><span class="line">string.isalpha()  <span class="comment"># 如果 string 至少有一个字符并且所有字符都是字母则返回Tue</span></span><br></pre></td></tr></table></figure>
<p>判断内容是数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string.isdecimal()   <span class="comment"># 如果 string 只包含数字则返回 True（全角数字）</span></span><br><span class="line">string.isdigit()   <span class="comment"># string 只包含数字则返回 True（全角数字，①，\u002 平方符号²）</span></span><br><span class="line">string.isnumeric()  <span class="comment"># 如果 string 只包含数字则返回 True，全角数字，汉字数字</span></span><br></pre></td></tr></table></figure>
<p>判断内容大小写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string.istitle()  <span class="comment"># 判断 string 标题化（每个单词首字母大写）</span></span><br><span class="line">string.islower()  <span class="comment"># 判断 string 中字符是否都是小写</span></span><br><span class="line">string.isupper()  <span class="comment"># 判断 string 中字符是否都是大写</span></span><br></pre></td></tr></table></figure>
<p>判断空格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string.isspace()  <span class="comment"># 如果 string 中只包含空格，则返回 True</span></span><br><span class="line"><span class="comment"># 还可以判断包括空格在内的 \n \t \r</span></span><br></pre></td></tr></table></figure>
<p>判断数字函数的区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般编程只针对平常数字，建议使用此函数来判断数字</span></span><br><span class="line">string.isdecima()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以判断 unicode 数字，如①, /u00b2（平方符号²）</span></span><br><span class="line">string.isdigit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以判断 unicode 数字，如①, /u00b2（平方符号²）</span></span><br><span class="line"><span class="comment"># 还可以判断中文数字，如一千零一</span></span><br><span class="line">string.isnumber()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：三个函数不能判断小数</p>
</blockquote>
<h3 id="6-3-字符串搜索定位与替换">6.3 字符串搜索定位与替换</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.startswith(prefix[, start[, end]])  # 检查字符串是否已 prefix 起始</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str = &quot;this is string example....wow!!!&quot;</span><br><span class="line"># 字符串是否以 this 开头</span><br><span class="line">print (str.startswith( &#x27;this&#x27; ))</span><br><span class="line"># 从第八个字符开始的字符串是否以 string 开头   </span><br><span class="line">print (str.startswith( &#x27;string&#x27;, 8 ))  </span><br><span class="line"># 从第2个字符开始到第四个字符结束的字符串是否以 this 开头</span><br><span class="line">print (str.startswith( &#x27;this&#x27;, 2, 4 )) </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.endswith(suffix[, start[, end]])  # 是否已xxx为结尾</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 检查 str1 是否包含在 str 中（可指定范围），如果是则返回索引值，否则返回-1</span><br><span class="line">str.find(str1, start=0, end=len(str))  </span><br><span class="line">str.rfind(sub[, start[, end]])  # 类似 find 函数，从右侧开始找</span><br><span class="line">str.index(sub[, start[, end]])  # 类似 find 函数，如果没找到会报错</span><br><span class="line">str.rindex(sub[, start[, end]])  # 类似 index 函数，从右侧开始找</span><br><span class="line"></span><br><span class="line">str.replace(old, new[, count])  # 在 str 中将old替换成为new，替换不超过count次</span><br><span class="line">str.count(sub, start= 0,end=len(string))  # 统计sub在str中出现的次数</span><br><span class="line">len(str)  # 求 str 字符串长度</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>string.index() 和 string.find() 区别</strong></p>
<p>都是返回字符串索引位置，如果子字符串没有在源字符串中找到的话，那么index会报错，find会返回-1</p>
</blockquote>
<blockquote>
<p>string.replace() 会返回一个新的字符串，不会对源字符串进行修改。</p>
</blockquote>
<h3 id="6-4-文本对齐">6.4 文本对齐</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 返回一个原字符串左对齐，并使用空格（可用其他字符）填充至长度为 width 的新字符串</span><br><span class="line">str.ljust(width[, fillchar])  </span><br><span class="line">str.rjust(width[, fillchar])  # 右对齐</span><br><span class="line">str.center(width[, fillchar])  # 居中对齐</span><br><span class="line">str.zfill(width)  # 返回指定长度的字符串，原字符串右对齐，前面填充0</span><br></pre></td></tr></table></figure>
<h3 id="6-5-去除空白字符">6.5 去除空白字符</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.lstrip([chars])  # 去掉 str 左侧的空白字符</span><br><span class="line">str.rstrip([chars])  # 去掉 str 右侧的空白字符</span><br><span class="line">str.strip([chars])  # 去掉 str 两侧所有空格</span><br></pre></td></tr></table></figure>
<h3 id="6-6-字符串的联合与分割">6.6 字符串的联合与分割</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.join(iterable)  # 以 str 作为分隔符，将一个迭代元素合并成一个新字符串</span><br><span class="line"></span><br><span class="line">str.partition(sep)  # 把字符串str分成一个3元素的元组</span><br><span class="line">str = &quot;www.runoob.com&quot;</span><br><span class="line">print str.partition(&quot;.&quot;)  # 输出结果为 (&#x27;www&#x27;, &#x27;.&#x27;, &#x27;runoob.com&#x27;)</span><br><span class="line"></span><br><span class="line">str.rpartition(sep)  # 类似 partition() ，从右侧开始查找</span><br><span class="line"></span><br><span class="line">string.split(str=&quot;&quot;, num)  # 以 str 为分隔符切片 string</span><br><span class="line">string.rsplit(sep=None, maxsplit=-1)  # 从右侧开始分割</span><br><span class="line">string.splitlines()  # 按照(\r, \n) 分割，返回一个包含各行作为元素的列表</span><br></pre></td></tr></table></figure>
<h3 id="6-7-字符串编码">6.7 字符串编码</h3>
<p>以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.encode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="6-8-字符串切片">6.8 字符串切片</h3>
<p>sequence特性的数据对象 都支持 切片操作 ， 字符串是具有sequence特性的，当然也支持切片。</p>
<p>假想我们手里有把刀，要从下面的字符串中切出你好，就应该在箭头所示的地方切两刀，就得到 <code>你好</code> 这个子字符串了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/21.jpg" alt="img"></p>
<p>如果用正数表示就是 2 和 4 ， Python中可以用 hello[2:4] 这样的切片表达式来得到该字符串。 大家可以运行如下代码看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello = &#x27;刘总你好啊&#x27;</span><br><span class="line">print(hello[2:4])  # 输出你好</span><br></pre></td></tr></table></figure>
<p>当然也可以用负数表示， 就是 -3 和 -1 ， Python中可以用 hello[-3:-1] 这样的切片表达式来得到该字符串。 大家可以运行如下代码看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello = &#x27;刘总你好啊&#x27;</span><br><span class="line">print(hello[-3:-1])  # 输出你好</span><br></pre></td></tr></table></figure>
<p>省略切片索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello[2:]  # 输出你好啊</span><br><span class="line">hello[:-3]  # 输出刘总</span><br></pre></td></tr></table></figure>
<p>切片步数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str[start:stop:step]</span><br><span class="line">hello[0::2] # 输出刘你啊</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/79541418">https://zhuanlan.zhihu.com/p/79541418</a></p>
<h3 id="6-9-格式化字符串输出">6.9 格式化字符串输出</h3>
<h4 id="新版格式化输出方式">新版格式化输出方式</h4>
<p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。基本语法是通过 {} 和 : 来代替以前的 % 。format 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)    # 不设置指定位置，按默认顺序</span><br><span class="line">&#x27;hello world&#x27;</span><br><span class="line"></span><br><span class="line">&quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)  # 设置指定位置</span><br><span class="line">&#x27;hello world&#x27;</span><br><span class="line"></span><br><span class="line">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)  # 设置指定位置</span><br><span class="line">&#x27;world hello world&#x27;</span><br></pre></td></tr></table></figure>
<p>也可以设置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;))</span><br><span class="line"></span><br><span class="line"># 通过字典设置参数</span><br><span class="line">site = &#123;&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;&#125;</span><br><span class="line">print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(**site))</span><br><span class="line"></span><br><span class="line"># 通过列表索引设置参数</span><br><span class="line">my_list = [&#x27;菜鸟教程&#x27;, &#x27;www.runoob.com&#x27;]</span><br><span class="line">print(&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;.format(my_list))  # &quot;0&quot; 是必须的</span><br></pre></td></tr></table></figure>
<p>数字格式化<br>
下表展示了 str.format() 格式化数字的多种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;&#123;:.2f&#125;&quot;.format(3.1415926))</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/22.jpg" alt="img"></p>
<h4 id="旧版格式化输出方式">旧版格式化输出方式</h4>
<p>在 Python 可以使用 % 作为格式化操作符，专门用于处理字符串中的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%s  # 字符串</span><br><span class="line">%d  # 有符号十进制整数， %06d 表示输出的整数显示位数，不足的地方使用0补全</span><br><span class="line">%f  # 浮点数， %.02f 表示小数点后只显示两位</span><br><span class="line">%%  # 输出 %</span><br></pre></td></tr></table></figure>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;格式化字符串&quot; % 变量1)</span><br><span class="line">print(&quot;格式化字符串&quot; % (变量1, 变量2))  # 多个变量需要以元组的形式（加括号）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;我的名字叫%s&quot; % name)</span><br><span class="line">print(&quot;我卖的%06d号水果, 价格为%.02f每斤&quot; % (num, price))</span><br></pre></td></tr></table></figure>
<p>如果需要在格式化里做运算，需要用小括号，否则会造成字符串重复输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">percentage = 0.25</span><br><span class="line">print(&quot;利率为%.02f%%&quot; % (percentage * 100))</span><br></pre></td></tr></table></figure>
<p>%c是格式化字符串，中间的%是转义结束，后边括号是需要进行替换的字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;%c %c %c&quot; % (97,98,99))</span><br></pre></td></tr></table></figure>
<p>字符串格式化符号附录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%c 格式化字符及其 ASCII 码</span><br><span class="line">%s 格式化字符串</span><br><span class="line">%d 格式化整数</span><br><span class="line">%o 格式化无符号八进制数</span><br><span class="line">%x 格式化无符号十六进制数</span><br><span class="line">%X 格式化无符号十六进制数（大写）</span><br><span class="line">%f 格式化浮点数字，可指定小数点后的精度</span><br><span class="line">%e 用科学计数法格式化浮点数</span><br><span class="line">%E 作用同 %e，用科学计数法格式化浮点数</span><br><span class="line">%g 根据值的大小决定使用 %f 或 %e</span><br><span class="line">%G 作用同 %g，根据值的大小决定使用 %f 或者 %E</span><br></pre></td></tr></table></figure>
<p>格式化操作符辅助命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m.n 	m 是显示整个数值占位的最小总宽度，n 是小数点后的位数</span><br><span class="line">- 		用于左对齐</span><br><span class="line">+ 		在正数前面显示加号（+）</span><br><span class="line"># 		在八进制数前面显示 &#x27;0o&#x27;，在十六进制数前面显示 &#x27;0x&#x27; 或 &#x27;0X&#x27;</span><br><span class="line">0 		显示的数字前面填充 &#x27;0&#x27; 取代空格</span><br></pre></td></tr></table></figure>
<h3 id="6-10-Python-的转义字符">6.10 Python 的转义字符</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&#x27; 单引号</span><br><span class="line">\&quot; 双引号</span><br><span class="line">\a 发出系统响铃声</span><br><span class="line">\b 退格符</span><br><span class="line">\n 换行符</span><br><span class="line">\t 横向制表符（TAB）</span><br><span class="line">\v 纵向制表符</span><br><span class="line">\r 回车符</span><br><span class="line">\f 换页符</span><br><span class="line">\o 八进制数代表的字符</span><br><span class="line">\x 十六进制数代表的字符</span><br><span class="line">\0 表示一个空字符</span><br><span class="line">\\ 反斜杠</span><br></pre></td></tr></table></figure>
<p>输出带有单引号的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;Let&#x27;s Go&quot;)</span><br></pre></td></tr></table></figure>
<p>输出带有双引号的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;Tommy say &quot;What are you doing&quot;&#x27;)</span><br></pre></td></tr></table></figure>
<p>输出带有路径符号\的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;C:\\Temp&#x27;)</span><br><span class="line">print(r&#x27;C:\Temp&#x27;)  # r代表字符串中对\不进行转义</span><br></pre></td></tr></table></figure>
<p>输出多行文本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;&#x27;&#x27;</span><br><span class="line">多行文本</span><br><span class="line">多行文本</span><br><span class="line">多行文本</span><br><span class="line">多行文本</span><br><span class="line">&#x27;&#x27;&#x27;)</span><br></pre></td></tr></table></figure>
<h1>七、条件分支</h1>
<h2 id="1-If-条件判断">1. If 条件判断</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件表达式:</span><br><span class="line">	# 执行代码</span><br></pre></td></tr></table></figure>
<p>一般条件分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (is_male == true):</span><br><span class="line">    print(&quot;He is Male&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;He is not a Male&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：if 判断条件是否成立，如果成立则执行if代码，如果不成立则执行else代码</p>
</blockquote>
<h2 id="2-逻辑运算符">2. 逻辑运算符</h2>
<p>Python 中可以使用 and、or、not 三种逻辑运算符来把多个条件按照逻辑进行连接，变成更复杂的条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (is_male==True) and (is_tall==True):</span><br><span class="line">    print(&quot;He is qualified&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;He is not qualified&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="3-多分支语句">3. 多分支语句</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件1:</span><br><span class="line">    # 代码段1</span><br><span class="line">elif 条件2:</span><br><span class="line">    # 代码段2</span><br><span class="line">else:</span><br><span class="line">    # 上方条件都不满足，最终执行代码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>elif 可以看成 “否则的话，那么再如果”</p>
</blockquote>
<p>若全部用if语句，程序运行时会遍历所有if（不管每个if后的逻辑运算是否为True）。而用if-elif，程序运行时，只要if或后续某一个elif之一满足逻辑值为True，则程序执行完对应输出语句后自动结束该轮if-elif（即不会再去冗余地执行后续的elif或else）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = True</span><br><span class="line">b = True</span><br><span class="line">if a:</span><br><span class="line">    print(&quot;代码块1&quot;)</span><br><span class="line">if b:</span><br><span class="line">    print(&quot;代码块2&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码块1和代码块2都会被输出，而再想一下如果是使用elif:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = True</span><br><span class="line">b = True</span><br><span class="line">if a:</span><br><span class="line">    print(&quot;代码块1&quot;)</span><br><span class="line">elif b:</span><br><span class="line">    print(&quot;代码块2&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只会输出代码块1，而不会输出代码块2了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = False</span><br><span class="line">b = True</span><br><span class="line">if a:</span><br><span class="line">    print(&quot;代码块1&quot;)</span><br><span class="line">elif b:</span><br><span class="line">    print(&quot;代码块2&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出的话就是代码块2了，如果a不满足，继续判断，直到不满足所有的条件，输出else代码</p>
</blockquote>
<p>而嵌套则是相反的意思</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = True</span><br><span class="line">b = True</span><br><span class="line">if a:</span><br><span class="line">    print(&#x27;代码块1&#x27;)</span><br><span class="line">    if b:</span><br><span class="line">        print(&#x27;代码块2&#x27;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当满足a的条件，则继续向下判断。</p>
</blockquote>
<p>混合条件可以用 or、and、not 来作为条件连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">is_male=False</span><br><span class="line">is_tall=True</span><br><span class="line"></span><br><span class="line">if is_male and is_tall:</span><br><span class="line">    print(&quot;He is a Tall Male&quot;)</span><br><span class="line">elif is_male and not is_tall:</span><br><span class="line">    print(&quot;He is a Male but not Tall&quot;)</span><br><span class="line">elif not is_male and is_tall:</span><br><span class="line">    print(&quot;He is not a Male but Tall&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;He is not a Male and not Tall&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：if 判断条件是否成立，如果成立则执行if代码，如果不成立则继续判断elif代码，直到最后都判断完，执行else代码</p>
</blockquote>
<h2 id="4-数值区间判断">4.  数值区间判断</h2>
<p>不能写成 <code>percentage &gt;= 0  and percentage &lt;= 1</code>，需要写成如下格式，更精炼也更容易理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 0 &lt;= percentage &lt;= 1:</span><br><span class="line">    print(&quot;正确&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="5-三元操作符-三元表达式">5. 三元操作符/三元表达式</h2>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x if 条件表达式 else y</span><br></pre></td></tr></table></figure>
<p>普通 if 判断后赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x,y = 4,5</span><br><span class="line">if x&lt;y:</span><br><span class="line">small = x</span><br><span class="line">else:</span><br><span class="line">small = y</span><br></pre></td></tr></table></figure>
<p>用三元表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">small = x if (x&lt;y) else y</span><br></pre></td></tr></table></figure>
<h2 id="补充：随机数模块">补充：随机数模块</h2>
<p>Python 中生成一个随机数需要引入随机数的模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br></pre></td></tr></table></figure>
<p>Python 中生成一个随机数需要引入随机数的模块</p>
<p>导入模块后，可以在模块名称后边敲一个 <code>.</code> 然后按TAB键，会提示该模块中包含的所有函数，使用随机整数的方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">random.randint(a,b)  # 返回[a,b]之间的整数，包含a和b</span><br><span class="line">random.randint(1,10) # 返回10以内随机整数</span><br></pre></td></tr></table></figure>
<h1>八、循环语句</h1>
<h2 id="1-while-语句基本语法">1. while 语句基本语法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始条件设置  # 通常是计数器</span><br><span class="line">while 条件:</span><br><span class="line"> 循环体代码</span><br><span class="line"> 处理条件（终止条件）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输出1-9</span><br><span class="line"></span><br><span class="line">i = 1 </span><br><span class="line">while i &lt; 10:</span><br><span class="line">    print(i)</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure>
<h2 id="2-循环中断">2. 循环中断</h2>
<p>break 和 continue 是专门在循环中使用的关键字</p>
<ul>
<li>break 某一条件满足时，退出循环</li>
<li>continue 某一条件满足时，跳过此次循环，执行下一次循环</li>
</ul>
<h2 id="3-循环嵌套">3. 循环嵌套</h2>
<p>while 循环嵌套就是： while 里边还有 while</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while 条件1：</span><br><span class="line">    循环体</span><br><span class="line">    while 条件2：</span><br><span class="line">        循环体</span><br><span class="line">        处理条件2</span><br><span class="line">    处理条件1</span><br></pre></td></tr></table></figure>
<h2 id="4-for-遍历循环">4. for 遍历循环</h2>
<p>遍历就是从头到尾依次从列表中获取数据，在循环体内部针对每一个元素，执行相同的操作。使用 for 循环可以实现迭代遍历。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 循环变量 in 列表:</span><br><span class="line">    循环体</span><br></pre></td></tr></table></figure>
<p>遍历列表中每个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name_list = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]</span><br><span class="line">for i in name_list:</span><br><span class="line">    print(i, end=&#x27; &#x27;) #用空格隔开每次输出内容</span><br></pre></td></tr></table></figure>
<p>遍历字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in &quot;Total&quot;:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<h2 id="5-range-函数">5. range 函数</h2>
<p>python 中 range() 函数可创建一个整数列表，一般用在 for 循环中。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">range(start, stop[, step])</span><br></pre></td></tr></table></figure>
<p>start： 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;<br>
stop： 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5<br>
step： 步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</p>
<p>指定遍历次数（10次）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>输出3-6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in range(3,7):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>遍历数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">letters = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]</span><br><span class="line">for i in range(len(letters)):</span><br><span class="line">    print(letters[i])</span><br></pre></td></tr></table></figure>
<p>判断变量是否在字符串中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">letter = &quot;b&quot;</span><br><span class="line">if letter in &quot;AEIOUaeiou&quot;:</span><br><span class="line">    print(&quot;true&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;false&quot;)</span><br></pre></td></tr></table></figure>
<p>精简</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">letter = &quot;b&quot;</span><br><span class="line">if letter.lower() in &quot;aeiou&quot;:</span><br><span class="line">    print(&quot;true&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;false&quot;)</span><br></pre></td></tr></table></figure>
<p>生成整数列表</p>
<p>需要将 range 转换成列表才可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = range(10)</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list2 = list(range(10))</span><br><span class="line">print(list2)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">range(0, 10)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>九、函数 - Function</h1>
<h2 id="1-函数的定义">1. 函数的定义</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def 函数名():</span><br><span class="line"> 函数封装代码</span><br><span class="line"> return # 如果没有返回数值，可以没有 return</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有 Function Code 必须要有缩进Tab，定义名后要有冒号</p>
</blockquote>
<p>定义一个 say_hi 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def say_hi():</span><br><span class="line">    print(&quot;Hello&quot;)</span><br><span class="line">say_hi()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数体相对比较独立，在函数定义的上方，应该与其他代码保留2个空行</p>
</blockquote>
<h2 id="2-函数参数的使用">2. 函数参数的使用</h2>
<p>在函数名后边的小括号内部填写参数，多个参数会用逗号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def sum_2_num(num1, num2):</span><br><span class="line">    result = num1 + num2</span><br><span class="line">    print(&quot;%d + %d = %d&quot; % (num1, num2, result))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">sum_2_num(50,20)</span><br></pre></td></tr></table></figure>
<p>多参数的传值：<br>
参数传值需要按照定义参数的顺序来进行传值，如果顺序错了，则值就给错了。多参数环境下，记不住参数顺序可以直接给实参附上形参的名称来进行传参。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def sayhi(name, From):</span><br><span class="line">    print(name + &quot; Say hello from &quot; + From)</span><br><span class="line">sayhi(name=&quot;Li Lei&quot;, From=&quot;China&quot;)</span><br></pre></td></tr></table></figure>
<p>默认参数：<br>
定义函数的时候，可以给参数设定默认值，如果调用函数的时候没有传参，则默认使用定义参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def sayhi(name=&quot;Lee&quot;, isfrom=&quot;China&quot;):</span><br><span class="line">    print(&#x27;%s is from %s&#x27; % (name, isfrom))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sayhi()</span><br><span class="line"></span><br><span class="line"># 输出结果：</span><br><span class="line"># Lee is from China</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果有默认参数时，需要将默认参数放在最尾</p>
</blockquote>
<p>不指定参数数量：<br>
在定义函数参数的时候，如果不确定参数的数量，则在参数名前边加*号。这样用户传多少个值，这个函数就有多少个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def test(*params):</span><br><span class="line">    print(&#x27;参数长度是: &#x27;, len(params))</span><br><span class="line">    print(&#x27;第一个参数是: &#x27;, params[0])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test(1, &quot;Num&quot;, 2, 3, 4, 5, 8.8)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数名前增加一个 * ，可以接收元组，一般参数名为 *args<br>
参数名前增加两个 * ， 可以接收字典，一般参数名为 **kwargs</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def demo(num, *args, **kwargs):</span><br><span class="line">    print(num)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line">demo(1,2,3,4,5, name=&quot;小明&quot;, age=18, gender=True)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">(2, 3, 4, 5)</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: True&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-函数的文档注释">3. 函数的文档注释</h2>
<p>在开发中，如果希望给函数添加注释，应该定义在函数的下方，使用连续的三对双引号，在双引号体内部编写说明文字，以及参数说明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def say_hi(name):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    A function to say hello to someone</span><br><span class="line">    :param name: define a person&#x27;s name</span><br><span class="line">    :return: no return value</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&#x27;hi &#x27; + name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say_hi(&#x27;Lee&#x27;)</span><br></pre></td></tr></table></figure>
<p>查看函数文档注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">help(sayhi)</span><br><span class="line">print(sayhi.__doc__)</span><br></pre></td></tr></table></figure>
<h2 id="4-函数的返回值-return">4. 函数的返回值 return</h2>
<p>在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理。在函数中使用 return 关键字可以返回结果。可以使用变量来接收函数返回的结果。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/24.jpg" alt="img"></p>
<blockquote>
<p>当 return 代码执行完毕后，后续代码则不会被执行。代表该函数已经执行结束。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def sum_2_num(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  result = sum_2_num(50,20)</span><br><span class="line">  print(&#x27;计算结果是 %d&#x27; % result)</span><br></pre></td></tr></table></figure>
<p>return 的返回值可以是一个数据、一个函数，也可以是多个数据，当返回多个数据的时候，则以元组的形式返回，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def demo():</span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br><span class="line">    return a, b</span><br><span class="line"></span><br><span class="line">print(demo())</span><br><span class="line">print(type(demo()))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line"></span><br><span class="line">(1, 2)</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>返回值是列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def r():</span><br><span class="line">    return [1,3,4,5]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为列表其实只是一个变量，里边包含多个元素而已，其实返回的还是一个变量，不算多个变量</p>
</blockquote>
<p>当返回多个变量时，可以分别用两个变量接受这个返回值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def r():</span><br><span class="line">    return 1, 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a, b = r()</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="补充：a，b-值互换面试题">补充：a，b 值互换面试题</h2>
<p>解法1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c = a</span><br><span class="line">a = b</span><br><span class="line">b = c</span><br></pre></td></tr></table></figure>
<p>解法2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br></pre></td></tr></table></figure>
<p>画图解释， 小方框代表a，大方框代表b</p>
<p>第一步：a = a + b</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/25.jpg" alt="img"></p>
<blockquote>
<p>a 的值变为了 a + b 两个值的和</p>
</blockquote>
<p>第二步：b = a - b</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/26.jpg" alt="img"></p>
<blockquote>
<p>b 的值变为了两个值得和减去之前b的值，就变成了a的值，完成了 b = a 的操作</p>
</blockquote>
<p>第三步：a = a - b</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/27.jpg" alt="img"></p>
<blockquote>
<p>此时 a 的值还是两个值得和，b 已经变成了a，那么用两个值得和减去已经变为a的b，就得出b的值了。</p>
</blockquote>
<p>解法3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>
<p>和函数返回值一样，利用多个变量接收函数的的多个返回值，函数的返回值为多个元素的时候，是一个元组。</p>
<h2 id="5-其他函数">5. 其他函数</h2>
<h3 id="dir-函数">dir() 函数</h3>
<p>列出类或对象中所有属性和方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(dir(list))</span><br></pre></td></tr></table></figure>
<h3 id="chr-ord">chr(), ord()</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将字符转换为ASCII</span><br><span class="line">print(chr(97))</span><br><span class="line"></span><br><span class="line"># 将ASCII转换为数字</span><br><span class="line">print(ord(&#x27;a&#x27;))</span><br></pre></td></tr></table></figure>
<p>进制转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin(obj)  # 二进制</span><br><span class="line">oct(obj)  # 八进制</span><br><span class="line">hex(obj)  # 十六进制</span><br></pre></td></tr></table></figure>
<h3 id="abs-绝对值函数">abs() 绝对值函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 求 -5 的绝对值</span><br><span class="line">print(abs(-5))</span><br></pre></td></tr></table></figure>
<h3 id="pow-幂运算函数">pow() 幂运算函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 求2的3次方</span><br><span class="line">print(pow(2,3))</span><br></pre></td></tr></table></figure>
<h3 id="max-最大值函数">max() 最大值函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(max(3,5,8,9))</span><br></pre></td></tr></table></figure>
<h3 id="min-最小值函数">min() 最小值函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(min(2,6))</span><br></pre></td></tr></table></figure>
<h3 id="round-函数">round() 函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 四舍五入（取整）</span><br><span class="line">print(round(3.8))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 四舍五入（保留1位小数）</span><br><span class="line">print(round(3.48,1))</span><br></pre></td></tr></table></figure>
<h3 id="math-库数学函数">math 库数学函数</h3>
<p>除了默认的一些数学函数外，python 还提供了 math 模块，提供更多的数学计算函数，在使用这些函数前，需要先引入 math 模块。<br>
from math import *</p>
<h4 id="floor-函数">floor() 函数</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 向下取整</span><br><span class="line">print(math.floor(3.7))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line"># 3</span><br></pre></td></tr></table></figure>
<h4 id="ceil-函数">ceil() 函数</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 向上取整</span><br><span class="line">print(math.ceil(3.7))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line"># 4</span><br></pre></td></tr></table></figure>
<h4 id="sqrt-函数">sqrt() 函数</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#求平方根</span><br><span class="line">print(sqrt(36))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line"># 6.0</span><br></pre></td></tr></table></figure>
<h2 id="6-嵌套函数">6. 嵌套函数</h2>
<p>嵌套函数，就是一个函数中包含另外一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    print(&quot;this is fun1&quot;)</span><br><span class="line">    def fun2():</span><br><span class="line">        print(&quot;this is fun2&quot;)</span><br><span class="line">    fun2()  # 在 fun1 中调用 fun2 函数</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是fun2()无法在外边进行调用，因为 fun2 属于局部变量，执行完 fun1，fun2 就被回收了</p>
</blockquote>
<p><strong>闭包基础</strong></p>
<p>把一个函数当做另外一个函数的返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    print(&#x27;我是fun1，我被调用了&#x27;)</span><br><span class="line">    return &#x27;fun1&#x27;</span><br><span class="line"></span><br><span class="line">def fun2():</span><br><span class="line">    print(&#x27;我是fun2，我被调用了&#x27;)</span><br><span class="line">    return fun1()</span><br><span class="line"></span><br><span class="line">x = fun2()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当进行赋值的时候，会执行 fun2() 时，fun1 也会被调用，最后 x 的值是 fun1 的返回值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    print(&#x27;我是fun1，我被调用了&#x27;)</span><br><span class="line">    return &#x27;fun1&#x27;</span><br><span class="line"></span><br><span class="line">def fun2():</span><br><span class="line">    print(&#x27;我是fun2，我被调用了&#x27;)</span><br><span class="line">    return fun1</span><br><span class="line"></span><br><span class="line">x = fun2()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进行赋值的时候，会将fun2的返回值给x，而fun2的返回值是fun1函数的内存地址，所以fun1不会被执行。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    print(&#x27;我是fun1，我被调用了&#x27;)</span><br><span class="line">    return &#x27;fun1&#x27;</span><br><span class="line"></span><br><span class="line">def fun2():</span><br><span class="line">    print(&#x27;我是fun2，我被调用了&#x27;)</span><br><span class="line">    return fun1</span><br><span class="line"></span><br><span class="line">x = fun2()</span><br><span class="line"></span><br><span class="line"># 此时x相当于fun1，所以x()就相当于fun1()</span><br><span class="line">x()</span><br><span class="line"></span><br><span class="line"># 先调用fun2，然后再调用 fun1</span><br><span class="line">fun2()()</span><br></pre></td></tr></table></figure>
<p>闭包应用</p>
<p>闭包概念：在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。简单来说就是有一个嵌套函数，然后内部函数需要引用一个外部变量，并且外部函数的返回值是这个内部函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun1(x):</span><br><span class="line">    print(x)</span><br><span class="line">    def fun2(y):</span><br><span class="line">        print(y)</span><br><span class="line">        return x * y</span><br><span class="line"></span><br><span class="line">    return fun2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = fun1(5)  # 调用fun1函数，给5传参给fun1的形参x，但是 fun1 的返回值是 fun2，所以 i 其实是 fun2()</span><br><span class="line">print(i(6)) # 调用 i(6)，相当于 fun2(6)，这样两个形参都有值了，x=5，y=6</span><br><span class="line">print(fun1(5)(6)) # 同理，fun1(5) 返回值是 fun2(),所以 fun1(5)(6) 可以看做 fun2(6)</span><br></pre></td></tr></table></figure>
<p>闭包函数中调用外层函数中的变量，需要加 nonlocal 声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    x=5</span><br><span class="line">    def fun2():</span><br><span class="line">    	# 这里让x变量不再重新声明一个新变量，而是使用外部函数中的变量</span><br><span class="line">        nonlocal x</span><br><span class="line">        x*=x</span><br><span class="line">        return x</span><br><span class="line">    return fun2()</span><br><span class="line">print(fun1())</span><br></pre></td></tr></table></figure>
<p><strong>计算代码运行时间</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">x = 0</span><br><span class="line">for i in range(1,10000000):</span><br><span class="line">    x += i</span><br><span class="line">print(x)</span><br><span class="line">end = time.time()</span><br><span class="line">print(&#x27;代码运行时间为&#123;&#125;&#x27;.format(end - start))</span><br></pre></td></tr></table></figure>
<p>写成函数来计算时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def calc_time(fn):</span><br><span class="line">    start = time.time()</span><br><span class="line">    fn()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;代码运行时间为&#123;&#125;&#x27;.format(end - start))</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    x = 0</span><br><span class="line">    for i in range(1,10000000):</span><br><span class="line">        x += i</span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line">calc_time(test)</span><br></pre></td></tr></table></figure>
<p>装饰器也是闭包的一种应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def calc_time(fn):</span><br><span class="line">    def inner():</span><br><span class="line">        start = time.time()</span><br><span class="line">        fn()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(&#x27;代码运行时间为&#123;&#125;&#x27;.format(end - start))</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"># 1. 自动调用 calc_time 函数</span><br><span class="line"># 2. 并且将被装饰的函数以参数形式传递给 calc_time 函数</span><br><span class="line">@calc_time</span><br><span class="line">def test():</span><br><span class="line">    x = 0</span><br><span class="line">    for i in range(1,10000000):</span><br><span class="line">        x += i</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"># 此时 test 函数已经被装饰。变成了 inner 函数</span><br><span class="line"># @calc_time 的意义 test = calc_time(test)</span><br><span class="line"># calc_time(test) 的返回值是 inner</span><br><span class="line"># test() 就相当于 inner()</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>装饰器一般应用在不改动原代码的情况下，给代码添加新功能，比如原代码中只显示时间，需要在不改动原代码的情况下，让同样的函数前边加上当地时间四个字。</p>
<p>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def getXXXTime():</span><br><span class="line">    return time.strftime(&#x27;%Y_%m_%d %H:%M:%S&#x27;,time.localtime())</span><br><span class="line"></span><br><span class="line">print (getXXXTime())  </span><br></pre></td></tr></table></figure>
<p>装饰器修改代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 定义一个装饰器函数</span><br><span class="line">def sayLocal(func):</span><br><span class="line">    def wrapper():</span><br><span class="line">        curTime = func()</span><br><span class="line">        return f&#x27;当地时间： &#123;curTime&#125;&#x27;</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">def getXXXTime():</span><br><span class="line">    return time.strftime(&#x27;%Y_%m_%d %H:%M:%S&#x27;,time.localtime())</span><br><span class="line"></span><br><span class="line"># 装饰 getXXXTime</span><br><span class="line">getXXXTime = sayLocal(getXXXTime)</span><br><span class="line"></span><br><span class="line">print (getXXXTime())  </span><br></pre></td></tr></table></figure>
<p>可以更简便的以 <code>@sayLocal</code> 开头后面接装饰器函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def sayLocal(func):</span><br><span class="line">    def wrapper():</span><br><span class="line">        curTime = func()</span><br><span class="line">        return f&#x27;当地时间： &#123;curTime&#125;&#x27;</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@sayLocal</span><br><span class="line">def getXXXTime():</span><br><span class="line">    return time.strftime(&#x27;%Y_%m_%d %H:%M:%S&#x27;,time.localtime())</span><br><span class="line"></span><br><span class="line">print (getXXXTime())  </span><br></pre></td></tr></table></figure>
<p><strong>带返回值函数的装饰器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def calc_time(fn):</span><br><span class="line">    def inner():</span><br><span class="line">        start = time.time()</span><br><span class="line">        fn()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(&#x27;代码运行时间为&#123;&#125;&#x27;.format(end - start))</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@calc_time</span><br><span class="line">def test():</span><br><span class="line">    x = 0</span><br><span class="line">    for i in range(1,10000000):</span><br><span class="line">        x += i</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line"># 这时候输出的test函数运行结果是空，因为test()已经不是调用test()了，调用的是calc_time(test)，</span><br><span class="line"># 所以返回值是 inner 函数的运行结果，而inner没有返回值，所以是空</span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure>
<p>修改代码，我们只需要让 inner 函数有返回值，就可以输出 calc_time(test) 函数的返回值了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def calc_time(fn):</span><br><span class="line">    def inner():</span><br><span class="line">        start = time.time()</span><br><span class="line">        s = fn()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(&#x27;代码运行时间为&#123;&#125;&#x27;.format(end - start))</span><br><span class="line">        return s</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@calc_time</span><br><span class="line">def test():</span><br><span class="line">    x = 0</span><br><span class="line">    for i in range(1,10000000):</span><br><span class="line">        x += i</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure>
<p><strong>带参数的函数装饰器</strong></p>
<p>需要将 inner，fn，都加上参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def calc_time(fn):</span><br><span class="line">    def inner(x):</span><br><span class="line">        start = time.time()</span><br><span class="line">        s = fn(x)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(&#x27;代码运行时间为&#123;&#125;&#x27;.format(end - start))</span><br><span class="line">        return s</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@calc_time</span><br><span class="line">def test(n):</span><br><span class="line">    x = 0</span><br><span class="line">    for i in range(1,n):</span><br><span class="line">        x += i</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(test(10000000))</span><br></pre></td></tr></table></figure>
<p>传不确定参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def play_limit(fn):</span><br><span class="line">    def inner(x, y, *args, **kwargs):</span><br><span class="line">        if args[0] &lt;= 22:</span><br><span class="line">            fn(x,y)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;太晚了，赶紧睡&#x27;)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@play_limit</span><br><span class="line">def play_game(name, game):</span><br><span class="line">    print(&#x27;&#123;&#125;正在玩&#123;&#125;&#x27;.format(name, game))</span><br><span class="line"></span><br><span class="line">play_game(&#x27;张三&#x27;,&#x27;王者荣耀&#x27;, 23)</span><br></pre></td></tr></table></figure>
<p>传字典参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def play_limit(fn):</span><br><span class="line">    def inner(x, y, *args, **kwargs):</span><br><span class="line">        if kwargs[&#x27;clock&#x27;] &lt;= 22:</span><br><span class="line">            fn(x,y)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;太晚了，赶紧睡&#x27;)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@play_limit</span><br><span class="line">def play_game(name, game):</span><br><span class="line">    print(&#x27;&#123;&#125;正在玩&#123;&#125;&#x27;.format(name, game, clock=18))</span><br><span class="line"></span><br><span class="line">play_game(&#x27;张三&#x27;,&#x27;王者荣耀&#x27;, clock=23)</span><br></pre></td></tr></table></figure>
<p>建议不要用 kwargs[‘index’]形式获取value值，如果没有传参的话，会被报错，建议用 kwargs.get(‘clock’) 来代替。并且可以设置默认值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def play_limit(fn):</span><br><span class="line">    def inner(x, y, *args, **kwargs):</span><br><span class="line">        if kwargs.get(&#x27;clock&#x27;, 23) &lt;= 22:</span><br><span class="line">            fn(x,y)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;太晚了，赶紧睡&#x27;)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@play_limit</span><br><span class="line">def play_game(name, game):</span><br><span class="line">    print(&#x27;&#123;&#125;正在玩&#123;&#125;&#x27;.format(name, game, clock=18))</span><br><span class="line"></span><br><span class="line">play_game(&#x27;张三&#x27;,&#x27;王者荣耀&#x27;)</span><br></pre></td></tr></table></figure>
<p>即使这样，我们还是需要在源代码中修改一下传入新参数。装饰器可以做到对源代码不做任何修改的进行传参。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def play_limit(clock):</span><br><span class="line">    def handle_action(fn):</span><br><span class="line">        def do_action(name,game):</span><br><span class="line">            if clock &lt;21:</span><br><span class="line">                fn(name,game)</span><br><span class="line">            else:</span><br><span class="line">                print(&#x27;太晚了，不能玩游戏&#x27;)</span><br><span class="line">        return do_action</span><br><span class="line">    return handle_action</span><br><span class="line"></span><br><span class="line">@play_limit(22)</span><br><span class="line">def play_game(name, game):</span><br><span class="line">    print(&#x27;&#123;&#125;正在玩&#123;&#125;&#x27;.format(name, game))</span><br><span class="line"></span><br><span class="line">play_game(&#x27;张三&#x27;,&#x27;王者荣耀&#x27;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多嵌套了一层，相当于将 play_game = play_limit(22)(play_game)</p>
</blockquote>
<ul>
<li>play_game = play_limit(22) 拿到了返回值 handle_action，这时候 play_game 就变成了 handle_action 函数的内存地址</li>
<li>然后再用 handle_action(play_game)，返回值是 do_action，两层嵌套下来，play_game 就变成了 do_action</li>
</ul>
<p>查看用户权限应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user_permission = 15</span><br><span class="line"></span><br><span class="line">DEL_PERMISSION = 8  # 1000</span><br><span class="line">READ_PERMISSION = 4  # 0100</span><br><span class="line">WRITE_PERMISSION = 2  # 0010</span><br><span class="line">EXE_PERMISSION = 1  # 0001</span><br><span class="line"></span><br><span class="line">def check_permission(x,y):</span><br><span class="line">    def handle_action(fn):</span><br><span class="line">        def do_action():</span><br><span class="line">            if x &amp; y !=0:  # 有权限，可以执行</span><br><span class="line">                fn()</span><br><span class="line">            else:</span><br><span class="line">                print(&#x27;对不起，您没有相应的权限&#x27;)</span><br><span class="line">        return do_action</span><br><span class="line">    return handle_action</span><br><span class="line"></span><br><span class="line">@check_permission(user_permission, READ_PERMISSION)</span><br><span class="line">def read():</span><br><span class="line">    print(&#x27;有读取权限&#x27;)</span><br><span class="line"></span><br><span class="line">@check_permission(user_permission, WRITE_PERMISSION)</span><br><span class="line">def write():</span><br><span class="line">    print(&#x27;有写入权限&#x27;)</span><br><span class="line"></span><br><span class="line">@check_permission(user_permission, EXE_PERMISSION)</span><br><span class="line">def exe():</span><br><span class="line">    print(&#x27;有执行权限&#x27;)</span><br><span class="line"></span><br><span class="line">@check_permission(user_permission, DEL_PERMISSION)</span><br><span class="line">def delete():</span><br><span class="line">    print(&#x27;有删除权限&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read()</span><br><span class="line">write()</span><br><span class="line">exe()</span><br><span class="line">delete()</span><br></pre></td></tr></table></figure>
<h2 id="7-匿名函数-lambda">7. 匿名函数 lambda</h2>
<p>函数的赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    return 1+2</span><br><span class="line"></span><br><span class="line">add = fun1</span><br><span class="line">print(add())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>赋值语句 x = y，其实就是把 y 的地址给x。而函数也是一样，将自身函数的内存地址告诉一个变量。相当于给原函数起了一个别名</p>
<p>add = fun1() 和 add = fun1 是不同的，一个是获得fun1的返回值，另外一个是获得fun1的内存地址。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/28.jpg" alt="image-20200805172218408"></p>
<p>也可以用 id 方法来查看两个函数的内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(id(fun1))</span><br><span class="line">print(id(add))</span><br></pre></td></tr></table></figure>
<p>定义一个lambda函数，冒号左边为参数，右侧为返回值，因为匿名函数没有名字，所以还需要将匿名函数的内存地址给一个变量，这样才可以调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = lambda x:x+10</span><br><span class="line">print(a(5))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>多参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = lambda x,y:x+y</span><br><span class="line">print(a(3,4))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>匿名函数的常用应用场景是将自身作为参数放在另外一个函数当中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def calc(x, y, fn):</span><br><span class="line">    return fn(x,y)</span><br><span class="line">x = calc(10, 5, lambda x, y: x+y)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>求10以内奇数，将迭代类型传入函数x%2,余数为1则为true，用filter过滤掉为false结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(list(filter(lambda x:x%2,range(10))))</span><br></pre></td></tr></table></figure>
<p>map函数，将迭代类型的数据传入函数中，进行x*2，并返还</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(list(map(lambda x:x*2,range(10))))</span><br></pre></td></tr></table></figure>
<h2 id="8-递归函数">8. 递归函数</h2>
<p>递归函数就是函数调用自身的一种编程技巧，函数内部的代码是相同的，只是针对参数不同，处理的结果也不同，当参数满足一个条件时，函数不再执行。一般这个条件通常被称为递归的出口。否则会出现死循环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def sum_numbers(num):</span><br><span class="line">    print(num)</span><br><span class="line">    if num == 1:</span><br><span class="line">        return</span><br><span class="line">    sum_numbers(num - 1)</span><br><span class="line">sum_numbers(3)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/29.jpg" alt="img"></p>
<p>阶乘例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun(n):</span><br><span class="line">    # 因为range(1,n)不包括n，所以需要先弄一个result=n</span><br><span class="line">    result=n</span><br><span class="line">    for i in range(1,n):</span><br><span class="line">        result *= i</span><br><span class="line">    return result</span><br><span class="line">print(fun(5))</span><br></pre></td></tr></table></figure>
<p>递归阶乘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun(n):</span><br><span class="line">    if n==1:</span><br><span class="line">        return n</span><br><span class="line">    else:</span><br><span class="line">        return n*fun(n-1)</span><br><span class="line">print(fun(5))</span><br></pre></td></tr></table></figure>
<p>解释：<br>
fun(5) = 5 * fun(4)<br>
fun(4) = 4 * fun(3)<br>
fun(3) = 3 * fun(2)<br>
fun(2) = 2 * (fun1)<br>
fun(1) = 1</p>
<h1>十、列表（list）</h1>
<p>在 Python 中，字符串、列表、元组、字典这些变量有公用的特点：</p>
<ul>
<li>都是一个序列（sequence），也可以理解为容器</li>
<li>可以用[]取值</li>
<li>可以用 for in 遍历</li>
<li>可以计算长度、最大/最小值、比较、删除元素操作</li>
<li>可以用 + 链接，也可以用 * 重复元素</li>
<li>可以切片</li>
</ul>
<h2 id="1-列表的定义">1. 列表的定义</h2>
<p>列表（list）是 Python 中使用最频繁的数据类型，在其他语言中通常叫做数组，列表用于存储一串信息（多个变量）。列表用 [] 定义，数据之间用逗号分隔。列表的索引从0开始。</p>
<blockquote>
<p>索引就是数据在列表中的位置编号，索引又可以被称为下标，如果从列表中取值时，超出索引范围，程序会报错。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name_list = [&#x27;Zhang&#x27;, &#x27;Li&#x27;, &#x27;Zhao&#x27;]</span><br><span class="line">print(name_list[0])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">Zhang</span><br></pre></td></tr></table></figure>
<p>Python 中的数组不仅仅可以插入同类型数据，也可以混合数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">friend = [&quot;Kevin&quot;, &quot;Tom&quot;, &quot;John&quot;, 123, False]</span><br></pre></td></tr></table></figure>
<h2 id="2-列表的取值">2. 列表的取值</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义一个列表</span><br><span class="line">friend = [&quot;Kevin&quot;, &quot;Tom&quot;, &quot;John&quot;]</span><br><span class="line"></span><br><span class="line"># 输出整个数组</span><br><span class="line">print(friend)</span><br><span class="line"></span><br><span class="line"># 输出数组中第一个组成员</span><br><span class="line">print(friend[0])</span><br><span class="line"></span><br><span class="line"># 输出数组中最后一个组成员</span><br><span class="line">print(friend[-1])</span><br><span class="line"></span><br><span class="line"># 输出从第2到最后一个成员</span><br><span class="line">print(friend[1:])</span><br><span class="line"></span><br><span class="line"># 输出第2到第3个成员</span><br><span class="line">print(friend[1:3])</span><br><span class="line"></span><br><span class="line"># 数组里边值总计</span><br><span class="line">print(sum([1,2,3,4,5]))</span><br></pre></td></tr></table></figure>
<h2 id="3-添加列表元素">3. 添加列表元素</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 向原数组增加另一个数组</span><br><span class="line">friend.extend(num)</span><br><span class="line"></span><br><span class="line"># 同一数组中增加成员</span><br><span class="line">friend.append(&quot;Jenny&quot;)</span><br><span class="line"></span><br><span class="line"># 在第二个位置插入新成员</span><br><span class="line">friend.insert(1,&quot;Sam&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="4-删除列表元素">4. 删除列表元素</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从数组中移除 Kevin </span><br><span class="line">friend.remove(&quot;Kevin&quot;)</span><br><span class="line"></span><br><span class="line"># 删除数组</span><br><span class="line">del friend</span><br><span class="line">del friend[0]</span><br><span class="line"></span><br><span class="line">#  从数组中移除最后一个成员，有返回值，返回值就是最后一个成员</span><br><span class="line">friend.pop()</span><br><span class="line"></span><br><span class="line"># pop加参数，剔除第二个成员</span><br><span class="line">friend.pop(1)</span><br><span class="line"></span><br><span class="line"># 清空数组</span><br><span class="line">friend.clear()</span><br></pre></td></tr></table></figure>
<h2 id="5-查看列表元素">5. 查看列表元素</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看Tom处于数组中的位置</span><br><span class="line">print(friend.index(&quot;Tom&quot;))</span><br><span class="line"></span><br><span class="line"># 在数组列表中第2到第8位中判断Tom的序号</span><br><span class="line">print(friend.index(&quot;Tom&quot;,1,8)</span><br><span class="line"></span><br><span class="line"># 判断是否存在</span><br><span class="line">print(&#x27;Kevin&#x27; in friend)</span><br><span class="line">print(&#x27;Jane&#x27; in friend)</span><br><span class="line"></span><br><span class="line"># 统计数组中John的数量</span><br><span class="line">print(friend.count(&quot;John&quot;))</span><br></pre></td></tr></table></figure>
<h2 id="6-列表的排序">6. 列表的排序</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 正序排列</span><br><span class="line">friend.sort()</span><br><span class="line"></span><br><span class="line"># 降序排列</span><br><span class="line">friend.sort(reverse=True)</span><br><span class="line"></span><br><span class="line"># 反向排列</span><br><span class="line">friend.reverse()</span><br></pre></td></tr></table></figure>
<h2 id="7-多个列表的操作">7. 多个列表的操作</h2>
<p>合并列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 运算符 + 合并数组</span><br><span class="line">alist = [1, 2, 3]</span><br><span class="line">blist = [4, 5, 6]</span><br><span class="line">clist = alist + blist</span><br><span class="line">print(clist)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 内建方法 extend() 扩展数组</span><br><span class="line">alist = [1, 2, 3]</span><br><span class="line">blist = [4, 5, 6]</span><br><span class="line">alist.extend(blist)</span><br><span class="line">print(alist)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>+ 和 extend() 的区别，+ 会生成一个新的变量，而 extend 则是在原有的列表基础上进行扩展。</p>
</blockquote>
<p>复制列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">friend2 = friend.copy()</span><br><span class="line">friend2 = friend[:]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组中复制是创建一个新的数组，如果用 = 的话，类似指针，指向同一个地址</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blist = alist</span><br><span class="line"></span><br><span class="line">print(blist)</span><br><span class="line">print(id(alist))</span><br><span class="line">print(id(blist))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">[1, 2, 3]</span><br><span class="line">17150984</span><br><span class="line">17150984</span><br></pre></td></tr></table></figure>
<blockquote>
<p>copy() 方法只是浅拷贝（只会复制第一层数组，如果多层数组嵌套则需要使用深拷贝方法 copy.deepcopy() ，需要引入 copy 模块</p>
</blockquote>
<p>可以去 <a target="_blank" rel="noopener" href="http://www.pythontutor.com/visualize.html">http://www.pythontutor.com/visualize.html</a> 来查看数据的可视化分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">list1 = [&#x27;a&#x27;,[1,2,3],&#x27;b&#x27;,&#x27;c&#x27;]</span><br><span class="line">list2 = list1.copy()</span><br><span class="line">list3 = copy.deepcopy(list1)</span><br></pre></td></tr></table></figure>
<p>数组比较运算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1, 2, 3]</span><br><span class="line">blist = [4, 5, 6]</span><br><span class="line">print(alist &lt; blist)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组中比较大小，比较第一个成员大小</p>
</blockquote>
<h2 id="8-列表推导式">8. 列表推导式</h2>
<p>如果想遍历一个列表，一般写法是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [1,2,3,4,5,6]</span><br><span class="line">list2 = []</span><br><span class="line">for num in list1:</span><br><span class="line">    list2.append(num*num)</span><br></pre></td></tr></table></figure>
<p>使用列表推导式可以写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [1,2,3,4,5,6] </span><br><span class="line">list2 = [num**2 for num in list1]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前边是一个函数的返回值，后边为 for in 遍历语句，遍历后返回的数值保存在 list2 列表中</p>
</blockquote>
<p>列表推导式还可以添加其他条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [i for i in range(10) if i % 2 == 0]</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure>
<p>进阶1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [(x, y) for x in range(5, 9) for y in range(10, 20)]</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for x in range(5, 9):</span><br><span class="line">    for y in range(10, 20):</span><br><span class="line">        list2.append((x, y))</span><br></pre></td></tr></table></figure>
<p>进阶2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m = [i for i in range(0, 100)]</span><br><span class="line">n = [m[j:j+3] for j in range(1, 100, 3)]</span><br></pre></td></tr></table></figure>
<h3 id="9-字符串切片">9. 字符串切片</h3>
<p>sequence特性的数据对象 都支持 切片操作 ， 字符串是具有sequence特性的，当然也支持切片。</p>
<p>假想我们手里有把刀，要从下面的字符串中切出你好，就应该在箭头所示的地方切两刀，就得到 <code>你好</code> 这个子字符串了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/30.jpg" alt="img"></p>
<p>如果用正数表示就是 2 和 4 ， Python中可以用 hello[2:4] 这样的切片表达式来得到该字符串。 大家可以运行如下代码看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello = &#x27;刘总你好啊&#x27;</span><br><span class="line">print(hello[2:4])  # 输出你好</span><br></pre></td></tr></table></figure>
<p>当然也可以用负数表示， 就是 -3 和 -1 ， Python中可以用 hello[-3:-1] 这样的切片表达式来得到该字符串。 大家可以运行如下代码看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello = &#x27;刘总你好啊&#x27;</span><br><span class="line">print(hello[-3:-1])  # 输出你好</span><br></pre></td></tr></table></figure>
<p>省略切片索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello[2:]  # 输出你好啊</span><br><span class="line">hello[:-3]  # 输出刘总</span><br></pre></td></tr></table></figure>
<p>切片步数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str[start:stop:step]</span><br><span class="line">hello[0::2] # 输出刘你啊</span><br></pre></td></tr></table></figure>
<h1>十一、常量，元组（tuple）</h1>
<h2 id="1-创建元组">1. 创建元组</h2>
<p>Tuple（元组）与列表类似，不同之处在于元组的元素不能修改。元组用()定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new_tuple = (1,2,3,4,5)</span><br></pre></td></tr></table></figure>
<p>元组中只包含一个元素的时候，需要在元素后边添加逗号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">single_tuple = (1,)</span><br></pre></td></tr></table></figure>
<p>数组中的元组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">coordinates = [(3,4),(3,2),(3,1)]</span><br></pre></td></tr></table></figure>
<h2 id="2-访问元组">2. 访问元组</h2>
<p>元组可以使用下标索引来访问元组中的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(coordinates[0])  # 用索引取值</span><br><span class="line">print(new_tuple[1:4])  # 用切片取值</span><br></pre></td></tr></table></figure>
<h2 id="3-修改元组">3. 修改元组</h2>
<p>元组中的元素无法修改，可以用特殊方法重新赋值，或者拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">member = (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;)</span><br><span class="line">member = member[:1] + (&#x27;1.1&#x27;,) + member[1:]  # 在第一个元素后插入新元素</span><br><span class="line">print(member)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">(&#x27;1&#x27;, &#x27;1.1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">member1 = (1,2,3)</span><br><span class="line">member2 = (4,5,6)</span><br><span class="line">member3 = member1 + member2</span><br><span class="line">print(member3)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">(1, 2, 3, 4, 5, 6)</span><br></pre></td></tr></table></figure>
<h2 id="4-删除元组">4. 删除元组</h2>
<p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tup = (&#x27;physics&#x27;, &#x27;chemistry&#x27;, 1997, 2000)</span><br><span class="line">del tup</span><br></pre></td></tr></table></figure>
<h2 id="5-列表、元组、字符串互相转换">5. 列表、元组、字符串互相转换</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(1,2,3,4,5)</span><br><span class="line">tuple[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<h2 id="6-应用场景">6. 应用场景</h2>
<p>尽管可以使用 for in 遍历元组，但是在开发过程中，更多的应用场景是返回值，如函数有多个返回值，用逗号隔开，则返回的值就是元组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    num1 = 1</span><br><span class="line">    num2 = 2</span><br><span class="line">    return num1, num2</span><br><span class="line">    </span><br><span class="line">print(fun1())</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">(1, 2)</span><br></pre></td></tr></table></figure>
<p>另外格式化字符串，后边的括号本质上也是一个元组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info = (&quot;zhangsan&quot;, 18)</span><br><span class="line">print(&quot;%s is %d years old&quot; % info)</span><br></pre></td></tr></table></figure>
<h1>十二、字典（Dictionary）：Key+Value</h1>
<p>字典是除列表以外 Python 中最灵活的数据类型，字典同样可以用来存储多个数据。字典用 {} 定义，字典使用键值对存储数据，键值对之间使用逗号分隔。</p>
<p>字典和列表的区别：</p>
<ul>
<li>列表是有序的对象集合</li>
<li>字典是无序的对象集合</li>
</ul>
<h2 id="1-创建字典">1. 创建字典</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xiaoming = &#123;&quot;name&quot;:&quot;xiaoming&quot;,</span><br><span class="line">            &quot;age&quot;:18,</span><br><span class="line">            &quot;gender&quot;:&quot;Male&quot;,</span><br><span class="line">            &quot;height&quot;:1.75&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/31.jpg" alt="image-20200716125858640"></p>
<blockquote>
<p>键 key 是索引<br>
值 value 是数据<br>
键和值之间使用冒号分割<br>
键必须是唯一的<br>
值可以取任何数据类型，但键只能使用字符串、数字或元组</p>
</blockquote>
<p>定义一个字典</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">month_conversion=&#123;</span><br><span class="line">    &quot;Jan&quot;:&quot;January&quot;,</span><br><span class="line">    &quot;Feb&quot;:&quot;Febuary&quot;,</span><br><span class="line">    &quot;Mar&quot;:&quot;March&quot;,</span><br><span class="line">    &quot;Apr&quot;:&quot;April&quot;,</span><br><span class="line">    &quot;May&quot;:&quot;May&quot;,</span><br><span class="line">    &quot;Jun&quot;:&quot;June&quot;,</span><br><span class="line">    &quot;Jul&quot;:&quot;July&quot;,</span><br><span class="line">    &quot;Aug&quot;:&quot;August&quot;,</span><br><span class="line">    &quot;Sep&quot;:&quot;September&quot;,</span><br><span class="line">    &quot;Oct&quot;:&quot;Octorber&quot;,</span><br><span class="line">    &quot;Nov&quot;:&quot;November&quot;,</span><br><span class="line">    &quot;Dec&quot;:&quot;December&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-字典的取值">2. 字典的取值</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取键对应值</span><br><span class="line">print(month_conversion[&quot;Jan&quot;])</span><br><span class="line">print(month_conversion.get(&quot;Dec&quot;))</span><br><span class="line"></span><br><span class="line"># 获取对应值（如错误key，则返回提示）</span><br><span class="line">print(month_conversion.get(&quot;Wed&quot;,&quot;Not a Valid Key&quot;))</span><br></pre></td></tr></table></figure>
<h2 id="3-增加或修改字典元素">3. 增加或修改字典元素</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 增加一对键值，如果key不存在则新增，如存在则修改</span><br><span class="line">month_conversion[&#x27;name&#x27;] = &#x27;Month&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="4-统计字典内元素数量">4. 统计字典内元素数量</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(len(month_conversion))</span><br></pre></td></tr></table></figure>
<h2 id="5-创建字典的其他方法">5. 创建字典的其他方法</h2>
<h3 id="5-1-dict">5.1 dict()</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict1 = dict(((&#x27;A&#x27;,1),(&#x27;B&#x27;,2),(&#x27;C&#x27;,3)))</span><br><span class="line">print(dict1)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&#123;&#x27;A&#x27;: 1, &#x27;B&#x27;: 2, &#x27;C&#x27;: 3&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict2 = dict(A=&#x27;BB&#x27;,B=&#x27;CC&#x27;)</span><br><span class="line">print(dict2)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&#123;&#x27;A&#x27;: &#x27;BB&#x27;, &#x27;B&#x27;: &#x27;CC&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-fromkeys">5.2 fromkeys()</h3>
<p>内建方法 fromkeys() ，创建新的字典，以第一个参数为key，第二个参数为value的字典。如果没有 Value，则显示 None</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&#125;</span><br><span class="line">print(dict1.fromkeys((1, 2, 3)))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&#123;1: None, 2: None, 3: None&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建 dict1 字典，字典元素键分别为1，2，3。所有值为 &quot;numbers&quot;</span><br><span class="line">dict1=&#123;&#125;</span><br><span class="line">print(dict1.fromkeys((1,2,3),&#x27;numbers&#x27;))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&#123;1: &#x27;numbers&#x27;, 2: &#x27;numbers&#x27;, 3: &#x27;numbers&#x27;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建 dict1 字典，字典键从0-2，所有键赋值为字符串&quot;赞&quot;</span><br><span class="line">dict1=&#123;&#125;</span><br><span class="line">dict1 = dict1.fromkeys(range(3),&#x27;赞&#x27;)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&#123;0: &#x27;赞&#x27;, 1: &#x27;赞&#x27;, 2: &#x27;赞&#x27;, 3: &#x27;赞&#x27;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 和 dict 不同， fromkeys 是字典的内建方法，是基于字典变量的方法，所以需要先创建一个空字典才可以使用。</p>
</blockquote>
<h2 id="6-遍历字典-key-values-items">6. 遍历字典 key(), values(), items()</h2>
<p>普通遍历字典的方法，用 for 循环，每次循环的循环体就是字典的键，通过键可以将对应的值取出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 遍历字典，for循环中的 item 每次载入的就是 key</span><br><span class="line">for item in month_conversion:</span><br><span class="line">    print(&#x27;%s - %s&#x27; % (item, month_conversion[item]))</span><br></pre></td></tr></table></figure>
<p>字典内置了三个方法 key(), values(), items() 可以更简单的遍历字典</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/32.jpg" alt="img"></p>
<p>内建方法 keys()，一般用于遍历每个键名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new_dict = &#123;&quot;a&quot;: 1,</span><br><span class="line">            &quot;b&quot;: 2,</span><br><span class="line">            &quot;c&quot;: 3&#125;</span><br><span class="line">            </span><br><span class="line">for each_key in new_dict.keys():</span><br><span class="line">    print(each_key)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>内建方法 values()，遍历每个键值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new_dict = &#123;&quot;a&quot;: 1,</span><br><span class="line">            &quot;b&quot;: 2,</span><br><span class="line">            &quot;c&quot;: 3&#125;</span><br><span class="line"></span><br><span class="line">for each_value in new_dict.values():</span><br><span class="line">    print(each_value)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>内建方法 items()，会以元组的形式同时将字典中每个元素的键和值输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new_dict = &#123;&quot;a&quot;: 1,</span><br><span class="line">            &quot;b&quot;: 2,</span><br><span class="line">            &quot;c&quot;: 3&#125;</span><br><span class="line"></span><br><span class="line">for item in new_dict.items():</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">(&#x27;a&#x27;, 1)</span><br><span class="line">(&#x27;b&#x27;, 2)</span><br><span class="line">(&#x27;c&#x27;, 3)</span><br></pre></td></tr></table></figure>
<p>遍历的时候可以用 key, value 同时遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new_dict = &#123;&quot;a&quot;: 1,</span><br><span class="line">            &quot;b&quot;: 2,</span><br><span class="line">            &quot;c&quot;: 3&#125;</span><br><span class="line"></span><br><span class="line">for key, value in new_dict.items():</span><br><span class="line">    print(key, value)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">a 1</span><br><span class="line">b 2</span><br><span class="line">c 3</span><br></pre></td></tr></table></figure>
<h2 id="7-判断字典内元素">7. 判断字典内元素</h2>
<p>内建方法 get()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&#125;</span><br><span class="line">#没有第32项，返回 None，也可以加第二个参数，让其返回该参数</span><br><span class="line">print(dict1.get(32))</span><br><span class="line">print(dict1.get(32, &#x27;无&#x27;))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">None</span><br><span class="line">无</span><br></pre></td></tr></table></figure>
<p>也可以用 in 来查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">31 in dict1</span><br><span class="line">32 not in dict1</span><br></pre></td></tr></table></figure>
<h2 id="8-删除字典内元素">8. 删除字典内元素</h2>
<p>popitem()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 弹出最后一组映射</span><br><span class="line">dict1.popitem()</span><br></pre></td></tr></table></figure>
<p>pop()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 弹出 key 为 &quot;a&quot; 的映射，这里必须带参数，如果是列表的话则不用，自动弹出最后一组</span><br><span class="line">new_dict = &#123;&quot;a&quot;: 1,</span><br><span class="line">            &quot;b&quot;: 2,</span><br><span class="line">            &quot;c&quot;: 3&#125;</span><br><span class="line"></span><br><span class="line">new_dict.pop(&#x27;a&#x27;)</span><br><span class="line">print(new_dict)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&#123;&#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br></pre></td></tr></table></figure>
<p>clear() 清空字典</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 清空字典</span><br><span class="line">dict1.clear()</span><br></pre></td></tr></table></figure>
<h2 id="9-合并字典">9. 合并字典</h2>
<p>update() 合并字典，如被合并字典有相同键，则覆盖键值对，否则则会新增键值对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict1=&#123;</span><br><span class="line">    1:&#x27;玫瑰&#x27;,</span><br><span class="line">    2:&#x27;月季&#x27;,</span><br><span class="line">    3:&#x27;牡丹&#x27;,</span><br><span class="line">    4:&#x27;郁金香&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dict2=&#123;4:&#x27;百合&#x27;&#125;</span><br><span class="line">dict1.update(dict2)</span><br><span class="line">print(dict1)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&#123;1: &#x27;玫瑰&#x27;, 2: &#x27;月季&#x27;, 3: &#x27;牡丹&#x27;, 4: &#x27;百合&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-字典推导式">10. 字典推导式</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&#x27;a&#x27;:100, &#x27;b&#x27;:200, &#x27;c&#x27;:300&#125;</span><br><span class="line">dict2 = &#123;v:k for k,v in dict1.items()&#125;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&#x27;a&#x27;:100, &#x27;b&#x27;:200, &#x27;c&#x27;:300&#125;</span><br><span class="line">dict2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">for x,y in dict1.items():</span><br><span class="line">    dict2[y] = x</span><br><span class="line"></span><br><span class="line">print(dict2)</span><br></pre></td></tr></table></figure>
<h1>十三、集合（Set）</h1>
<p>集合：是一个无序且不重复的元素集合。集合最多的应用场景就是去重（删除重复元素），并且会自动将数组进行正序排列。</p>
<p>set() 函数转换字典或列表为集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建集合 set()，参数可以是元组、列表</span><br><span class="line"></span><br><span class="line">num = &#123;1,2,3,4,5&#125;</span><br><span class="line">set1 = set([1,2,3,4,5])</span><br></pre></td></tr></table></figure>
<p>例子：将 [1,2,3,4,3,2,2,2,3,4,5,6,7] 中的重复元素去除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set1=[1,2,3,4,3,2,2,2,3,4,5,6,7]</span><br><span class="line">print(set(set1))</span><br></pre></td></tr></table></figure>
<p>内置方法 add(), remove()，添加/删除集合中的成员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new_list =[1,2,3]</span><br><span class="line">new_set = set(new_list)</span><br><span class="line">new_set.add(8)</span><br><span class="line">new_set.remove(3)</span><br><span class="line">print(new_set)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&#123;8, 1, 2&#125;</span><br></pre></td></tr></table></figure>
<p>fronzenset() 转换元素为固定集合，无法改变容器内元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new_list =[1,2,3]</span><br><span class="line">new_set = set(new_list)</span><br><span class="line"></span><br><span class="line"># 参数可以是列表、元组或集合</span><br><span class="line">frozen_set = frozenset(new_set)</span><br><span class="line"></span><br><span class="line"># 元素被转换为固定集合后，无法添加或删除元素，会报错</span><br><span class="line">frozen_set.add(8)</span><br></pre></td></tr></table></figure>
<h1>十四、字符串、元素、列表、字典、集合的公共方法</h1>
<p>字符串、元素、列表、字典、集合的特性有共同点，所以有一些方法是通用的。</p>
<h2 id="1-公共方法">1. 公共方法</h2>
<p>len() 统计容器中元素的个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_list = [1,2,3,4,5]</span><br><span class="line">print(len(num_list))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>del() 删除变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将 num_list 从内存中销毁</span><br><span class="line"></span><br><span class="line">num_list = [1,2,3,4,5]</span><br><span class="line">del(num_list)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除容器中第一个元素</span><br><span class="line">num_list = [1,2,3,4,5]</span><br><span class="line">del(num_list[0])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除字典中元素</span><br><span class="line">num_list = &#123;&quot;a&quot;:1,</span><br><span class="line">            &quot;b&quot;:2&#125;</span><br><span class="line">del(num_list[&#x27;a&#x27;])</span><br><span class="line">print(num_list)</span><br></pre></td></tr></table></figure>
<p>max() 、min() 返回容器中元素的最大值、最小值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_list = [1, 2, 3, 4, 5]</span><br><span class="line">print(max(num_list))</span><br><span class="line">print(min(num_list))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是字典只针对 key 比较</p>
</blockquote>
<h2 id="2-切片">2. 切片</h2>
<p>关于切片之前已经讲过，切片支持的数据类型有字符串、列表、元组<br>
切片使用索引值来限定范围，列表和元组都是有序集合，所以可以通过索引值来切片，而字典和集合是无序容器，所以无法使用切片功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_list = [1,2,3,4,5]</span><br><span class="line">print(num_list[2:])</span><br></pre></td></tr></table></figure>
<h2 id="3-运算符">3. 运算符</h2>
<p>运算符 +<br>
运算符 + 可以合并元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list_a = [1,2,3]</span><br><span class="line">list_b = [4,5,6]</span><br><span class="line">list_c = list_a + list_b</span><br><span class="line">print(list_c)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>支持的数据类型：字符串、列表、元组</p>
</blockquote>
<p>运算符 *<br>
运算符 * 重复元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;*&quot; * 10)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">**********</span><br></pre></td></tr></table></figure>
<blockquote>
<p>支持的数据类型：字符串、列表、元组</p>
</blockquote>
<p>运算符 in、not in<br>
检查元素是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(3 in (1, 2, 3))</span><br><span class="line">print(4 not in [1, 2, 3])</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<blockquote>
<p>支持的数据类型：字符串、列表、元组、字典<br>
in 在对字典操作时，判断的是字典的键</p>
</blockquote>
<p>比较运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print((1,2,3)&lt;(2,2,3))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<blockquote>
<p>支持的数据类型：字符串、列表、元组</p>
</blockquote>
<h2 id="4-遍历方法">4. 遍历方法</h2>
<p>用 for in 语句可以遍历字符串、列表、元组、字典。</p>
<h2 id="5-迭代操作函数">5. 迭代操作函数</h2>
<h3 id="sorted-函数">sorted() 函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sorted(iterable, cmp=None, key=None, reverse=False)</span><br></pre></td></tr></table></figure>
<ul>
<li>iterable – 可迭代对象。</li>
<li>cmp – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</li>
<li>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li>
<li>reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&#x27;a&#x27;:3, &#x27;b&#x27;:2, &#x27;c&#x27;:1&#125;</span><br><span class="line">print(sorted(dict1.values()))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>字典默认按照key进行排序</p>
</blockquote>
<p>列表中的字典（JSON数据）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;, &#x27;age&#x27;:20, &#x27;score&#x27;:80, &#x27;height&#x27;:177&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;lisi&#x27;, &#x27;age&#x27;:18, &#x27;score&#x27;:100, &#x27;height&#x27;:167&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;wangwu&#x27;, &#x27;age&#x27;:19, &#x27;score&#x27;:66, &#x27;height&#x27;:173&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;zhaoliu&#x27;, &#x27;age&#x27;:22, &#x27;score&#x27;:59, &#x27;height&#x27;:185&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 传入的foo函数需要一个参数，而这个参数就会遍历列表中所有元素</span><br><span class="line"># 将需要指定排序的元素返回，则会按照该元素升序排列</span><br><span class="line">def foo(x):</span><br><span class="line">    return x[&#x27;age&#x27;]</span><br><span class="line"></span><br><span class="line">print(sorted(students, key=foo))</span><br></pre></td></tr></table></figure>
<p>匿名函数写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(sorted(students, key=lambda x: x[&#x27;age&#x27;]))</span><br></pre></td></tr></table></figure>
<h3 id="filter-函数">filter() 函数</h3>
<p>filter() 函数可以让我们调用一个自定义方法，然后用这个方法遍历一个迭代数据，达到过滤的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter(function, iterable)</span><br></pre></td></tr></table></figure>
<ul>
<li>function – 判断函数。</li>
<li>iterable – 可迭代对象。</li>
</ul>
<p>如下方代码，我们定义了一个 odd() 函数来判断奇数，然后将这个函数当做参数传入 filter()，返回一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def odd(x):</span><br><span class="line"> return x%2  # 如果是奇数返回1，如果是偶数返回0</span><br><span class="line">temp = range(10)</span><br><span class="line">show=filter(odd,temp)  # 用odd(x)函数遍历temp中所有元素，经过运算如果为真则保留。</span><br><span class="line">print(list(show))  # 用 list 查看对象内容</span><br><span class="line"></span><br><span class="line"># lambda 函数简写</span><br><span class="line">print(list(filter(lambda x:x%2, range(10))))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数方法，第二个参数迭代数据，返回一个对象，因为对象是迭代数据，所以需要用list转换成列表显示。</p>
</blockquote>
<p>思考：</p>
<p>如果将 odd 函数写成这样会是什么结果？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def odd(x):</span><br><span class="line">    if x%2 == 0:</span><br><span class="line">        return x </span><br></pre></td></tr></table></figure>
<p>进阶</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 20, &#x27;score&#x27;: 80, &#x27;height&#x27;: 177&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;lisi&#x27;, &#x27;age&#x27;: 18, &#x27;score&#x27;: 100, &#x27;height&#x27;: 167&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 19, &#x27;score&#x27;: 66, &#x27;height&#x27;: 173&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;zhaoliu&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 59, &#x27;height&#x27;: 185&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 传入的foo函数需要一个参数，而这个参数就会遍历列表中所有元素</span><br><span class="line"># 将不符合条件的元素过滤掉</span><br><span class="line">def foo(x):</span><br><span class="line">    if x[&#x27;age&#x27;] &lt;= 20:</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(list(filter(foo,students)))</span><br><span class="line"></span><br><span class="line"># 简写</span><br><span class="line">print(list(filter(lambda x: x[&#x27;age&#x27;] &lt;= 20, students)))</span><br></pre></td></tr></table></figure>
<h3 id="map">map()</h3>
<p><strong>map()</strong> 会根据提供的函数对指定序列做映射。遍历跌倒数据中每一个元素，然后将元素以参数形式传入函数中，进行遍历操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure>
<ul>
<li>function – 函数</li>
<li>iterable – 一个或多个序列</li>
</ul>
<p>将列表中每个元素进行加2操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = range(10)</span><br><span class="line"></span><br><span class="line">def foo(x):</span><br><span class="line">    x+=2</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line">print(list(map(foo,list1)))</span><br><span class="line"></span><br><span class="line"># 简写</span><br><span class="line">print(list(map(lambda x:x+2, range(10))))</span><br></pre></td></tr></table></figure>
<h3 id="reduce">reduce()</h3>
<p><strong>reduce()</strong> 函数会对参数序列中元素进行累积。</p>
<p>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure>
<ul>
<li>function – 函数，有两个参数</li>
<li>iterable – 可迭代对象</li>
<li>initializer – 可选，初始参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(reduce(lambda x,y: x+y[&#x27;score&#x27;], students, 0))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为第一个和第二个数据都是列表，但是执行第三次操作的时候，x 就不是 x[‘score’] 的形式了。变成了 x = 180 的形式，所以无法继续操作，这时候需要设置一个初始值0，这样x以后每次相加都会是数字形式迭代。</p>
</blockquote>
<h1>十五、全局变量、局部变量</h1>
<p>变量和数据都是保存在内存中的，在 Python 中，函数的参数传递以及返回值都是靠引用传递的。</p>
<h2 id="1-引用的概念">1. 引用的概念</h2>
<p>在 Python 中，变量和数据是分开存储的，数据保存在内存的一个位置，变量保存着数据再内存中的地址，变量中记录数据的地址，就叫做引用，使用 id() 函数可以查看变量中保存数据所在的内存地址。</p>
<blockquote>
<p>如果变量已经被定义，当给这个已经被定义的变量赋值的时候，本质上是修改了数据的引用</p>
</blockquote>
<h2 id="2-可变和不可变类型">2. 可变和不可变类型</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangshicheng/p/10627916.html">https://www.cnblogs.com/wangshicheng/p/10627916.html</a></p>
<p>不可变类型，内存中的数据不允许被修改</p>
<ul>
<li>数字类型： int、bool、float、complex、long(2.x)</li>
<li>字符串：str</li>
<li>元组：tuple</li>
</ul>
<p>可变类型，内存中的数据可以被修改</p>
<ul>
<li>列表、字典</li>
</ul>
<h2 id="3-局部变量和全局变量">3. 局部变量和全局变量</h2>
<p>局部变量是在函数内部定义的变量，只能在函数内部使用<br>
全局变量是在函数外部定义的变量（没有定义在某一个函数内），所有函数内部都可以使用这个变量。</p>
<h3 id="3-1-局部变量">3.1 局部变量</h3>
<p>局部变量是在函数内部定义的变量，只能在函数内部使用，函数执行结束后，函数内部的局部变量会被系统回收。不同的函数，可以定义相同的名字的局部变量，不互相影响。</p>
<blockquote>
<p>局部变量的作用：在函数内部使用，临时保存函数内部需要使用的数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count=5</span><br><span class="line">def myFun():</span><br><span class="line">    count=10</span><br><span class="line">    print(count)  # 这里的 count 是局部变量 10</span><br><span class="line">myFun()</span><br><span class="line">print(count)  # 这里 count 是全局变量的 5</span><br></pre></td></tr></table></figure>
<h3 id="3-2-全局变量-global-关键字">3.2 全局变量 global 关键字</h3>
<p>如果想在函数内部使用全局变量，需要在函数内部加上 globle 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count=5</span><br><span class="line">def myFun():</span><br><span class="line">    global count  # 调用全局变量</span><br><span class="line">    count=10  # 更改函数外全局变量 count 的值</span><br><span class="line">    print(count)</span><br><span class="line">myFun()</span><br><span class="line">print(count)  # 输出为10</span><br></pre></td></tr></table></figure>
<h2 id="4-函数不可变和可变的参数">4. 函数不可变和可变的参数</h2>
<p>在函数内部，如果有变量与函数外部的变量同名，我们知道两个变量互不影响，但是我们如果针对参数使用赋值语句呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def demo(num):</span><br><span class="line">    num = 100</span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">gl_num = 99</span><br><span class="line">demo(gl_num)</span><br><span class="line">print(gl_num)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line"></span><br><span class="line">100</span><br><span class="line">99</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：针对参数进行的赋值，并不会影响外部实参</p>
</blockquote>
<p>原理解释：</p>
<ol>
<li>Python 解释器由上到下执行，看到函数不会立即执行。</li>
<li>然后看到 gl_num = 99 后，在内存中开辟一个空间存储数字99，然后让变量gl_num 引用数字99</li>
<li>然后执行函数，将参数传入函数</li>
<li>函数中 num 这个参数实际上也是个变量，Python 会让 num 这个变量引用 99 （相同的位置）</li>
<li>然后在内存中开辟一个新的空间存放100</li>
<li>将 num 变量引用100</li>
<li>执行 print(num)，这时候 num 已经引用的是 100 了</li>
<li>函数执行完毕，num 被系统回收</li>
<li>gl_num 引用没有变，依然是 99</li>
<li>输出 gl_num</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/33.jpg" alt="img"></p>
<p>在函数内部使用内建方法更改参数的值，会更改实参的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def demo(num_list):</span><br><span class="line">    num_list.append(4)</span><br><span class="line">    print(num_list)</span><br><span class="line"></span><br><span class="line">gl_list = [1,2,3]</span><br><span class="line">demo(gl_list)</span><br><span class="line">print(gl_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/34.jpg" alt="img"></p>
<blockquote>
<p>因为实参和形参引用的都是同一个地址，当内存中列表的值发生改变，在外边引用的变量也会同时改变</p>
</blockquote>
<p>在 Python 中， += 针对数字是 num = num + num，而针对列表则使用的是 extend 方法，所以当列表作为参数传入函数当中，如果使用了 num_list = num_list  + num_list  ，则不会影响外部变量。而使用 += 的话，则外部变量同时会跟着内部变量一起改变。</p>
<h2 id="5-变量的生命周期">5. 变量的生命周期</h2>
<p>局部变量在函数执行时才会被创建，函数执行完毕后，局部变量被系统回收。全局变量在程序执行完毕后才会被系统回收。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/35.jpg" alt="img"></p>
<h2 id="6-全局变量命名的建议">6. 全局变量命名的建议</h2>
<p>为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：在全局变量名前增加 g_ 或者 gl_ 前缀</p>
<h1>十六、面向对象OOP</h1>
<h2 id="1-面向对象概念">1. 面向对象概念</h2>
<p>面向对象编程 Object Oriented Pogramming 简写 OOP，在了解面向对象之前，需要了解面向过程。</p>
<h3 id="1-1-面向过程">1.1 面向过程</h3>
<p>把完成某一个需求的所有步骤从头到尾逐步实现，程序员根据开发需求，将某些功能独立的代码封装成一个又一个函数，最后顺序的调用不同的函数。</p>
<p>特点：</p>
<ul>
<li>注重步骤与过程，不注重职责分工</li>
<li>如果需求复杂，代码会变得很复杂</li>
<li>开发复杂项目，没有固定套路，开发难度很大。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/36.jpg" alt="img"></p>
<p>用下五子棋的例子来描述面向过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下五子棋 &#123;</span><br><span class="line">    开始游戏();</span><br><span class="line">    黑子先走();</span><br><span class="line">    绘制画面();</span><br><span class="line">    判断输赢();</span><br><span class="line">    轮到白子();</span><br><span class="line">    绘制画面();</span><br><span class="line">    判断输赢();</span><br><span class="line">	返回到 黑子先走();</span><br><span class="line">	输出最后结果；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-面向对象">1.2 面向对象</h3>
<p>在日常生活或编程中，简单的问题可以用面向过程的思路来解决，直接有效，但是当问题的规模变得更大时，用面向过程的思想是远远不够的。所以慢慢就出现了面向对象的编程思想。世界上有很多人和事物，每一个都可以看做一个对象，而每个对象都有自己的属性和行为，对象与对象之间通过方法来交互。面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个对象在整个解决问题的步骤中的属性和行为。</p>
<p>相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法。在完成某一个需求前，首先确定职责（要做的事情），根据职责确定不同的对象，在对象内部封装不同的方法，最后完成代码，就是顺序的让不同对象调用不同的方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/37.jpg" alt="img"></p>
<p>再用五子棋这个游戏来举例，面向对象的编程思想</p>
<p>在下五子棋的例子中，用面向对象的方法来解决的话，首先将整个五子棋游戏分为三个对象:<br>
（1）黑白双方，这两方的行为是一样的。<br>
（2）棋盘系统，负责绘制画面<br>
（3）规则系统，负责判定犯规、输赢等。</p>
<p>然后赋予每个对象一些属性和行为：<br>
（4）第一类对象（黑白双方）负责接受用户输入，并告知第二类对象（棋盘系统）棋子布局的变化，棋盘系统接收到了棋子的变化，并负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</p>
<p>可以看出，面向对象是以功能来划分问题，而不是以步骤解决。比如绘制画面这个行为，在面向过程中是分散在了多个步骤中的，可能会出现不同的绘制版本，所以要考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘系统这个对象中出现，从而保证了绘图的统一。</p>
<h3 id="1-3-面向过程与面向对象的优缺点">1.3 面向过程与面向对象的优缺点</h3>
<p><strong>面向过程</strong></p>
<p>优点：</p>
<ul>
<li>流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。</li>
<li>效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。</li>
</ul>
<p><strong>面向对象</strong></p>
<p>优点：</p>
<ul>
<li>结构清晰，程序是模块化和结构化，更加符合人类的思维方式；</li>
<li>易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；</li>
<li>易维护，系统低耦合的特点有利于减少程序的后期维护工作量。</li>
</ul>
<p>缺点：</p>
<ul>
<li>开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。</li>
<li>性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。</li>
</ul>
<h2 id="2-类和对象">2. 类和对象</h2>
<h3 id="2-1-类和对象的概念">2.1 类和对象的概念</h3>
<p>类和对象是面向对象编程的两个核心概念</p>
<ul>
<li>类：是对一群具有相同特征或行为的事物的一个统称，是抽象的，不能直接使用，在类中，特征被称为属性，行为被称为方法。</li>
</ul>
<blockquote>
<p>类就相当于制造飞机时的图纸，是一个模板，是负责创建对象的。</p>
</blockquote>
<ul>
<li>对象：是由类创建出来的一个具体存在，可以直接使用，由哪一个类创建出来的对象，就拥有在哪一个类中定义的属性和方法。</li>
</ul>
<blockquote>
<p>对象就相当于用图纸创造的飞机</p>
</blockquote>
<p>类和对象的关系<br>
类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象。类只有一个，而对象可以有很多个。不同的对象之间属性和方法可能会各不相同。类中定义了什么属性和方法，对象中就有什么属性和方法。</p>
<p>类的设计<br>
在使用面向对象开发前，需要先分析需求，确定一下，程序中需要包含哪些类，以植物大战僵尸来举例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/38.jpg" alt="img"></p>
<p>设计一个类，需要满足以下三个要素：</p>
<ul>
<li>类名：这类事物的名字，满足大驼峰命名法（MyClass）</li>
<li>属性：这类事物具有什么样的特征</li>
<li>方法：这类事物具有什么样的行为</li>
</ul>
<p>查看对象的属性和方法<br>
在 Python 中对象几乎无所不在，之前学习的变量、数据、函数都是对象，在 Python 中可以使用以下两个方法验证。</p>
<ol>
<li>进入 ipython，在标识符（变量或数据）后边输入一个 <code>.</code>  然后按下 TAB 键，会提示该对象能够调用的方法列表。</li>
<li>使用内置函数 dir 传入标识符/数据，可以查看对象内所有的属性和方法。</li>
</ol>
<p>提示： <code>__方法名__</code> 格式的方法是 Python 提供的内置方法/属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__new__		创建对象时，会被自动调用</span><br><span class="line">__init__	对象被初始化时，会被自动调用</span><br><span class="line">__del__		对象被销毁时，会被自动调用</span><br><span class="line">__str__		返回对象描述信息，print 函数输出使用</span><br></pre></td></tr></table></figure>
<h3 id="2-2-定义简单的类">2.2 定义简单的类</h3>
<p>在 Python 中定义一个类，语法如下：</p>
<pre><code>class 类名:

    属性1 = 变量

	def 方法1(self, 参数):
    	pass
</code></pre>
<blockquote>
<p>类包含属性和方法，属性一般是变量，而方法是函数</p>
</blockquote>
<p>创建一个对象（实例）</p>
<p>使用 类名() 创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class myClass:</span><br><span class="line">	pass</span><br><span class="line"></span><br><span class="line">obj = myClass()  # 创建了一个 obj 实例</span><br></pre></td></tr></table></figure>
<p>术语：</p>
<ol>
<li>创建出来的 <strong>对象</strong> 叫做 <strong>类</strong> 的 <strong>实例</strong></li>
<li>创建对象的 <strong>动作</strong> 叫做 <strong>实例化</strong></li>
<li><strong>对象的属性</strong> 叫做 <strong>实例属性</strong></li>
<li><strong>对象调用的方法</strong> 叫做 <strong>实例方法</strong></li>
</ol>
<p>在程序执行时：</p>
<ol>
<li>对象各自拥有自己的 <strong>实例属性</strong></li>
<li>调用对象方法，可以通过 <code>self.</code>
<ul>
<li>访问自己的属性</li>
<li>调用自己的方法</li>
</ul>
</li>
</ol>
<p><strong>结论</strong></p>
<ul>
<li><strong>每一个对象</strong> 都有自己 <strong>独立的内存空间</strong>，<strong>保存各自不同的属性</strong></li>
<li><strong>多个对象的方法</strong>，<strong>在内存中只有一份</strong>，在调用方法时，<strong>需要把对象的引用</strong> 传递到方法内部</li>
</ul>
<h3 id="2-3-类的属性赋值方法">2.3 类的属性赋值方法</h3>
<h4 id="2-3-1-外部赋值">2.3.1 外部赋值</h4>
<p>可以在外部赋值（不推荐，破坏了类的完整性）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line"> pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.name = &#x27;Tom&#x27;</span><br><span class="line">print(tom.name)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-在内部定义属性">2.3.2 在内部定义属性</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    name = &#x27;Tom&#x27;</span><br><span class="line">    gender = &#x27;Male&#x27;</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;%s is eating&quot; % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.eat()</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-初始化方法-init">2.3.3 初始化方法 _<em>init</em>_</h4>
<p>当使用类名() 创建对象时，会自动执行以下操作：</p>
<ol>
<li>为对象在内存中分配空间 – 创建对象</li>
<li>为对象的属性设置初始值 – 初始化方法 <code>__init__</code></li>
</ol>
<p>这个初始化方法 <code>__init__</code> 就是对象的内置方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;初始化方法&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当创建对象时，就会自动调用 <code>__init__</code> 这个初始化方法</p>
</blockquote>
<p>在初始化方法内部定义属性<br>
在 <code>__init__</code> 方法内部使用 self.属性名 = 属性的初始值就可以定义属性，定义属性后，再时候用 Cat 类创建的对象，都会拥有该属性。也可以在 <code>__init__</code> 中定义参数，在创建的时候传入参数就可以把对象属性初始化。</p>
<pre><code>class Cat:

    def __init__(self, name):
        self.name = name
        #如果需要固定参数，直接在初始化中定义即可
        self.gender = 'Male'
        print(&quot;初始化方法&quot;)

    def eat(self):
        print(&quot;%s is eating&quot; % self.name)

    def drink(self):
        print(&quot;%s is drinking&quot; % self.name)
</code></pre>
<p>​<br>
​    tom = Cat(‘Tom’)<br>
​    tom.eat()</p>
<blockquote>
<p>在类的外部，用 变量名. 访问类的属性和方法<br>
在类的封装方法中，用 self. 访问对象的属性和方法<br>
self 指向的就是对象实例的地址，通过引用，让类知道哪个对象调用的方法。</p>
</blockquote>
<p>初始化属性的默认值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 要求这个类必须有这些参数（属性）</span><br><span class="line">class Ball:</span><br><span class="line">    def  __init__(self,name=&#x27;默认名字&#x27;)</span><br><span class="line">        self.name = name</span><br><span class="line">    def kick(self):</span><br><span class="line">        print(&#x27;踢他&#x27; + self.name)</span><br></pre></td></tr></table></figure>
<p>类属性和实例属性</p>
<ul>
<li><strong>类属性</strong> 就是给 <strong>类对象</strong> 中定义的 <strong>属性</strong></li>
<li>通常用来记录 <strong>与这个类相关</strong> 的特征</li>
<li><strong>类属性</strong> <strong>不会用于</strong>记录 <strong>具体对象的特征</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Tool(object):</span><br><span class="line"></span><br><span class="line">    # 使用赋值语句，定义类属性，记录创建工具对象的总数</span><br><span class="line">    count = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">        # 针对类属性做一个计数+1</span><br><span class="line">        Tool.count += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建工具对象</span><br><span class="line">tool1 = Tool(&quot;斧头&quot;)</span><br><span class="line">tool2 = Tool(&quot;榔头&quot;)</span><br><span class="line">tool3 = Tool(&quot;铁锹&quot;)</span><br><span class="line"></span><br><span class="line"># 知道使用 Tool 类到底创建了多少个对象?</span><br><span class="line">print(&quot;现在创建了 %d 个工具&quot; % Tool.count)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>属性的获取机制</p>
<p>在 <code>Python</code> 中 <strong>属性的获取</strong> 存在一个 <strong>向上查找机制</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/39.jpg" alt="image-20200716190432933"></p>
<ul>
<li>因此，要访问类属性有两种方式：
<ol>
<li><strong>类名.类属性</strong></li>
<li><strong>对象.类属性</strong> （不推荐）</li>
</ol>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>如果使用 <code>对象.类属性 = 值</code> 赋值语句，只会 <strong>给对象添加一个属性</strong>，而不会影响到 <strong>类属性的值</strong></li>
</ul>
<p>类也是一种对象，如果对类直接操作的话，那么类里边所有属性则都会改变，用类创建的实例也跟着改变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class C:</span><br><span class="line">    count = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = C()</span><br><span class="line">b = C()</span><br><span class="line">a.count = 10  # a中的count则会改变</span><br><span class="line"># b.count #b中的count不会跟着改变</span><br><span class="line">C.count = 10  # 类里边的count变量改变</span><br><span class="line"># a.count #count不会跟着类改变，因为已经初始化过了</span><br><span class="line"># b.count #则会跟着改变</span><br></pre></td></tr></table></figure>
<h3 id="2-4-内置方法和属性">2.4 内置方法和属性</h3>
<h4 id="2-4-1-del-方法">2.4.1 _<em>del</em>_ 方法</h4>
<p>对象从内存中销毁前，会被自动调用，如果需要在对象被销毁前，再做一些事情，可以使用 <code>__del__</code> 方法，一个对象一旦被 <code>__del__</code> 调用，生命周期结束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        print(&quot;对象 %s 被初始化&quot; % self.name)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;对象 %s 被销毁&quot; % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tom = Person(&quot;Tom&quot;)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">对象 Tom 被初始化</span><br><span class="line">对象 Tom 被销毁</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-str-方法">2.4.2 _<em>str</em>_ 方法</h4>
<p>在 Python 中，使用 print 输出对象变量，默认情况下，会输出这个变量引用的对象时由哪一个类创建的对象，以及在内存中的地址（十六进制表示）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    pass</span><br><span class="line">tom = Person()</span><br><span class="line">print(tom)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&lt;__main__.Person object at 0x012DE4D8&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>是由 Person 类创建的对象，内存地址是 0x012DE4D8</p>
</blockquote>
<p>如果在开发中，希望使用 print 输出对象变量时，可以打印自定义的内容，就可以利用 <code>__str__</code> 这个内置方法了</p>
<blockquote>
<p>注意：<code>__str__</code> 方法必须返回一个字符串</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return (&quot;print 我创建的对象，就会输出这段文字&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tom = Person()</span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-类的封装">2.5 类的封装</h3>
<p>面向对象三大特征</p>
<ul>
<li>封装：根据职责将属性和方法封装到一个抽象的类中</li>
<li>继承：实现代码的重用，相同的代码不需要重复的编写</li>
<li>多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度。</li>
</ul>
<p>封装是面向对象编程的一大特点，面向对象编程的第一步就是将属性和方法封装到一个抽象的类中。外界使用类创建对象，然后让对象调用方法。</p>
<blockquote>
<p>把所有属性和方法放在类中，用户就无法知道这个类调用的是什么，拥有什么属性，起到保护作用</p>
</blockquote>
<p>一个类的对象，可以是另一个类的属性，或者方法中的参数。如果要开发多个相关类，则需要判断，那个类被使用，则先开发哪个类。</p>
<h3 id="2-6-身份运算符">2.6 身份运算符</h3>
<p>身份运算符用于笔记哦啊啊两个对象的内存地址是否一致（是否是同一个对象的引用）</p>
<p>is</p>
<p>判断两个标识符是不是引用同一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x is y</span><br><span class="line"></span><br><span class="line"># 类似</span><br><span class="line">id(x) == id(y)</span><br></pre></td></tr></table></figure>
<p>is not</p>
<p>判断两个标识符是不是引用不同对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x is not y</span><br><span class="line"></span><br><span class="line"># 类似</span><br><span class="line">id(x) != id(y)</span><br></pre></td></tr></table></figure>
<p>is 与 == 区别</p>
<ul>
<li>is 用于判断两个变量引用对象是否为同一个</li>
<li>== 用于判断引用变量的值是否相等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [1, 2, 3]</span><br><span class="line">b = [1, 2, 3]</span><br><span class="line">print(b is a)</span><br><span class="line">print(b == a)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>应用场景</p>
<p>比如用来判断参数是否为空对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if self.gun is None:</span><br></pre></td></tr></table></figure>
<h3 id="2-7-私有属性和私有方法">2.7 私有属性和私有方法</h3>
<p>在实际开发中，对象的某些属性和方法可能只希望在对象的内部被使用，二不希望在外部访问到。</p>
<ul>
<li>私有属性就是对象不希望公开的属性</li>
<li>私有方法就是对象不希望公开的方法</li>
</ul>
<p>定义私有属性和私有方法</p>
<p>在属性名或方法名前增加两个下划线，就可以定义私有属性或方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Women:</span><br><span class="line">	__name = &quot;Jane&quot;</span><br><span class="line">	__age = &quot;17&quot;</span><br><span class="line">	</span><br><span class="line">	def __secret(self):</span><br><span class="line">		pass</span><br><span class="line"></span><br><span class="line">xiaofang = Women()</span><br><span class="line">print(xiaofang.__name)       </span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序会报错，无法找到该属性</p>
</blockquote>
<p>在类内部调用私有属性和私有方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Women:</span><br><span class="line">    __name = &quot;Jane&quot;</span><br><span class="line">    __age = &quot;17&quot;</span><br><span class="line"></span><br><span class="line">    def __secret(self):</span><br><span class="line">        print(self.__name)</span><br><span class="line">        print(self.__age)</span><br><span class="line"></span><br><span class="line">    def show_secret(self):</span><br><span class="line">        self.__secret()</span><br><span class="line"></span><br><span class="line">xiaofang = Women()</span><br><span class="line">xiaofang.show_secret()</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">Jane</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在外部虽然无法直接调用私有属性和私有方法，但是如果在类内部，则无这个限制。</p>
</blockquote>
<p>伪私有属性和私有方法</p>
<p>在 Python 中，其实并没有真正意义的私有</p>
<ul>
<li>在给属性、方法命名时，实际上是对名称做了一些特殊处理，使得外界无法访问</li>
<li>处理方式：在名称前面加上 <code>_类名</code> =&gt; <code>_类名__名称</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Women:</span><br><span class="line">	__name = &quot;Jane&quot;</span><br><span class="line">	__age = &quot;17&quot;</span><br><span class="line">	</span><br><span class="line">	def __secret(self):</span><br><span class="line">		pass</span><br><span class="line"></span><br><span class="line">xiaofang = Women()</span><br><span class="line">print(xiaofang.__name)  # 外界无法访问私有属性</span><br><span class="line">print(xiaofang._Women__name)  # 外界可以访问</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议不要使用这种方法调用，因为私有属性和私有方法本来就是为了隐藏。</p>
</blockquote>
<h3 id="2-8-类的继承">2.8 类的继承</h3>
<h4 id="2-8-1-类的继承的概念">2.8.1 类的继承的概念</h4>
<p>子类拥有父类的所有方法和属性</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/40.jpg" alt="image-20200716163655669"></p>
<p>专业术语：</p>
<ul>
<li>Dog 类是 Animal 类的子类， Animal 类是 Dog 类的父类， Dog 类从 Animal 类继承</li>
<li>Dog 类是 Animal 类的派生类， Animal 类是 Dog 类的基类， Dog 类从 Animal 类派生</li>
</ul>
<p>继承的传递性</p>
<p>如果 C 类从 B 类继承，B类又从A类继承，那么 C 类就具有 B 类和 A 类的所有属性和方法。</p>
<blockquote>
<p>子类拥有父类以及父类的父类中封装的所有属性和方法</p>
</blockquote>
<p>类的继承语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 类名(父类名):</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子类继承自父类，可以直接享受父类中已经封装号的方法，不需要再次开发</p>
<p>子类中应该根据职责，封装子类特有的属性和方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义一个 myClass 的新类，让这个类继承列表类的所有功能</span><br><span class="line">class MyClass(list):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 生成一个对象</span><br><span class="line">new_list = MyClass()</span><br><span class="line"></span><br><span class="line"># new_list 拥有列表的所有方法和属性</span><br><span class="line">new_list.append(1)</span><br><span class="line">print(new_list)</span><br><span class="line"></span><br><span class="line"># 输出对象</span><br><span class="line">[1]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>myClass 继承 list 这个类的所有方法和属性，新生成的对象 new_list 相当于 new_list = list()</p>
</blockquote>
<h4 id="2-8-2-方法的重写">2.8.2 方法的重写</h4>
<p>子类拥有父类的所有方法和属性，当父类的方法实现不能满足子类需求时，可以对方法进行重写（override）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/41.jpg" alt="image-20200716164927111"></p>
<ul>
<li>Dog 类继承 Animal 类的所有属性和方法</li>
<li>Dog 类拥有自己独有的方法 bark(self)</li>
<li>XiaoTianQuan 继承自 Dog 类，拥有 Dog 类和 Animal 类的所有属性和方法，并且拥有自己的独有方法 fly(self)，而且 bark(self) 方法与 Dog 类中的 bark(self) 并不相同</li>
</ul>
<p>重写父类方法有两种情况：</p>
<ol>
<li>覆盖父类的方法</li>
<li>对父类方法进行扩展</li>
</ol>
<p><strong>覆盖父类的方法</strong></p>
<p>如果在开发中，父类的方法实现和子类方法实现完全不同，就可以使用覆盖的方式，在子类中重新编写父类的方法实现</p>
<blockquote>
<p>具体的实现方式，就是在子类中定义一个和父类同名的方法并且实现</p>
</blockquote>
<p>重写之后，在运行时，只会调用子类中重写的方法，而不会再调用父类中封装的方法。</p>
<p>子类方法的覆盖重写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Parent:</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;调用父类&quot;)</span><br><span class="line">class Child(Parent):</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;调用子类&quot;)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">a=Parent()</span><br><span class="line">b=Child()</span><br><span class="line"></span><br><span class="line">a.hello()</span><br><span class="line">b.hello()</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">调用父类</span><br><span class="line">调用子类</span><br></pre></td></tr></table></figure>
<p><strong>对父类方法进行扩展</strong></p>
<p>如果开发中，子类方法实现中包含父类的方法实现（父类原本封装的方法实现是子类方法的一部分）就可以使用扩展的方式。</p>
<ol>
<li>在子类中重写父类的方法</li>
<li>在需要的位置使用 <code>super().父类方法</code> 来调用父类方法的执行</li>
<li>代码其他的位置针对子类的需求，编写子类特有的代码实现</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal:</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;跑&quot;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;吃&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def eat(self):</span><br><span class="line">        super().eat()</span><br><span class="line">        print(&quot;吃猫粮&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.eat()</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">吃</span><br><span class="line">吃猫粮</span><br></pre></td></tr></table></figure>
<blockquote>
<p>新生成的对象tom是Cat类，继承自Animal类，两个类都有eat()方法。</p>
<p>在Cat类中对eat() 方法进行了扩展，使用 super().eat() 先继承了父类 Animal 中的 eat() 方法，然后又增加了新的功能</p>
</blockquote>
<p>关于 super</p>
<p>在 Python 中 super 是一个特殊的类，super() 就是使用 super 类创建出来的对象。最常使用的场景就是在重写父类方法时，调用在父类中封装的方法实现。</p>
<p>调用父类方法的另一种方式</p>
<p>在 Python 2.x 版本，如果需要调用父类的方法，还可以使用一下方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类名.方法(self)</span><br></pre></td></tr></table></figure>
<ul>
<li>这种方式，目前在 Python 3.x 还支持这种方式</li>
<li><strong>不推荐使用</strong>， 因为一旦父类发生变化，方法调用位置的类名同样需要修改</li>
</ul>
<blockquote>
<p>在开发时，父类名和super() 方式不要混用</p>
<p>如果使用当前子类名调用方法，会形成递归调用，出现死循环</p>
</blockquote>
<h4 id="2-8-3-多继承">2.8.3 多继承</h4>
<p>子类可以拥有多个父类，并且具有所有父类的属性和方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/42.jpg" alt="image-20200716170811752"></p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 子类名(父类名1, 父类名2...)</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<p>一个子类可以继承多个父类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Child(Parent, Grandfather)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>Python 中的 MRO – 方法搜索顺序</p>
<p>如果一个子类继承多个父类，那么如果多个父类中有相同的方法，那么子类会继承哪个顺序呢？Python 针对类提供了一个内置属性 <code>__mro__</code> ，可以查看方法的搜索顺序。</p>
<p>MRO 是 method resolution order 的简写，主要用于在多继承时判断方法、属性的调用路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def show(self):</span><br><span class="line">        print(&quot;A的方法&quot;)</span><br><span class="line">class B:</span><br><span class="line">    def show(self):</span><br><span class="line">        print(&quot;B的方法&quot;)</span><br><span class="line">class C(A,B):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">obj = C()</span><br><span class="line">obj.show()</span><br><span class="line">print(C.__mro__)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">A的方法</span><br><span class="line">(&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到以C类创建出来的对象调用的A类中的方法，使用<code>__mro__</code> 属性可以看到调用的顺序，如果自身有重写该方法，那么调用自身的，否则调用A、再调用B</p>
</blockquote>
<p>如果将定义C类的继承顺序改写，那么生成的结果也会不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class C(B,A):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：如果多个类有相同的方法，根据继承顺序的不同，调用的顺序也不同。</p>
</blockquote>
<p><strong>新式类与旧式类</strong></p>
<p>object 是 Python 为所有对象提供的基类，提供一些内置的属性和方法，可以使用 dir 函数查看。</p>
<ul>
<li>新式类：Python 3.x 中，如果没有定义父类，默认以 object 为基类，<strong>推荐使用</strong>。</li>
<li>旧式类 ：在 Python2.x 中，不会默认以 object 为基类</li>
</ul>
<blockquote>
<p>新式类与旧式类在多继承时，会影响到方法的搜索顺序</p>
</blockquote>
<p>建议在定义类时，如果没有父类，统一继承自 object</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 类名(object):</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<h4 id="2-8-4-父类的私有属性和私有方法">2.8.4 父类的私有属性和私有方法</h4>
<ol>
<li>子类对象不能再自己的方法内部，直接访问父类的私有属性或私有方法</li>
<li>子类对象可以通过父类的公有方法间接访问到私有属性或私有方法</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/43.jpg" alt="image-20200716172643432"></p>
<ul>
<li>B 的对象不能直接访问 <code>__num2</code> 属性</li>
<li>B 的对象不能再 demo 方法内访问 __num2 属性</li>
<li>B 的对象可以在 demo 方法内，调用父类的 test 方法</li>
<li>父类的 test 方法内部，能够访问 <code>__num2</code> 属性和<code>__test</code> 方法</li>
</ul>
<h3 id="2-9-多态">2.9 多态</h3>
<p>面向对象的三大特征</p>
<ol>
<li>封装：根据职责将属性和方法封装到一个抽象的类中
<ul>
<li>定义类的准则</li>
</ul>
</li>
<li>继承：实现代码的重用，相同的代码不需要重复编写
<ul>
<li>设计类的技巧</li>
<li>子类针对自己特有的需求，编写特定的代码</li>
</ul>
</li>
<li>多态：不同的子类对象调用相同的父类方法，产生不同的执行结果
<ul>
<li>多态可以增加代码的灵活度</li>
<li>以继承的和重写父类方法为前提</li>
<li>是调用方法的技巧，不会影响到类的内部设计</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/44.jpg" alt="image-20200716174126222"></p>
<p>不同对象对同一个方法响应不同的行动，类里边的方法相同，但是实现的效果却不一样。</p>
<p>多态案例演练</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/45.jpg" alt="image-20200716175120063"></p>
<ol>
<li>在 <code>Dog</code> 类中封装方法 <code>game</code>
<ul>
<li>普通狗只是简单的玩耍</li>
</ul>
</li>
<li>定义 <code>XiaoTianDog</code> 继承自 <code>Dog</code>，并且重写 <code>game</code> 方法
<ul>
<li>哮天犬需要在天上玩耍</li>
</ul>
</li>
<li>定义 <code>Person</code> 类，并且封装一个 <strong>和狗玩</strong> 的方法
<ul>
<li>在方法内部，直接让 <strong>狗对象</strong> 调用 <code>game</code> 方法</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def game(self):</span><br><span class="line">        print(&quot;%s 蹦蹦跳跳的玩耍...&quot; % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class XiaoTianDog(Dog):</span><br><span class="line"></span><br><span class="line">    def game(self):</span><br><span class="line">        print(&quot;%s 飞到天上去玩耍...&quot; % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Person(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def game_with_dog(self, dog):</span><br><span class="line"></span><br><span class="line">        print(&quot;%s 和 %s 快乐的玩耍...&quot; % (self.name, dog.name))</span><br><span class="line"></span><br><span class="line">        # 让狗玩耍</span><br><span class="line">        dog.game()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 1. 创建一个狗对象</span><br><span class="line"># wangcai = Dog(&quot;旺财&quot;)</span><br><span class="line">wangcai = XiaoTianDog(&quot;飞天旺财&quot;)</span><br><span class="line"></span><br><span class="line"># 2. 创建一个小明对象</span><br><span class="line">xiaoming = Person(&quot;小明&quot;)</span><br><span class="line"></span><br><span class="line"># 3. 让小明调用和狗玩的方法</span><br><span class="line">xiaoming.game_with_dog(wangcai)</span><br></pre></td></tr></table></figure>
<h3 id="2-10-类方法和类的静态方法">2.10 类方法和类的静态方法</h3>
<p><strong>类方法</strong> 就是针对 <strong>类对象</strong> 定义的方法</p>
<ul>
<li>在 <strong>类方法</strong> 内部可以直接访问 <strong>类属性</strong> 或者调用其他的 <strong>类方法</strong></li>
<li>类方法是直接针对类进行操作的方法。</li>
</ul>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">def 类方法名(cls):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<ul>
<li>类方法需要用 <strong>修饰器</strong> <code>@classmethod</code> 来标识，<strong>告诉解释器这是一个类方法</strong></li>
<li>类方法的 <strong>第一个参数</strong> 应该是 <code>cls</code>
<ul>
<li>由 <strong>哪一个类</strong> 调用的方法，方法内的 <code>cls</code> 就是 <strong>哪一个类的引用</strong></li>
<li>这个参数和 <strong>实例方法</strong> 的第一个参数是 <code>self</code> 类似</li>
<li><strong>提示</strong> 使用其他名称也可以，不过习惯使用 <code>cls</code></li>
</ul>
</li>
</ul>
<ul>
<li>
<p>通过 <strong>类名.</strong> 调用 <strong>类方法</strong>，<strong>调用方法时</strong>，不需要传递 <code>cls</code> 参数</p>
</li>
<li>
<p><strong>在方法内部</strong></p>
<ul>
<li>可以通过 <code>cls.</code> <strong>访问类的属性</strong></li>
<li>也可以通过 <code>cls.</code> <strong>调用其他的类方法</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Tool(object):</span><br><span class="line">    # 使用赋值语句，定义类属性，记录创建工具对象的总数</span><br><span class="line">    count = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">        # 针对类属性做一个计数+1</span><br><span class="line">        Tool.count += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def show_tool_count(cls):</span><br><span class="line">        &quot;&quot;&quot;显示工具对象的总数&quot;&quot;&quot;</span><br><span class="line">        print(&quot;工具对象的总数 %d&quot; % cls.count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建工具对象</span><br><span class="line">tool1 = Tool(&quot;斧头&quot;)</span><br><span class="line">tool2 = Tool(&quot;榔头&quot;)</span><br><span class="line">tool3 = Tool(&quot;铁锹&quot;)</span><br><span class="line"></span><br><span class="line">Tool.show_tool_count()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在类方法内部，可以直接使用 <code>cls</code> 访问 <strong>类属性</strong> 或者 <strong>调用类方法</strong></p>
</blockquote>
<p>静态方法</p>
<ul>
<li>在开发时，如果需要在 <strong>类</strong> 中封装一个方法，这个方法：
<ul>
<li>既 <strong>不需要</strong> 访问 <strong>实例属性</strong> 或者调用 <strong>实例方法</strong></li>
<li>也 <strong>不需要</strong> 访问 <strong>类属性</strong> 或者调用 <strong>类方法</strong></li>
</ul>
</li>
<li>这个时候，可以把这个方法封装成一个 <strong>静态方法</strong></li>
</ul>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">def 静态方法名():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>静态方法</strong> 需要用 <strong>修饰器</strong> <code>@staticmethod</code> 来标识，<strong>告诉解释器这是一个静态方法</strong></li>
<li>通过 <strong>类名.</strong> 调用 <strong>静态方法</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    </span><br><span class="line">    # 狗对象计数</span><br><span class="line">    dog_count = 0</span><br><span class="line">    </span><br><span class="line">    @staticmethod</span><br><span class="line">    def run():</span><br><span class="line">        </span><br><span class="line">        # 不需要访问实例属性也不需要访问类属性的方法</span><br><span class="line">        print(&quot;狗在跑...&quot;)</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="2-11-类、对象相关BIF">2.11 类、对象相关BIF</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#判断子类</span><br><span class="line">issubclass(class,classinfo) </span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有的类都会被认为是自己的子类，classinfo可以是类对象构成的元组，只要这个类是某个类的子类则会返回True</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#判断是否是某个类的实例</span><br><span class="line">isinstance(object, classinfo) </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#判断是有某个属性</span><br><span class="line">hasattr(object, name)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#返回指定属性的值，否则返回默认值</span><br><span class="line">getattr(object, name[,default])	</span><br><span class="line"></span><br><span class="line">#设置指定属性的值</span><br><span class="line">setattr(object, name, value)</span><br><span class="line"></span><br><span class="line">#删除属性</span><br><span class="line">delattr(object, name)</span><br><span class="line"></span><br><span class="line">#设置属性</span><br><span class="line">property(fget=None, fset=None, fdel=None, doc=None)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class C:</span><br><span class="line">	def __init__(self, size=10):</span><br><span class="line">		self.size = size</span><br><span class="line">    def getSize(self):</span><br><span class="line">    	return self.size</span><br><span class="line">    def setSize(self, value):</span><br><span class="line">    	self.size = value</span><br><span class="line">  	del delSize(self):</span><br><span class="line">  		del self.size</span><br><span class="line">    x = property(getSize, setSize, delSize)</span><br></pre></td></tr></table></figure>
<h3 id="2-12-单例">2.12 单例</h3>
<p>单例的目的是让类创建对象，在系统中只有唯一的实例，每一次执行类名() 返回的对象，内存地址都是相同的。</p>
<p>单例设计模式的应用场景</p>
<ul>
<li>音乐播放</li>
<li>回收站</li>
<li>打印机</li>
</ul>
<p>_<em>new</em>_ 方法</p>
<p>使用类名() 创建对象时， Python 的解释器首相会调用 <code>__new__ </code> 方法来为对象分配空间。然后返回对象的引用</p>
<p>Python 解释器获得对象引用后，将引用作为第一个参数，传递给 <code>__init__</code> 方法。</p>
<ul>
<li>重写 <code>__new__</code> 方法 <strong>一定要</strong> <code>return super().__new__(cls)</code></li>
<li>否则 Python 的解释器 <strong>得不到</strong> 分配了空间的 <strong>对象引用</strong>，<strong>就不会调用对象的初始化方法</strong></li>
<li>注意：<code>__new__</code> 是一个静态方法，在调用时需要 <strong>主动传递</strong> <code>cls</code> 参数</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/46.jpg" alt="image-20200716194212438"></p>
<p>当一般创建实例的时候，实例分别会被分配到不同的内存空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个实例被分配的空间不同</span></span><br><span class="line">player1 = MusicPlayer()</span><br><span class="line"><span class="built_in">print</span>(player1)</span><br><span class="line"></span><br><span class="line">player2 = MusicPlayer()</span><br><span class="line"><span class="built_in">print</span>(player2)</span><br></pre></td></tr></table></figure>
<p>而单例则需要固定内存地址，让每次创建的实例，只分配到固定的内存空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 定义一个类属性 instance</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个类属性 init_flag 来记录是否被初始化</span></span><br><span class="line">    init_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法，第一个参数和self相同，谁调用了这个类方法，这个cls就是谁</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 判断类属性是否是空对象（判断类是否已经创建了对象）</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 2. 调用父类中的__new__方法来创建内存空间，虽然方法是父类，但是cls参数确是本类。</span></span><br><span class="line">            cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="comment"># 3. 返回引用的地址</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> MusicPlayer.init_flag == <span class="literal">False</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;初始化播放器&quot;</span>)</span><br><span class="line">            MusicPlayer.init_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个实例被分配的空间相同</span></span><br><span class="line">player1 = MusicPlayer()</span><br><span class="line"><span class="built_in">print</span>(player1)</span><br><span class="line"></span><br><span class="line">player2 = MusicPlayer()</span><br><span class="line"><span class="built_in">print</span>(player2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-可迭代对象">3. 可迭代对象</h2>
<p>可迭代对象有很多种： list/tuple/dict/set/str/range/filter/map</p>
<p>而可迭代对象都可以遍历，用 <code>for...in 可迭代对象</code></p>
<p>什么是可迭代对象？</p>
<p>只要内置方法中有 <code>__iter__</code> 方法的对象就是可迭代对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections.abc import Iterable</span><br><span class="line"></span><br><span class="line">class Demo(object):</span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">class Iter(object):</span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.x = x</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">d = Demo(100)</span><br><span class="line">print(isinstance(d, Iterable))</span><br><span class="line"></span><br><span class="line">names = list(&#x27;hello&#x27;)</span><br><span class="line">print(isinstance(names,Iterable))</span><br><span class="line"></span><br><span class="line">i = Iter(100)</span><br><span class="line">print(isinstance(names,Iterable))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然创建了 i 这个可迭代对象，但是不可以用 for…in 遍历。因为 <code>__iter__</code> 方法里边没有内容。而 for…in 循环的本质就是调用 <code>__iter__</code> 方法，然后返回一个对象，之后调用这个对象的 <code>__next__</code> 方法。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections.abc import Iterable</span><br><span class="line"></span><br><span class="line">class Foo(object):</span><br><span class="line">    def __next__(self):</span><br><span class="line">        return 1</span><br><span class="line"></span><br><span class="line">class Demo(object):</span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">class Iter(object):</span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.x = x</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        x = Foo()</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">d = Demo(100)</span><br><span class="line">print(isinstance(d, Iterable))</span><br><span class="line"></span><br><span class="line">names = list(&#x27;hello&#x27;)</span><br><span class="line">print(isinstance(names,Iterable))</span><br><span class="line"></span><br><span class="line">i = Iter(100)</span><br><span class="line">print(isinstance(names,Iterable))</span><br><span class="line"></span><br><span class="line">for j in i:</span><br><span class="line">    print(j)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过这样会陷入死循环，一致调用 <code>__next__</code> 方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Iter(object):</span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.count = 0</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.count += 1</span><br><span class="line">        if self.count &lt;= self.x:</span><br><span class="line">            return &#x27;hello&#x27;</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration  # 终止迭代器</span><br><span class="line"></span><br><span class="line">test = Iter(10)</span><br><span class="line"></span><br><span class="line">for i in test:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>再稍作修改，上边的对象就可以变成 range 了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Iter(object):</span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.count = 0</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.count += 1</span><br><span class="line">        if self.count &lt;= self.x:</span><br><span class="line">            return self.count - 1</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration  # 终止迭代器</span><br><span class="line"></span><br><span class="line">test = Iter(10)</span><br><span class="line"></span><br><span class="line">for i in test:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>内置函数中的 iter 本质上就是调用魔术方法 <code>__iter__</code> ， next 方法就是调用 <code>__next__</code> 魔术方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = Demo(d)</span><br><span class="line">i = iter(d)</span><br><span class="line">print(next(i))</span><br><span class="line"></span><br><span class="line"># 相当于</span><br><span class="line">i = d.__iter__()</span><br><span class="line">i.__next__</span><br></pre></td></tr></table></figure>
<blockquote>
<p>iter函数还可以将可迭代对象转换为迭代器。</p>
</blockquote>
<p>用迭代方法计算 Fibnacci 第 n 位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Fibnacci(object):</span><br><span class="line">    def __init__(self,n):</span><br><span class="line">        self.n = n</span><br><span class="line">        self.num1 = self.num2 = 1</span><br><span class="line">        self.count = 0</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.count += 1</span><br><span class="line">        if self.count &lt;= self.n:</span><br><span class="line">            x = self.num1</span><br><span class="line">            self.num1, self.num2 = self.num2, self.num1 + self.num2</span><br><span class="line">            return x</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration  # 终止迭代器</span><br><span class="line"></span><br><span class="line">f = Fibnacci(12)</span><br><span class="line"></span><br><span class="line">for i in f:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果只想得到指定位置，做个循环让迭代器进行计算，然后用 next 调用下一个即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in f:</span><br><span class="line">	pass</span><br><span class="line">print(next(f))</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-1-zip-函数">3.1 zip 函数</h3>
<p>zip 函数可以将多个可迭代对象连接起来，将每个可迭代对象的同下标元素合并生成一个元组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections.abc import Iterator, Iterable, Generator</span><br><span class="line"></span><br><span class="line">list1 = [1,2,3]</span><br><span class="line">list2 = [4,5,6]</span><br><span class="line">zipdata = zip(list1,list2)</span><br><span class="line">print(zipdata)</span><br><span class="line"></span><br><span class="line">print(isinstance(zipdata, Iterable))</span><br><span class="line">print(isinstance(zipdata, Iterator))</span><br><span class="line">print(isinstance(zipdata, Generator))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&lt;zip object at 0x02F3E028&gt;</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从结果可以看出，zip函数会返回一个元组，并且是迭代器。</p>
</blockquote>
<p>可以用 for 循环来遍历 zip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [1,2,3]</span><br><span class="line">list2 = [4,5,6]</span><br><span class="line">zipdata = zip(list1,list2)</span><br><span class="line"></span><br><span class="line">for (x, y) in zipdata:</span><br><span class="line">    print (&#x27;&#123;&#125;+&#123;&#125;=&#123;&#125;&#x27;.format(x,y,x+y))</span><br></pre></td></tr></table></figure>
<p>用zip来创建字典</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [&#x27;name&#x27;,&#x27;age&#x27;,&#x27;score&#x27;]</span><br><span class="line">list2 = [&#x27;张三&#x27;,&#x27;18&#x27;,&#x27;90&#x27;]</span><br><span class="line">dict1 = &#123;&#125;</span><br><span class="line">for (k,v) in zip(list1,list2):</span><br><span class="line">    dict1[k] = v</span><br><span class="line"></span><br><span class="line">print(dict1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [&#x27;name&#x27;,&#x27;age&#x27;,&#x27;score&#x27;]</span><br><span class="line">list2 = [&#x27;张三&#x27;,&#x27;18&#x27;,&#x27;90&#x27;]</span><br><span class="line">dict1 = dict(zip(list1,list2))</span><br><span class="line"></span><br><span class="line">print(dict1)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-enumerate-函数">3.2 enumerate 函数</h3>
<p>同时生成可迭代对象中元素的值和索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections.abc import Iterator, Iterable, Generator</span><br><span class="line"></span><br><span class="line">list1 = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;]</span><br><span class="line">enu = enumerate(list1)</span><br><span class="line">print(enu)</span><br><span class="line">print(list(enu))</span><br><span class="line"></span><br><span class="line">print(isinstance(enu, Iterable))</span><br><span class="line">print(isinstance(enu, Iterator))</span><br><span class="line">print(isinstance(enu, Generator))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">[(0, &#x27;张三&#x27;), (1, &#x27;李四&#x27;), (2, &#x27;王五&#x27;), (3, &#x27;赵六&#x27;)]</span><br></pre></td></tr></table></figure>
<h2 id="4-生成器">4. 生成器</h2>
<p>列表与生成器和迭代器的区别就是，列表需要占内存，而生成器和迭代器是将数据算出来的，不用将数据存储在内存当中。</p>
<p>生成器生成方法：</p>
<ul>
<li>使用推导式，只是将[]换成()</li>
<li>使用函数 + yield</li>
</ul>
<h3 id="4-1-推导式生成器">4.1 推导式生成器</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g = (x for x in range(100))</span><br><span class="line">print(type(g))</span><br><span class="line">print(g)</span><br><span class="line"></span><br><span class="line"># 调用生成器中的下一个元素</span><br><span class="line">print(next(g))</span><br></pre></td></tr></table></figure>
<p>判断 range 是否可迭代、迭代器、生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections.abc import Iterable, Iterator, Generator</span><br><span class="line"></span><br><span class="line">r = range(10)</span><br><span class="line">print(isinstance(r, Iterable))</span><br><span class="line">print(isinstance(r, Iterator))</span><br><span class="line">print(isinstance(r, Generator))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以range只是一个可迭代对象，而不是迭代器，也不是生成器</p>
</blockquote>
<p>再来看看用生成器生成的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g = (x for x in range(100))</span><br><span class="line">print(isinstance(g, Iterable))</span><br><span class="line">print(isinstance(g, Iterator))</span><br><span class="line">print(isinstance(g, Generator))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h3 id="4-2-函数-yield">4.2 函数 + yield</h3>
<p>yield 类似于 return，当碰到 return，我们会将 return 后边的变量作为返回值返回给函数。而 yield 则将跟随的变量作为一个生成器对象返回给函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        yield i</span><br><span class="line">        print(&#x27;-------&gt;&#x27;i)</span><br><span class="line"></span><br><span class="line">g = fun()</span><br><span class="line">print(g)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&lt;generator object fun at 0x016ACD10&gt;</span><br></pre></td></tr></table></figure>
<p>调用 next 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        yield i</span><br><span class="line">        print(&#x27;-------&gt;&#x27;i)</span><br><span class="line"></span><br><span class="line">g = fun()</span><br><span class="line">print(g)</span><br><span class="line">print(next(g))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&lt;generator object fun at 0x008BDCD8&gt;</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到只输出了第一个返回值0，并没有输出 yield 后边的代码，因为 yield 有两个功能，一个是暂停，另外一个是给出返回值</p>
</blockquote>
<p>当第二次执行 next 时，程序会返回到之前暂停的位置，然后继续执行后边的代码，再次进入循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        yield i</span><br><span class="line">        print(&#x27;-------&gt;&#x27;i)</span><br><span class="line"></span><br><span class="line">g = fun()</span><br><span class="line">print(g)</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&lt;generator object fun at 0x008BDCD8&gt;</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>send 方法，将参数传送给函数中 yield</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fun():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        x = yield i</span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line">g = fun()</span><br><span class="line">g.send(None)</span><br><span class="line">g.send(10)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一次send必须传入空值，因为第一次 yield 返回 i，但是还没有进行赋值操作，所以此时 yield 是空值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 菲波那切数列</span><br><span class="line">def Fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &#x27;亲！没有数据了...&#x27;</span><br><span class="line"># 调用方法，生成出10个数来</span><br><span class="line">f=Fib(10)</span><br><span class="line"># 使用一个循环捕获最后return 返回的值，保存在异常StopIteration的value中</span><br><span class="line">while  True:</span><br><span class="line">    try:</span><br><span class="line">        x=next(f)</span><br><span class="line">        print(&quot;f:&quot;,x)</span><br><span class="line">    except StopIteration as e:</span><br><span class="line">        print(&quot;生成器最后的返回值是：&quot;,e.value)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<p>通过生成器 yield 实现协程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def study():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&#x27;学习中------&gt;&#x27;, i)</span><br><span class="line">        yield</span><br><span class="line"></span><br><span class="line">def listen():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&#x27;音乐中------&gt;&#x27;, i)</span><br><span class="line">        yield</span><br><span class="line"></span><br><span class="line">def wechat():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&#x27;聊天中------&gt;&#x27;, i)</span><br><span class="line">        yield</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 = study()</span><br><span class="line">c2 = listen()</span><br><span class="line">c3 = wechat()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    c1.__next__()</span><br><span class="line">    c2.__next__()</span><br><span class="line">    c3.__next__()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行函数的时候碰到 yield 就会暂停函数，然后返回给赋值对象。然后一直调用 next 就可以简单实现协程效果。切换运行的代码块。</p>
</blockquote>
<h3 id="4-3-迭代器和生成器">4.3 迭代器和生成器</h3>
<ul>
<li>
<p>迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
</li>
<li>
<p>生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
</li>
</ul>
<h1>十七、异常处理</h1>
<p>在编写程序的时候，程序经常会报错，我们称这些报错信息为异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果用户输入了字符串，程序会报错</span><br><span class="line">num = int(input(&quot;请输入一个整数： &quot;))</span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>
<h2 id="1-简单的捕获异常语法">1. 简单的捕获异常语法</h2>
<ul>
<li>在程序开发中，如果 <strong>对某些代码的执行不能确定是否正确</strong>，可以增加 <code>try(尝试)</code> 来 <strong>捕获异常</strong></li>
<li>捕获异常最简单的语法格式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    尝试执行的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    出现错误的处理</span><br></pre></td></tr></table></figure>
<ul>
<li><code>try</code> <strong>尝试</strong>，下方编写要尝试代码，不确定是否能够正常执行的代码</li>
<li><code>except</code> <strong>如果不是</strong>，下方编写尝试失败的代码</li>
</ul>
<h2 id="2-简单异常捕获演练">2. 简单异常捕获演练</h2>
<p>要求用户输入整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 提示用户输入一个数字</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id=""></h3>
<h2 id="3-异常处理完整写法">3. 异常处理完整写法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    #正常代码</span><br><span class="line"></span><br><span class="line">except:</span><br><span class="line">    #异常代码返回</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">    # 没有异常才会执行的代码</span><br><span class="line">    </span><br><span class="line">finally:</span><br><span class="line">    #无论如何都会执行</span><br></pre></td></tr></table></figure>
<h2 id="4-错误类型捕获">4. 错误类型捕获</h2>
<ul>
<li>在程序执行时，可能会遇到 <strong>不同类型的异常</strong>，并且需要 <strong>针对不同类型的异常，做出不同的响应</strong>，这个时候，就需要捕获错误类型了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    # 尝试执行的代码</span><br><span class="line">    pass</span><br><span class="line">except 错误类型1:</span><br><span class="line">    # 针对错误类型1，对应的代码处理</span><br><span class="line">    pass</span><br><span class="line">except (错误类型2, 错误类型3):</span><br><span class="line">    # 针对错误类型2 和 3，对应的代码处理</span><br><span class="line">    pass</span><br><span class="line">except Exception as result:</span><br><span class="line">    print(&quot;未知错误 %s&quot; % result)</span><br></pre></td></tr></table></figure>
<p>内置异常代码列表</p>
<table>
<thead>
<tr>
<th>AssertionError</th>
<th>断言语句（assert）失败</th>
</tr>
</thead>
<tbody>
<tr>
<td>AttributeError</td>
<td>尝试访问未知的对象属性</td>
</tr>
<tr>
<td>EOFError</td>
<td>用户输入文件末尾标志EOF（Ctrl+d）</td>
</tr>
<tr>
<td>FloatingPointError</td>
<td>浮点计算错误</td>
</tr>
<tr>
<td>GeneratorExit</td>
<td>generator.close()方法被调用的时候</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块失败的时候</td>
</tr>
<tr>
<td>IndexError</td>
<td>索引超出序列的范围</td>
</tr>
<tr>
<td>KeyError</td>
<td>字典中查找一个不存在的关键字</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>用户输入中断键（Ctrl+c）</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出（可通过删除对象释放内存）</td>
</tr>
<tr>
<td>NameError</td>
<td>尝试访问一个不存在的变量</td>
</tr>
<tr>
<td>NotImplementedError</td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统产生的异常（例如打开一个不存在的文件）</td>
</tr>
<tr>
<td>OverflowError</td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象</td>
</tr>
<tr>
<td>RuntimeError</td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td>StopIteration</td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python的语法错误</td>
</tr>
<tr>
<td>IndentationError</td>
<td>缩进错误</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab和空格混合使用</td>
</tr>
<tr>
<td>SystemError</td>
<td>Python编译器系统错误</td>
</tr>
<tr>
<td>SystemExit</td>
<td>Python编译器进程被关闭</td>
</tr>
<tr>
<td>TypeError</td>
<td>不同类型间的无效操作</td>
</tr>
<tr>
<td>UnboundLocalError</td>
<td>访问一个未初始化的本地变量（NameError的子类）</td>
</tr>
<tr>
<td>UnicodeError</td>
<td>Unicode相关的错误（ValueError的子类）</td>
</tr>
<tr>
<td>UnicodeEncodeError</td>
<td>Unicode编码时的错误（UnicodeError的子类）</td>
</tr>
<tr>
<td>UnicodeDecodeError</td>
<td>Unicode解码时的错误（UnicodeError的子类）</td>
</tr>
<tr>
<td>UnicodeTranslateError</td>
<td>Unicode转换时的错误（UnicodeError的子类）</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>ZeroDivisionError</td>
<td>除数为零</td>
</tr>
</tbody>
</table>
<h2 id="5-捕获未知错误">5. 捕获未知错误</h2>
<ul>
<li>在开发时，<strong>要预判到所有可能出现的错误</strong>，还是有一定难度的</li>
<li>如果希望程序 <strong>无论出现任何错误</strong>，都不会因为 <code>Python</code> 解释器 <strong>抛出异常而被终止</strong>，可以再增加一个 <code>except</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">except Exception as result:</span><br><span class="line">    print(&quot;未知错误 %s&quot; % result)</span><br></pre></td></tr></table></figure>
<h2 id="6-异常的传递">6. 异常的传递</h2>
<p>当函数/方法执行出现异常会 <strong>将异常传递</strong> 给 函数/方法 的 <strong>调用一方</strong>。如果 <strong>传递到主程序</strong>，仍然 <strong>没有异常处理</strong>，程序才会被终止</p>
<ul>
<li>在开发中，可以在主函数中增加 <strong>异常捕获</strong></li>
<li>而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 <strong>异常捕获</strong> 中</li>
<li>这样就不需要在代码中，增加大量的 <strong>异常捕获</strong>，能够保证代码的整洁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def demo1():</span><br><span class="line">    return int(input(&quot;请输入一个整数：&quot;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def demo2():</span><br><span class="line">    return demo1()</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    print(demo2())</span><br><span class="line">except ValueError:</span><br><span class="line">    print(&quot;请输入正确的整数&quot;)</span><br><span class="line">except Exception as result:</span><br><span class="line">    print(&quot;未知错误 %s&quot; % result)</span><br></pre></td></tr></table></figure>
<h2 id="7-抛出异常">7. 抛出异常</h2>
<ul>
<li><code>Python</code> 中提供了一个 <code>Exception</code> <strong>异常类</strong></li>
<li>在开发时，如果满足 <strong>特定业务需求时</strong>，希望 <strong>抛出异常</strong>，可以：
<ol>
<li><strong>创建</strong> 一个 <code>Exception</code> 的 <strong>对象</strong></li>
<li>使用 <code>raise</code> <strong>关键字</strong> 抛出 <strong>异常对象</strong></li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def input_password():</span><br><span class="line"></span><br><span class="line">    # 1. 提示用户输入密码</span><br><span class="line">    pwd = input(&quot;请输入密码：&quot;)</span><br><span class="line"></span><br><span class="line">    # 2. 判断密码长度，如果长度 &gt;= 8，返回用户输入的密码</span><br><span class="line">    if len(pwd) &gt;= 8:</span><br><span class="line">        return pwd</span><br><span class="line"></span><br><span class="line">    # 3. 密码长度不够，需要抛出异常</span><br><span class="line">    # 1&gt; 创建异常对象 - 使用异常的错误信息字符串作为参数</span><br><span class="line">    ex = Exception(&quot;密码长度不够&quot;)</span><br><span class="line"></span><br><span class="line">    # 2&gt; 抛出异常对象</span><br><span class="line">    raise ex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    user_pwd = input_password()</span><br><span class="line">    print(user_pwd)</span><br><span class="line">except Exception as result:</span><br><span class="line">    print(&quot;发现错误：%s&quot; % result)</span><br></pre></td></tr></table></figure>
<p>可以直接创建自定义异常类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LenthError(Exception):</span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &#x27;长度必须要在&#123;&#125;至&#123;&#125;之间&#x27;.format(self.x, self.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">password = input(&#x27;Please input your password:&#x27;)</span><br><span class="line">m = 6</span><br><span class="line">n = 12</span><br><span class="line">if m &lt;= len(password) &lt;= n:</span><br><span class="line">    print(&#x27;密码正确&#x27;)</span><br><span class="line">else</span><br><span class="line">    raise LenthError(m,n)</span><br></pre></td></tr></table></figure>
<h1>十八、模块</h1>
<h2 id="1-什么是模块">1. 什么是模块</h2>
<p>模块就是我们的 python 文件，将一些 function 或 class 写入文件，方便其他 python 文件调用。</p>
<blockquote>
<p><strong>模块是 Python 程序架构的一个核心概念</strong></p>
</blockquote>
<ul>
<li>每一个以扩展名 <code>py</code> 结尾的 <code>Python</code> 源代码文件都是一个 <strong>模块</strong></li>
<li><strong>模块名</strong> 同样也是一个 <strong>标识符</strong>，需要符合标识符的命名规则</li>
<li>在模块中定义的 <strong>全局变量</strong> 、<strong>函数</strong>、<strong>类</strong> 都是提供给外界直接使用的 <strong>工具</strong></li>
<li><strong>模块</strong> 就好比是 <strong>工具包</strong>，要想使用这个工具包中的工具，就需要先 <strong>导入</strong> 这个模块</li>
</ul>
<p>如随机模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">print(random.randint(0, 10))</span><br></pre></td></tr></table></figure>
<h2 id="2-导入模块的几种方式">2. 导入模块的几种方式</h2>
<p>import 导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import 模块名1</span><br><span class="line">import 模块名2 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：在导入模块时，每个导入应该独占一行</p>
</blockquote>
<p><strong>导入之后</strong></p>
<ul>
<li>通过 <code>模块名.</code> 使用 <strong>模块提供的工具</strong> —— <strong>全局变量</strong>、<strong>函数</strong>、<strong>类</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import easygui</span><br><span class="line">easygui.draw()</span><br></pre></td></tr></table></figure>
<p>使用 <code>as</code> 指定模块的别名</p>
<blockquote>
<p><strong>如果模块的名字太长</strong>，可以使用 <code>as</code> 指定模块的名称，以方便在代码中的使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import 模块名1 as 模块别名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<strong>模块别名</strong> 应该符合 <strong>大驼峰命名法</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import easygui as g</span><br><span class="line">g.draw()</span><br></pre></td></tr></table></figure>
<p>from…import 导入</p>
<p>如果希望 <strong>从某一个模块</strong> 中，导入 <strong>部分</strong> 工具，就可以使用 <code>from ... import</code> 的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从 模块 导入 某一个工具</span><br><span class="line">from 模块名1 import 工具名</span><br></pre></td></tr></table></figure>
<p>导入之后</p>
<ul>
<li><strong>不需要</strong> 通过 <code>模块名.</code></li>
<li>可以直接使用 <strong>模块提供的工具</strong> —— <strong>全局变量</strong>、<strong>函数</strong>、<strong>类</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from easygui import *</span><br><span class="line">draw()</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<blockquote>
<p>如果 <strong>两个模块</strong>，存在 <strong>同名的函数</strong>，那么 <strong>后导入模块的函数</strong>，会 <strong>覆盖掉先导入的函数</strong></p>
</blockquote>
<ul>
<li>开发时 <code>import</code> 代码应该统一写在 <strong>代码的顶部</strong>，更容易及时发现冲突</li>
<li>一旦发现冲突，可以使用 <code>as</code> 关键字 <strong>给其中一个工具起一个别名</strong></li>
</ul>
<h2 id="3-创建一个模块">3. 创建一个模块</h2>
<p>创建一个 <a target="_blank" rel="noopener" href="http://hello.py">hello.py</a> 的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def hello():</span><br><span class="line">    print(&#x27;hello world&#x27;)</span><br></pre></td></tr></table></figure>
<p>再同一个目录下创建另一个 py 文件，然后引入 hello 模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hello</span><br><span class="line">hello.hello()</span><br></pre></td></tr></table></figure>
<h2 id="4-模块的搜索顺序">4. 模块的搜索顺序</h2>
<ol>
<li>搜索 <strong>当前目录</strong> 指定模块名的文件，<strong>如果有就直接导入</strong></li>
<li>如果没有，再搜索 <strong>系统目录</strong></li>
</ol>
<blockquote>
<p>在开发时，给文件起名，不要和 <strong>系统的模块文件</strong> <strong>重名</strong></p>
</blockquote>
<p><code>Python</code> 中每一个模块都有一个内置属性 <code>__file__</code> 可以 <strong>查看模块</strong> 的 <strong>完整路径</strong></p>
<h2 id="5-查看模块的使用方法">5. 查看模块的使用方法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir(timeit)  # 查看模块包含的类</span><br><span class="line">timeit.__all__  # 查看可供调用的外部函数</span><br><span class="line">timeit.__doc__  # 查看使用说明</span><br><span class="line">timeit.__file__  # 查看模块路径</span><br><span class="line">help(timeit)  # 查看使用说明详细版</span><br></pre></td></tr></table></figure>
<h2 id="6-模块内测试代码">6. 模块内测试代码</h2>
<p>_<em>name</em>_ 属性</p>
<blockquote>
<ul>
<li><code>__name__</code> 属性可以做到，测试模块的代码 <strong>只在测试情况下被运行</strong>，而在 <strong>被导入时不会被执行</strong>！</li>
</ul>
</blockquote>
<ul>
<li><code>__name__</code> 是 <code>Python</code> 的一个内置属性，记录着一个 <strong>字符串</strong></li>
<li>如果 <strong>是被其他文件导入的</strong>，<code>__name__</code> 就是 <strong>模块名</strong></li>
<li>如果 <strong>是当前执行的程序</strong> <code>__name__</code> 是 <strong><code>__main__</code></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"># 指的代码运行在本程序中，那么就执行，如果是作为导入模块，则不执行</span><br></pre></td></tr></table></figure>
<h2 id="7-包-Package">7. 包 Package</h2>
<p>包是一个包含多个模块的特殊目录</p>
<p>目录名下有一个特殊的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__init__.py</span><br><span class="line"># 需要在外界使用包的时候，需要在 __init__.py 文件中提供模块列表</span><br><span class="line">from . import send_message</span><br><span class="line">from . import receive_message</span><br></pre></td></tr></table></figure>
<blockquote>
<p>包命名方式和变量名一致，小写字母加下划线</p>
</blockquote>
<p>使用 import 包名可以一次性导入包中所有的模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># m1 是文件夹，easygui.py 是里边的一个模块，另外需要在m1中创建一个 __init__.py的文件</span><br><span class="line">import m1.easygui as e</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<ol>
<li>新建一个 hm_message 的包</li>
<li>创建两个模块 send_message, receive_message</li>
<li>在 send_message 创建一个函数 send</li>
<li>在 receive_message 创建一个函数 receive</li>
<li>在外部导入包 hm_message 包</li>
</ol>
<h2 id="8-pip-安装第三方模块">8. pip 安装第三方模块</h2>
<ul>
<li><strong>第三方模块</strong> 通常是指由 <strong>知名的第三方团队</strong> <strong>开发的</strong> 并且被 <strong>程序员广泛使用</strong> 的 <code>Python</code> 包 / 模块
<ul>
<li>例如 <code>pygame</code> 就是一套非常成熟的 <strong>游戏开发模块</strong></li>
</ul>
</li>
<li><code>pip</code> 是一个现代的，通用的 <code>Python</code> 包管理工具</li>
<li>提供了对 <code>Python</code> 包的查找、下载、安装、卸载等功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install</span><br><span class="line">pip install --upgrade</span><br><span class="line">pip uninsall</span><br><span class="line">pip list</span><br><span class="line">pip show</span><br></pre></td></tr></table></figure>
<p>pip 其他参数：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python-pip-install-usage.html">https://www.runoob.com/w3cnote/python-pip-install-usage.html</a></p>
<p>pip 换源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>pip 源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">阿里云 http://mirrors.aliyun.com/pypi/simple/ </span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ </span><br><span class="line">豆瓣(douban) http://pypi.douban.com/simple/ </span><br><span class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ </span><br><span class="line">中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure>
<h4 id="Pycharm-安装模块">Pycharm 安装模块</h4>
<p>File - Settings - Project - Project Interpreter - 选择环境 - 按加号安装</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/47.jpg" alt="image-20200716201955655"></p>
<h1>十九、文件处理</h1>
<h2 id="1-文件的基本操作">1. 文件的基本操作</h2>
<p>在计算机中要操作文件的套路十分固定，一共包含三个步骤：</p>
<ol>
<li>打开文件</li>
<li>读、写文件</li>
<li>关闭文件</li>
</ol>
<h2 id="2-操作文件的函数-方法">2. 操作文件的函数/方法</h2>
<p>Python 中药操作文件需要记住1个函数和3个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open	打开文件，并且返回文件操作对象</span><br><span class="line">read	将文件内容读取到内存</span><br><span class="line">wrtie	将制定内容写入文件</span><br><span class="line">close	关闭文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>open 函数负责打开文件，并且返回文件对象</p>
<p>read/write/close 三个方法都需要通过文件对象来调用</p>
</blockquote>
<p>打开文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file = open(&quot;E:\\file.txt&quot;,&#x27;读取参数&#x27;)</span><br></pre></td></tr></table></figure>
<p>关闭文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<h2 id="3-读取文件-read">3. 读取文件 read()</h2>
<p>open 函数的第一个参数时要打开的文件名</p>
<ul>
<li>如果文件存在，返回文件操作对象</li>
<li>如果文件不存在，抛出异常</li>
</ul>
<p>read 方法可以一次性读入并返回文件的所有内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file = open(&quot;README.md&quot;)</span><br><span class="line">text = file.read()</span><br><span class="line">print(text)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<p>文件指针</p>
<p>文件指针标记从哪个位置开始读取数据</p>
<p>第一次打开文件时，通常指针会指向文件开始的位置，当执行了read 方法后，文件指针会移动到读取内容的末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file = open(&quot;random.txt&quot;)</span><br><span class="line">text = file.read()</span><br><span class="line">text1 = file.read()  </span><br><span class="line">print(text1)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针已经在上次调用 read() 方法时到了末尾，无法再读取内容，输出内容为空</p>
</blockquote>
<h2 id="4-打开文件模式">4. 打开文件模式</h2>
<p>open 函数默认以只读方式打开文件，并且返回文件对象。open 函数还支持其他访问方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;文件名&quot;, &quot;访问方式&quot;)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>打开模式</strong></th>
<th><strong>执行操作</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>‘r’</td>
<td>以只读方式打开文件（默认）</td>
</tr>
<tr>
<td>‘w’</td>
<td>以写入的方式打开文件，会覆盖已存在的文件</td>
</tr>
<tr>
<td>‘x’</td>
<td>如果文件已经存在，使用此模式打开将引发异常</td>
</tr>
<tr>
<td>‘a’</td>
<td>以写入模式打开，如果文件存在，则在末尾追加写入</td>
</tr>
<tr>
<td>‘b’</td>
<td>以二进制模式打开文件</td>
</tr>
<tr>
<td>‘t’</td>
<td>以文本模式打开（默认）</td>
</tr>
<tr>
<td>‘+’</td>
<td>可读写模式（可添加到其他模式中使用）</td>
</tr>
<tr>
<td>‘U’</td>
<td>通用换行符支持</td>
</tr>
</tbody>
</table>
<h3 id="4-1-with-上下文管理器">4.1 with 上下文管理器</h3>
<p>with 关键词是一个上下文管理器，经常与文件打开配合，如： <code>with open</code> ，用来自动关闭文件。如果一个程序中需要打开多个文件，那么打开太多文件的话，会出现错误 too many open files。用 with 关键字配合 open 后，会自动关闭文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with open(&#x27;files.txt&#x27;, &#x27;w&#x27;) as fp:</span><br><span class="line">	fp.write(&#x27;something&#x27;)</span><br></pre></td></tr></table></figure>
<ul>
<li>with 语句后边跟一个对象</li>
<li>当进入with代码块时，会自动调用对象中的 <code>__enter__</code> 方法</li>
<li>当 with 代码块结束的时候，会自动调用 <code>__exit__</code> 方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Demo():</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(&#x27;enter方法被调用了&#x27;)</span><br><span class="line">    def __exit__(self, exc_type, exc_val, exc_tb):</span><br><span class="line">        print(&#x27;exit方法被调用了&#x27;)</span><br><span class="line"></span><br><span class="line">def create_job():</span><br><span class="line">    return Demo()</span><br><span class="line"></span><br><span class="line">with Demo() as d:</span><br><span class="line">    print(d)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的 d 不是 Demo() 对象，而是类中 <code>__enter__</code>方法的返回值</p>
</blockquote>
<h2 id="5-写入文件">5. 写入文件</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打开文件</span><br><span class="line">f = open(&quot;README&quot;, &quot;w&quot;)</span><br><span class="line"></span><br><span class="line">f.write(&quot;hello python！\n&quot;)</span><br><span class="line">f.write(&quot;今天天气真好&quot;)</span><br><span class="line"></span><br><span class="line"># 关闭文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>用 print 函数也可以直接写入文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;hello&#x27;, file=open(&#x27;ss.txt&#x27;, &#x27;w&#x27;))</span><br></pre></td></tr></table></figure>
<h2 id="6-按行读取文件-readline">6. 按行读取文件 readline</h2>
<ul>
<li><code>read</code> 方法默认会把文件的 <strong>所有内容</strong> <strong>一次性读取到内存</strong></li>
<li>如果文件太大，对内存的占用会非常严重</li>
</ul>
<p><code>readline</code> 方法</p>
<ul>
<li><code>readline</code> 方法可以一次读取一行内容</li>
<li>方法执行后，会把 <strong>文件指针</strong> 移动到下一行，准备再次读取</li>
</ul>
<p>读取大文件的正确姿势</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打开文件</span><br><span class="line">file = open(&quot;README&quot;)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # 读取一行内容</span><br><span class="line">    text = file.readline()</span><br><span class="line"></span><br><span class="line">    # 判断是否读到内容</span><br><span class="line">    if not text:</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">    # 每读取一行的末尾已经有了一个 `\n`</span><br><span class="line">    print(text, end=&quot;&quot;)</span><br><span class="line"></span><br><span class="line"># 关闭文件</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<h2 id="7-复制文件">7. 复制文件</h2>
<p>小文件复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 打开文件</span><br><span class="line">file_read = open(&quot;README&quot;)</span><br><span class="line">file_write = open(&quot;README[复件]&quot;, &quot;w&quot;)</span><br><span class="line"></span><br><span class="line"># 2. 读取并写入文件</span><br><span class="line">text = file_read.read()</span><br><span class="line">file_write.write(text)</span><br><span class="line"></span><br><span class="line"># 3. 关闭文件</span><br><span class="line">file_read.close()</span><br><span class="line">file_write.close()</span><br></pre></td></tr></table></figure>
<p>大文件复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 打开文件</span><br><span class="line">file_read = open(&quot;README&quot;)</span><br><span class="line">file_write = open(&quot;README[复件]&quot;, &quot;w&quot;)</span><br><span class="line"></span><br><span class="line"># 2. 读取并写入文件</span><br><span class="line">while True:</span><br><span class="line">    # 每次读取一行</span><br><span class="line">    text = file_read.readline()</span><br><span class="line"></span><br><span class="line">    # 判断是否读取到内容</span><br><span class="line">    if not text:</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">    file_write.write(text)</span><br><span class="line"></span><br><span class="line"># 3. 关闭文件</span><br><span class="line">file_read.close()</span><br><span class="line">file_write.close()</span><br></pre></td></tr></table></figure>
<h2 id="文件对象的其他方法">文件对象的其他方法</h2>
<p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">file.close()关闭文件。关闭后文件不能再进行读写操作。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。<strong>只有关闭文件才会从缓存中写入文件。</strong></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">file.next()返回文件下一行。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">[file.read(size])从文件读取指定的字节数，如果未给定或为负则读取所有。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">[file.readline(size])读取整行，包括 “\n” 字符。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">[file.readlines(sizeint])读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">[file.seek(offset, whence])设置文件当前位置**（参数是文本的字节数）**</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">file.tell()返回文件当前位置。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">[file.truncate(size])截取文件，截取的字节通过size指定，默认为当前文件位置。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">file.write(str)将字符串写入文件，返回的是写入的字符长度。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td>
</tr>
</tbody>
</table>
<h2 id="文件读取时经常出现的-GBK-错误是什么？">文件读取时经常出现的 GBK 错误是什么？</h2>
<p>在读取文件的时候，经常会出现如下错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnicodeDecodeError: &#x27;gbk&#x27; codec can&#x27;t decode byte 0x98 in position 18: illegal multibyte sequence</span><br></pre></td></tr></table></figure>
<p>修复错误的方法也很简单，只要在打开文件的时候加上 <code>encoding='utf8'</code> 就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&#x27;ss.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf8&#x27;)</span><br><span class="line">print(f.readline())</span><br></pre></td></tr></table></figure>
<p>很多人都知道解决办法，却不知道为什么会报错，从 python3 开始，文件的存储都是以 UTF8 格式存储的，那么这个 GBK 错误是怎么来的？主要是因为 UTF-8 占3个字节，读取造成了混乱。</p>
<h2 id="8-OS-模块">8. OS 模块</h2>
<p>在 <code>Python</code> 中，如果希望通过程序实现创建、重命名、删除、改变路径、查看目录内容功能，需要导入 <code>os</code> 模块</p>
<h2 id="8-1-文件操作">8.1 文件操作</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法名</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>rename</td>
<td>重命名文件</td>
<td><code>os.rename(源文件名, 目标文件名)</code></td>
</tr>
<tr>
<td>02</td>
<td>remove</td>
<td>删除文件</td>
<td><code>os.remove(文件名)</code></td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">os.rename(&quot;random.txt&quot;, &quot;random1.txt&quot;)</span><br><span class="line">os.remove(&quot;random1.txt&quot;)</span><br></pre></td></tr></table></figure>
<p>拷贝文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from shutil import copyfile</span><br><span class="line"></span><br><span class="line"># 拷贝 d:/tools/first.py 到 e:/first.py</span><br><span class="line">copyfile(&#x27;d:/tools/first.py&#x27;, &#x27;e:/first.py&#x27;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果拷贝前，e:/first.py 已经存在，则会被拷贝覆盖，所以使用该函数一定要小心。</p>
</blockquote>
<h2 id="8-2-目录操作">8.2 目录操作</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法名</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>listdir</td>
<td>目录列表</td>
<td><code>os.listdir(目录名)</code></td>
</tr>
<tr>
<td>02</td>
<td>mkdir</td>
<td>创建目录</td>
<td><code>os.mkdir(目录名)</code></td>
</tr>
<tr>
<td>03</td>
<td>rmdir</td>
<td>删除目录</td>
<td><code>os.rmdir(目录名)</code></td>
</tr>
<tr>
<td>04</td>
<td>getcwd</td>
<td>获取当前目录</td>
<td><code>os.getcwd()</code></td>
</tr>
<tr>
<td>05</td>
<td>chdir</td>
<td>修改工作目录</td>
<td><code>os.chdir(目标目录)</code></td>
</tr>
<tr>
<td>06</td>
<td>path.isdir</td>
<td>判断是否是文件</td>
<td><code>os.path.isdir(文件路径)</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>提示：文件或者目录操作都支持 <strong>相对路径</strong> 和 <strong>绝对路径</strong></p>
</blockquote>
<p>递归的创建目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">os.makedirs(&#x27;tmp/python/fileop&#x27;,exist_ok=True)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会在当前工作目录下面创建 tmp目录，在tmp目录下面再创建 python目录，在Python目录下面再创建fileop目录<code>exist_ok=True</code> 指定了，如果某个要创建的目录已经存在，也不报错</p>
</blockquote>
<p>递归删除目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shutil.rmtree()</span><br><span class="line">shutil.rmtree(&#x27;tmp&#x27;)</span><br></pre></td></tr></table></figure>
<p>递归拷贝目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from shutil import copytree</span><br><span class="line"></span><br><span class="line"># 拷贝 d:/tools/aaa 目录中所有的内容 到 e:/bbb 中</span><br><span class="line">copytree(&#x27;d:/tools/aaa&#x27;, &#x27;e:/new/bbb&#x27;)</span><br></pre></td></tr></table></figure>
<p>注意拷贝前， 目标目录必须 <code>不存在</code> ，否则会报错。</p>
<p>上面的代码执行前面，如果 e:/new/bbb 已经存在，执行到copytree时，就会报错</p>
<p>上面的代码执行前面，如果 e:/new 这个目录都不存在，执行到copytree时，就会 创建 e:/new 目录，再创建 e:/new/bbb 目录，再拷贝 d:/tools/aaa 目录中所有的内容 到 e:/new/bbb 中。</p>
<p>上面的代码执行前面，如果 e:/new 这个目录存在，但是 e:/new/bbb 不存在，执行到copytree时，就只会 创建 e:/new/bbb ，再拷贝 d:/tools/aaa 目录中所有的内容 到 e:/new/bbb 中。</p>
<h2 id="8-3-路径操作">8.3 路径操作</h2>
<p>对于文件名的操作，比如 获取文件名称，文件所在目录，文件路径的拼接等，都可以使用 os.path 模块。如果你的程序需要在Linux、Windows等多个平台运行，它们的路径的分隔符是不同的，Windows上是 <code>\</code> , 而 Linux上是 <code>/</code>。这时，我们应该使用 os.path 模块。 它能够自动处理类似 Data/data.csv 和 Data\data.csv 这样的文件路径差异。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">path = &#x27;/Users/forece/Data/data.csv&#x27;</span><br><span class="line"></span><br><span class="line"># 获取路径中的文件名部分</span><br><span class="line">print(os.path.basename(path))</span><br><span class="line"></span><br><span class="line"># 获取路径中的目录部分</span><br><span class="line">print(os.path.dirname(path))</span><br><span class="line"></span><br><span class="line"># 文件路径的拼接</span><br><span class="line">os.path.join(&#x27;tmp&#x27;, &#x27;data&#x27;, os.path.basename(path))</span><br><span class="line"></span><br><span class="line"># 输出内容</span><br><span class="line">data.csv</span><br><span class="line">/Users/forece/Data</span><br><span class="line">tmp\data\data.csv</span><br></pre></td></tr></table></figure>
<p>判断文件、目录是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">print(os.path.exists(&#x27;d:/systems/cmd.exe&#x27;))</span><br><span class="line">print(os.path.exists(&#x27;d:/systems&#x27;))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>exists方法返回值为True表示 存在，否则表示不存在。</p>
</blockquote>
<p>判断是否是文件、目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">print(os.path.isfile(&#x27;d:/systems/cmd.exe&#x27;))</span><br><span class="line">print(os.path.isdir(&#x27;d:/systems&#x27;))</span><br></pre></td></tr></table></figure>
<p>判断文件大小、修改日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 返回文件大小</span><br><span class="line">print(os.path.getsize(&#x27;file1.txt&#x27;) )</span><br><span class="line"></span><br><span class="line"># 返回文件的最后修改日期，是秒时间</span><br><span class="line">print(os.path.getmtime(&#x27;file1.txt&#x27;))</span><br><span class="line">1272478234.0</span><br><span class="line"></span><br><span class="line"># 可以把秒时间 转化为日期时间</span><br><span class="line">import time</span><br><span class="line">print(time.ctime(os.path.getmtime(&#x27;/etc/passwd&#x27;)))</span><br></pre></td></tr></table></figure>
<p>返回当前目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cwd = os.getcwd()</span><br></pre></td></tr></table></figure>
<p>更改当前目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.chdir(path)</span><br></pre></td></tr></table></figure>
<h2 id="8-4-遍历目录-文件">8.4 遍历目录/文件</h2>
<p>假如我们要获取某个目录中所有的 文件， 包括子目录里面的文件。 可以使用 os库中的walk方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 目标目录</span><br><span class="line">targetDir = r&#x27;d:\tmp\util\dist\check&#x27;</span><br><span class="line">files = []</span><br><span class="line">dirs  = []</span><br><span class="line"></span><br><span class="line"># 下面的三个变量 dirpath, dirnames, filenames</span><br><span class="line"># dirpath 代表当前遍历到的目录名</span><br><span class="line"># dirnames 是列表对象，存放当前dirpath中的所有子目录名</span><br><span class="line"># filenames 是列表对象，存放当前dirpath中的所有文件名</span><br><span class="line"></span><br><span class="line">for (dirpath, dirnames, filenames) in os.walk(targetDir):</span><br><span class="line">   files += filenames</span><br><span class="line">   dirs += dirnames</span><br><span class="line"></span><br><span class="line">print(files)</span><br><span class="line">print(dirs)</span><br></pre></td></tr></table></figure>
<p>得到目录中所有的文件和子目录名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 目标目录</span><br><span class="line">targetDir = r&#x27;d:\tmp\util\dist\check&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files =  os.listdir(targetDir)</span><br><span class="line">print(files)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>listdir返回的是该目录下面所有的文件和子目录。</p>
</blockquote>
<p>如果我们只需要获取目录中所有的文件，或者只需要子目录，可以这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">from os.path import isfile, join,isdir</span><br><span class="line"></span><br><span class="line"># 目标目录</span><br><span class="line">targetDir = r&#x27;d:\tmp\util\dist\check&#x27;</span><br><span class="line"></span><br><span class="line"># 所有的文件</span><br><span class="line">print([f for f in os.listdir(targetDir) if isfile(join(targetDir, f))])</span><br><span class="line"></span><br><span class="line"># 所有的目录</span><br><span class="line">print([f for f in os.listdir(targetDir) if isdir(join(targetDir, f))])</span><br></pre></td></tr></table></figure>
<p>得到目录中指定扩展名的文件和子目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以使用glob库</span><br><span class="line">import glob</span><br><span class="line">exes = glob.glob(r&#x27;d:\tmp\*.txt&#x27;)</span><br><span class="line"></span><br><span class="line">print(exes)</span><br></pre></td></tr></table></figure>
<h2 id="8-5-调用外部命令">8.5 调用外部命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">os.system(&quot;cmd&quot;)</span><br></pre></td></tr></table></figure>
<p>或者利用变量将命令写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">command = &quot;pip install pygame&quot;</span><br><span class="line">os.system(&quot;command&quot;)</span><br></pre></td></tr></table></figure>
<h1>二十、eval 函数</h1>
<p><code>eval()</code> 函数十分强大 —— <strong>将字符串</strong> 当成 <strong>有效的表达式</strong> 来求值 并 <strong>返回计算结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本的数学计算</span><br><span class="line">In [1]: eval(&quot;1 + 1&quot;)</span><br><span class="line">Out[1]: 2</span><br><span class="line"></span><br><span class="line"># 字符串重复</span><br><span class="line">In [2]: eval(&quot;&#x27;*&#x27; * 10&quot;)</span><br><span class="line">Out[2]: &#x27;**********&#x27;</span><br><span class="line"></span><br><span class="line"># 将字符串转换成列表</span><br><span class="line">In [3]: type(eval(&quot;[1, 2, 3, 4, 5]&quot;))</span><br><span class="line">Out[3]: list</span><br><span class="line"></span><br><span class="line"># 将字符串转换成字典</span><br><span class="line">In [4]: type(eval(&quot;&#123;&#x27;name&#x27;: &#x27;xiaoming&#x27;, &#x27;age&#x27;: 18&#125;&quot;))</span><br><span class="line">Out[4]: dict</span><br></pre></td></tr></table></figure>
<p>用 eval 制作一个计算器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input_str = input(&quot;请输入一个算术题：&quot;)</span><br><span class="line">print(eval(input_str))</span><br></pre></td></tr></table></figure>
<p>不要滥用 <code>eval</code></p>
<blockquote>
<p>在开发时千万不要使用 <code>eval</code> 直接转换 <code>input</code> 的结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>等价代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">&quot;终端命令&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>执行成功，返回 0</li>
<li>执行失败，返回错误信息</li>
</ul>
<h1>定时任务</h1>
<ul>
<li>打开计划任务</li>
<li>创建基本任务</li>
<li>输入名称及描述</li>
<li>设置触发时间</li>
<li>选择启动程序</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.xwysyy.cn/img-md/img-syntax/python/48.jpg" alt="image-20220306203513787"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Forece">Forece</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Forece">https://github.com/Forece</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">转载自https://github.com/Forece</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/syntax/">syntax</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/syntax/JavaScript/" title="JavaScript"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/42.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaScript</div></div></a></div><div class="next-post pull-right"><a href="/syntax/HTML/" title="HTML"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HTML</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/syntax/Git/" title="Git"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/43.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-02</div><div class="title">Git</div></div></a></div><div><a href="/syntax/CSS%E7%AC%94%E8%AE%B0/" title="CSS笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="title">CSS笔记</div></div></a></div><div><a href="/syntax/HTML/" title="HTML"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-22</div><div class="title">HTML</div></div></a></div><div><a href="/syntax/MySQL/" title="MySQL"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-02</div><div class="title">MySQL</div></div></a></div><div><a href="/syntax/CSS/" title="CSS"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/37.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-24</div><div class="title">CSS</div></div></a></div><div><a href="/syntax/LaTeX/" title="LaTeX"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/44.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-01</div><div class="title">LaTeX</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="cols"><div class="col"><div class="container"><div class="front avatarPanel"><div class="inner"><div class="player-title">Attributes</div><div class="player-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></div></div><div class="back attributesPanel"><div class="inner"><div class="player-lv">LV.3</div><div class="player-name">善良的xwysyy</div><div class="attributes-value"><div class="attributes-value-item"><a href="/archives/"><div class="attributes">文章</div><div class="value-bar"><div class="value-bar-fill" style="width:26.00%"><div class="value-bar-fill-in" style="background: rgba(89, 230, 54,0.6)"></div></div></div><span>26/100</span></a></div><div class="attributes-value-item"><a href="/tags/"><div class="attributes">标签</div><div class="value-bar"><div class="value-bar-fill" style="width:17.00%"><div class="value-bar-fill-in" style="background: rgba(224, 20, 20, 0.6)"></div></div></div><span>17/100</span></a></div><div class="attributes-value-item"><a href="/categories/"><div class="attributes">分类</div><div class="value-bar"><div class="value-bar-fill" style="width:7.00%"><div class="value-bar-fill-in" style="background: rgba(30, 97, 226, 0.6)"></div></div></div><span>7/100</span></a></div></div></div></div></div></div><div class="col"><div class="container"><div class="front descriptionPanel"><div class="inner"><div class="player_description"><p>一念净心 花开遍世界<br>每临绝境 峰回路又转<br>但凭净信 自在出乾坤<br>恰似如梦初醒 归途在眼前</p></div><div class="play-bottom"></div></div></div><div class="back buttonPanel"><div class="inner"><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xwysyy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xwysyy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_73844376" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:xwysyy@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><div class="play-bottom"></div></div></div></div></div></div></div><div class="card-widget card-announcement"><div id="welcome-info"></div><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>welcome</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">一、Python 起源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Python-%E7%AE%80%E5%8F%B2"><span class="toc-number">1.1.</span> <span class="toc-text">1. Python 简史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Python-%E5%88%9B%E5%A7%8B%E4%BA%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 Python 创始人</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Python-%E7%9A%84%E7%90%86%E5%BF%B5"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 Python 的理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Python-%E5%90%8D%E5%AD%97%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 Python 名字的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Python-%E4%B9%8B%E7%A6%85"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 Python 之禅</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Python-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">2. Python 的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Python-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 Python 优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Python-%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 Python 可以做什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">3. 解释器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Python-%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.4.</span> <span class="toc-text">4. Python 的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.5.</span> <span class="toc-text">5. 运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BA%A4%E4%BA%92%E5%BC%8F-Python"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 交互式 Python</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 集成开发环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Python-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.6.</span> <span class="toc-text">6. Python 命名规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 文件项目命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Python-%E6%89%8B%E5%86%8C%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 Python 手册命名规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Python-%E6%B3%A8%E9%87%8A%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">7. Python 注释方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 单行注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 多行注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 添加任务列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">1.8.</span> <span class="toc-text">8. 小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-shebang"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 shebang</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Python-2-x-%E5%85%BC%E5%AE%B9%E4%B8%AD%E6%96%87%EF%BC%9A"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 Python 2.x 兼容中文：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">二、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1. 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#id-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">id() 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-type-%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2. type() 查看数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-isinstance-%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3. isinstance() 判断数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.</span> <span class="toc-text">4. 数据类型的转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">三、 Print 输出函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">四、Input 输入函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">练习：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">五、帮助文档</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">六、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%AC%A6"><span class="toc-number">7.1.</span> <span class="toc-text">1. 数学计算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.2.</span> <span class="toc-text">2. 比较运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.3.</span> <span class="toc-text">3. 逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.4.</span> <span class="toc-text">4. 赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">7.5.</span> <span class="toc-text">5. 运算符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">7.6.</span> <span class="toc-text">6. 字符串的常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.6.1.</span> <span class="toc-text">6.1 字符串大小写转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AE%B9"><span class="toc-number">7.6.2.</span> <span class="toc-text">6.2 判断字符串内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%9B%BF%E6%8D%A2"><span class="toc-number">7.6.3.</span> <span class="toc-text">6.3 字符串搜索定位与替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90"><span class="toc-number">7.6.4.</span> <span class="toc-text">6.4 文本对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%8E%BB%E9%99%A4%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">7.6.5.</span> <span class="toc-text">6.5 去除空白字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%81%94%E5%90%88%E4%B8%8E%E5%88%86%E5%89%B2"><span class="toc-number">7.6.6.</span> <span class="toc-text">6.6 字符串的联合与分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81"><span class="toc-number">7.6.7.</span> <span class="toc-text">6.7 字符串编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="toc-number">7.6.8.</span> <span class="toc-text">6.8 字符串切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA"><span class="toc-number">7.6.9.</span> <span class="toc-text">6.9 格式化字符串输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%89%88%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">7.6.9.1.</span> <span class="toc-text">新版格式化输出方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A7%E7%89%88%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">7.6.9.2.</span> <span class="toc-text">旧版格式化输出方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-Python-%E7%9A%84%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">7.6.10.</span> <span class="toc-text">6.10 Python 的转义字符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">七、条件分支</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-If-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">8.1.</span> <span class="toc-text">1. If 条件判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.2.</span> <span class="toc-text">2. 逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.3.</span> <span class="toc-text">3. 多分支语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E5%80%BC%E5%8C%BA%E9%97%B4%E5%88%A4%E6%96%AD"><span class="toc-number">8.4.</span> <span class="toc-text">4.  数值区间判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">8.5.</span> <span class="toc-text">5. 三元操作符&#x2F;三元表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%A8%A1%E5%9D%97"><span class="toc-number">8.6.</span> <span class="toc-text">补充：随机数模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">八、循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-while-%E8%AF%AD%E5%8F%A5%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">1. while 语句基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">9.2.</span> <span class="toc-text">2. 循环中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97"><span class="toc-number">9.3.</span> <span class="toc-text">3. 循环嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-for-%E9%81%8D%E5%8E%86%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.4.</span> <span class="toc-text">4. for 遍历循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-range-%E5%87%BD%E6%95%B0"><span class="toc-number">9.5.</span> <span class="toc-text">5. range 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">九、函数 - Function</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.</span> <span class="toc-text">1. 函数的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">2. 函数参数的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">10.3.</span> <span class="toc-text">3. 函数的文档注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC-return"><span class="toc-number">10.4.</span> <span class="toc-text">4. 函数的返回值 return</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9Aa%EF%BC%8Cb-%E5%80%BC%E4%BA%92%E6%8D%A2%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">10.5.</span> <span class="toc-text">补充：a，b 值互换面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.</span> <span class="toc-text">5. 其他函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dir-%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.1.</span> <span class="toc-text">dir() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chr-ord"><span class="toc-number">10.6.2.</span> <span class="toc-text">chr(), ord()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abs-%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.3.</span> <span class="toc-text">abs() 绝对值函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pow-%E5%B9%82%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.4.</span> <span class="toc-text">pow() 幂运算函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#max-%E6%9C%80%E5%A4%A7%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.5.</span> <span class="toc-text">max() 最大值函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-%E6%9C%80%E5%B0%8F%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.6.</span> <span class="toc-text">min() 最小值函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#round-%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.7.</span> <span class="toc-text">round() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#math-%E5%BA%93%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.8.</span> <span class="toc-text">math 库数学函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#floor-%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.8.1.</span> <span class="toc-text">floor() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ceil-%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.8.2.</span> <span class="toc-text">ceil() 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sqrt-%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.8.3.</span> <span class="toc-text">sqrt() 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0"><span class="toc-number">10.7.</span> <span class="toc-text">6. 嵌套函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-lambda"><span class="toc-number">10.8.</span> <span class="toc-text">7. 匿名函数 lambda</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">10.9.</span> <span class="toc-text">8. 递归函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">十、列表（list）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">11.1.</span> <span class="toc-text">1. 列表的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%97%E8%A1%A8%E7%9A%84%E5%8F%96%E5%80%BC"><span class="toc-number">11.2.</span> <span class="toc-text">2. 列表的取值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B7%BB%E5%8A%A0%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">11.3.</span> <span class="toc-text">3. 添加列表元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">11.4.</span> <span class="toc-text">4. 删除列表元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9F%A5%E7%9C%8B%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">11.5.</span> <span class="toc-text">5. 查看列表元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%97%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">11.6.</span> <span class="toc-text">6. 列表的排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A4%9A%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">11.7.</span> <span class="toc-text">7. 多个列表的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">11.8.</span> <span class="toc-text">8. 列表推导式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="toc-number">11.8.1.</span> <span class="toc-text">9. 字符串切片</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">十一、常量，元组（tuple）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84"><span class="toc-number">12.1.</span> <span class="toc-text">1. 创建元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E5%85%83%E7%BB%84"><span class="toc-number">12.2.</span> <span class="toc-text">2. 访问元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9%E5%85%83%E7%BB%84"><span class="toc-number">12.3.</span> <span class="toc-text">3. 修改元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E5%85%83%E7%BB%84"><span class="toc-number">12.4.</span> <span class="toc-text">4. 删除元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.5.</span> <span class="toc-text">5. 列表、元组、字符串互相转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.6.</span> <span class="toc-text">6. 应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">十二、字典（Dictionary）：Key+Value</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8"><span class="toc-number">13.1.</span> <span class="toc-text">1. 创建字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E5%85%B8%E7%9A%84%E5%8F%96%E5%80%BC"><span class="toc-number">13.2.</span> <span class="toc-text">2. 字典的取值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A2%9E%E5%8A%A0%E6%88%96%E4%BF%AE%E6%94%B9%E5%AD%97%E5%85%B8%E5%85%83%E7%B4%A0"><span class="toc-number">13.3.</span> <span class="toc-text">3. 增加或修改字典元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%9F%E8%AE%A1%E5%AD%97%E5%85%B8%E5%86%85%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F"><span class="toc-number">13.4.</span> <span class="toc-text">4. 统计字典内元素数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">13.5.</span> <span class="toc-text">5. 创建字典的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-dict"><span class="toc-number">13.5.1.</span> <span class="toc-text">5.1 dict()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-fromkeys"><span class="toc-number">13.5.2.</span> <span class="toc-text">5.2 fromkeys()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8-key-values-items"><span class="toc-number">13.6.</span> <span class="toc-text">6. 遍历字典 key(), values(), items()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%88%A4%E6%96%AD%E5%AD%97%E5%85%B8%E5%86%85%E5%85%83%E7%B4%A0"><span class="toc-number">13.7.</span> <span class="toc-text">7. 判断字典内元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%88%A0%E9%99%A4%E5%AD%97%E5%85%B8%E5%86%85%E5%85%83%E7%B4%A0"><span class="toc-number">13.8.</span> <span class="toc-text">8. 删除字典内元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%90%88%E5%B9%B6%E5%AD%97%E5%85%B8"><span class="toc-number">13.9.</span> <span class="toc-text">9. 合并字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">13.10.</span> <span class="toc-text">10. 字典推导式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">十三、集合（Set）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">十四、字符串、元素、列表、字典、集合的公共方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95"><span class="toc-number">15.1.</span> <span class="toc-text">1. 公共方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%87%E7%89%87"><span class="toc-number">15.2.</span> <span class="toc-text">2. 切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.3.</span> <span class="toc-text">3. 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">15.4.</span> <span class="toc-text">4. 遍历方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%AD%E4%BB%A3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">15.5.</span> <span class="toc-text">5. 迭代操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sorted-%E5%87%BD%E6%95%B0"><span class="toc-number">15.5.1.</span> <span class="toc-text">sorted() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter-%E5%87%BD%E6%95%B0"><span class="toc-number">15.5.2.</span> <span class="toc-text">filter() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">15.5.3.</span> <span class="toc-text">map()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce"><span class="toc-number">15.5.4.</span> <span class="toc-text">reduce()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">十五、全局变量、局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">16.1.</span> <span class="toc-text">1. 引用的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%AF%E5%8F%98%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.2.</span> <span class="toc-text">2. 可变和不可变类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">16.3.</span> <span class="toc-text">3. 局部变量和全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">16.3.1.</span> <span class="toc-text">3.1 局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-global-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">16.3.2.</span> <span class="toc-text">3.2 全局变量 global 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%92%8C%E5%8F%AF%E5%8F%98%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">16.4.</span> <span class="toc-text">4. 函数不可变和可变的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">16.5.</span> <span class="toc-text">5. 变量的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-number">16.6.</span> <span class="toc-text">6. 全局变量命名的建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">十六、面向对象OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">17.1.</span> <span class="toc-text">1. 面向对象概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">17.1.1.</span> <span class="toc-text">1.1 面向过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.1.2.</span> <span class="toc-text">1.2 面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">17.1.3.</span> <span class="toc-text">1.3 面向过程与面向对象的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.2.</span> <span class="toc-text">2. 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">17.2.1.</span> <span class="toc-text">2.1 类和对象的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E7%9A%84%E7%B1%BB"><span class="toc-number">17.2.2.</span> <span class="toc-text">2.2 定义简单的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.3.</span> <span class="toc-text">2.3 类的属性赋值方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%A4%96%E9%83%A8%E8%B5%8B%E5%80%BC"><span class="toc-number">17.2.3.1.</span> <span class="toc-text">2.3.1 外部赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%9C%A8%E5%86%85%E9%83%A8%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-number">17.2.3.2.</span> <span class="toc-text">2.3.2 在内部定义属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95-init"><span class="toc-number">17.2.3.3.</span> <span class="toc-text">2.3.3 初始化方法 _init_</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">17.2.4.</span> <span class="toc-text">2.4 内置方法和属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-del-%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.4.1.</span> <span class="toc-text">2.4.1 _del_ 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-str-%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.4.2.</span> <span class="toc-text">2.4.2 _str_ 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">17.2.5.</span> <span class="toc-text">2.5 类的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E8%BA%AB%E4%BB%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">17.2.6.</span> <span class="toc-text">2.6 身份运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.7.</span> <span class="toc-text">2.7 私有属性和私有方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">17.2.8.</span> <span class="toc-text">2.8 类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">17.2.8.1.</span> <span class="toc-text">2.8.1 类的继承的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">17.2.8.2.</span> <span class="toc-text">2.8.2 方法的重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-3-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">17.2.8.3.</span> <span class="toc-text">2.8.3 多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-4-%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.8.4.</span> <span class="toc-text">2.8.4 父类的私有属性和私有方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E5%A4%9A%E6%80%81"><span class="toc-number">17.2.9.</span> <span class="toc-text">2.9 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.10.</span> <span class="toc-text">2.10 类方法和类的静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3BIF"><span class="toc-number">17.2.11.</span> <span class="toc-text">2.11 类、对象相关BIF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-%E5%8D%95%E4%BE%8B"><span class="toc-number">17.2.12.</span> <span class="toc-text">2.12 单例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.3.</span> <span class="toc-text">3. 可迭代对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-zip-%E5%87%BD%E6%95%B0"><span class="toc-number">17.3.1.</span> <span class="toc-text">3.1 zip 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-enumerate-%E5%87%BD%E6%95%B0"><span class="toc-number">17.3.2.</span> <span class="toc-text">3.2 enumerate 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">17.4.</span> <span class="toc-text">4. 生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%8E%A8%E5%AF%BC%E5%BC%8F%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">17.4.1.</span> <span class="toc-text">4.1 推导式生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%87%BD%E6%95%B0-yield"><span class="toc-number">17.4.2.</span> <span class="toc-text">4.2 函数 + yield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">17.4.3.</span> <span class="toc-text">4.3 迭代器和生成器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">十七、异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E7%9A%84%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E8%AF%AD%E6%B3%95"><span class="toc-number">18.1.</span> <span class="toc-text">1. 简单的捕获异常语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%BC%94%E7%BB%83"><span class="toc-number">18.2.</span> <span class="toc-text">2. 简单异常捕获演练</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">18.2.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AE%8C%E6%95%B4%E5%86%99%E6%B3%95"><span class="toc-number">18.3.</span> <span class="toc-text">3. 异常处理完整写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%E6%8D%95%E8%8E%B7"><span class="toc-number">18.4.</span> <span class="toc-text">4. 错误类型捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8D%95%E8%8E%B7%E6%9C%AA%E7%9F%A5%E9%94%99%E8%AF%AF"><span class="toc-number">18.5.</span> <span class="toc-text">5. 捕获未知错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">18.6.</span> <span class="toc-text">6. 异常的传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">18.7.</span> <span class="toc-text">7. 抛出异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text">十八、模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97"><span class="toc-number">19.1.</span> <span class="toc-text">1. 什么是模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">19.2.</span> <span class="toc-text">2. 导入模块的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"><span class="toc-number">19.3.</span> <span class="toc-text">3. 创建一个模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%A8%A1%E5%9D%97%E7%9A%84%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F"><span class="toc-number">19.4.</span> <span class="toc-text">4. 模块的搜索顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">19.5.</span> <span class="toc-text">5. 查看模块的使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A8%A1%E5%9D%97%E5%86%85%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">19.6.</span> <span class="toc-text">6. 模块内测试代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8C%85-Package"><span class="toc-number">19.7.</span> <span class="toc-text">7. 包 Package</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-pip-%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97"><span class="toc-number">19.8.</span> <span class="toc-text">8. pip 安装第三方模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pycharm-%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97"><span class="toc-number">19.8.0.1.</span> <span class="toc-text">Pycharm 安装模块</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">20.</span> <span class="toc-text">十九、文件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">20.1.</span> <span class="toc-text">1. 文件的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0-%E6%96%B9%E6%B3%95"><span class="toc-number">20.2.</span> <span class="toc-text">2. 操作文件的函数&#x2F;方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6-read"><span class="toc-number">20.3.</span> <span class="toc-text">3. 读取文件 read()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.4.</span> <span class="toc-text">4. 打开文件模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-with-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">20.4.1.</span> <span class="toc-text">4.1 with 上下文管理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">20.5.</span> <span class="toc-text">5. 写入文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8C%89%E8%A1%8C%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6-readline"><span class="toc-number">20.6.</span> <span class="toc-text">6. 按行读取文件 readline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">20.7.</span> <span class="toc-text">7. 复制文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">20.8.</span> <span class="toc-text">文件对象的其他方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%97%B6%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84-GBK-%E9%94%99%E8%AF%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">20.9.</span> <span class="toc-text">文件读取时经常出现的 GBK 错误是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-OS-%E6%A8%A1%E5%9D%97"><span class="toc-number">20.10.</span> <span class="toc-text">8. OS 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">20.11.</span> <span class="toc-text">8.1 文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">20.12.</span> <span class="toc-text">8.2 目录操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C"><span class="toc-number">20.13.</span> <span class="toc-text">8.3 路径操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95-%E6%96%87%E4%BB%B6"><span class="toc-number">20.14.</span> <span class="toc-text">8.4 遍历目录&#x2F;文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">20.15.</span> <span class="toc-text">8.5 调用外部命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">21.</span> <span class="toc-text">二十、eval 函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">22.</span> <span class="toc-text">定时任务</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 善良的xwysyy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="refresh-cache" type="button" title="刷新缓存" onclick="refreshCache()"><i class="fas fa-refresh"></i></button><button type="button" title="切换背景" onclick="toggleWinbox()"><i class="fas fa-display"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="/js/cursor.js" async></script><script src="/js/jquery.js"></script><script src="/js/foot.js"></script><script defer src="/live2d-widget-master/autoload.js"></script><script async data-pjax src="/js/txmap.js"></script><script async data-pjax src="/js/bb.js"></script><script async data-pjax src="/js/waterfall.js"></script><script src="/js/background.js"></script><script data-pjax>obcboPic()</script><script src="/js/weather.js"></script><script src="http://fw.qq.com/ipaddress"></script><script src="/js/visitor.js"></script><script src="/js/weibo.js"></script><script src="/js/rightside_button1.js"></script><script src="/js/rightside_button2.js"></script><div id="fps"></div><script async data-pjax src="/js/music1.js"></script><script async data-pjax src="/js/music2.js"></script><script async src="/js/music3.js"></script><script src="/js/refresh.js"></script><script src="/js/console.js"></script><script src="/js/pace.js"></script><script src="/js/welcome.js"></script><canvas id="universe"></canvas><script src="/js/universe.js"></script><script src="/js/nav.js"></script><script src="/js/sun_moon.js" async></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="cf题补了吗,ddl赶了吗,考试复习了吗,看完赶紧去学习,上课别看了" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="/css/aplayer.css" media="print" onload="this.media='all'"><script src="/js/aplayer.js"></script><script src="/js/meting.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()"> </div><meting-js id="8265539094" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="contact-info"><div class="option"><i class="fas fa-warning"> </i><div class="bloktop"></div><div class="text"><div class="strip"></div><div class="aside_notice"><h1>警钟长鸣</h1><br>严禁将重要信息（如：key、token、cookie）、标识性信息、隐私性信息上传 <center><h3>遵守网络法规</h3><h3>保护信息安全</h3><h3>尊重个人意愿</h3><h3>警惕隐私泄露</h3><h2>铭记：</h2><h3>源代码面前无秘密</h3><h3>网络流量面前无秘密</h3></center></div></div></div><div class="option"><i class="fas fa-cube"></i><div class="blok"></div><div class="text"><div class="strip"></div><div class="post-reward"><div class="reward-button"><i class="fa-solid fa-bolt"></i></div><div class="reward-main">
<ul class="reward-all">
<li class="reward-item"><a href="https://Li-j-z.github.io" target="_blank">
<img class="post-qr-code-img entered loaded" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64181ed4a682492fccdf27fa.jpg" alt="Li-j-z的魔方小站"></a>
<div class="post-qr-code-desc">Li-j-z的魔方小站</div></li>
<li class="reward-item"><a href="https://www.cnblogs.com/xwysyy/" target="_blank">
<img class="post-qr-code-img entered loaded" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6432d8ed0d2dde5777c73749.png" alt="xwysyy博客园"></a>
<div class="post-qr-code-desc">xwysyy博客园</div></li>
</ul></div></div></div></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.7.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a><a class="github-badge" target="_blank" href="https://cloud.tencent.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路部署于腾讯云" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-%E8%85%BE%E8%AE%AF%E4%BA%91-pink?style=flat&amp;logo=tencentqq" alt=""/></a><a class="github-badge" target="_blank" href="https://www.xwysyy.cn/" style="margin-inline:5px" data-title="rating" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://codeforces-readme-api.xwysyy.cn/api/badge?username=kmsgk" alt=""/></a><a class="github-badge" target="_blank" href="https://www.xwysyy.cn/" style="margin-inline:5px" data-title="rating" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://codeforces-readme-api.xwysyy.cn/api/badge?username=xwysyy" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/" style="margin-inline:5px" data-title="萌ICP备20232640号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20232640-fe1384?style-flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAAByxJREFUSInl1nlwVeUZx/HPuTckkD0kQFiCEEIUlNUCAqKoSBV1AIt1ikpVLFbLONjWGUXbmWrbweJMy7hUxbbTjsUq6KCiWEvr0kE2WVK2QCKBJCxJgEASsienfxwqMob+3Zm+f93z3vM+32f5vc9z+H9bwVcfOp/YQ+1prhhEZS1VDQzqQ1MjiQmIC5Liwm3lBWpqFimrulb/7A/067vM2IsOBZ2h8MhJQW6KMDNVsKeaizKEyUlsKueqgWJ39AMJF3QpDCNYr1SaEig/lWNX2Z1h6dH5/lVyGdVIZFf7MHo9bEfh9rCg/+8NyHlN77QTsnpQ0i2y08VK+BosfhbW0cHxqmSfFd9qW+l9Pi+5WltFdGTsOBbO5dJcdh3lN5+xff0Y2zuelXjRsyYUrjOu4BVJaavlpbWIJRBLOM+J81O95AAnTtM9vNHGknut3zdT48FutJE3koWTuG4oSXH+VsInX3B9IdcVUNfCuv08t4GjO6NspOa3BNcOXx1eOugVHQnrTMkTuyWrC/BjRZO9uPYTpw7HhTWkXcLd45l9GblpHD7NWzt5ZTMXZ/OdkTy+lvR07rmcmWffq6pn9W5e/oymfcT6kJbXHiydMyVYkL/x66n+ZMcctQfjhgxl6UIGZ3Ooltd2RIZqjqKRS0ew9cFIA1cO5urlLHuPZWsZPJiZw7gqn0VT2HCIR9+jvCQhfHPrLGyE2Hng2roBxHnmJoZnc9drbD3I6QaaWkjpSVoeu4+x5XB05qMDqCenHz37UHmcFRv54ZuMeoYrB/L0DPRgZ0WfrsXVKzPX3nYykrn3dUZl8+Q0Qox/gc/L6ZlKzxQefo+UROpa6Z4VCedkPd8YyJYHI3u5T/HAShZNQxsXZfR3pCtwRW066VEeOuIUVUf77+9jTw2pycTOJml7Je1t9EgiI5X2jkgyze1fCSSdtjhBiJCkpKyuI+5oTdAtkTCgVwrbKsl8ko6QjO40tZ67EpkpdIbRf20dkbPpPTjdwsSX6I5dJYy4hoQAaZQdDy4A1iEMI613T6LtBPXJpPakrjGqc1Y6CTFq62htJp5KRwPJKWSkU3WKiiPEEqO6xgM6oZmctJhDXYH7Z59xuCyKpK6R26ZE+ys3MWYoN1/Mc5uoqmbEQJ6fTc/ulJ3i/lUc+YIfzeKhKzjVHN31A3XRHddKSrf6/6DOV3VTcw1hVKfkxOhaPDAe1UwfwmNTqT1Drxw+nE9xNXetIjHG2vnoxoT+rNrN2Of58Rp6JZ+ldKes5kjX4G7dKuikpoERfaltYnQ/DOSS3hEAFk9lXQkLnmf7Ib65lPJT3HU1+46Tm8rYvgzKYVA2h+vQIMjvewHwdSN20MiOSmZczO4a1hSzYi77T7CiiPF5JMTZexjJ5OagkwNV9M+MnJ09nKU3smgyQ3PYWoEO4fUjii4QceJmevJuMeP6csUAln4atcbSGoqOUpjD30uZNwnpHNtN3lC+NZa1xeT34pGVTJ3PL9+Ohs6GQ8gVtHZs6VLVwZhBReGwoXvt3THM/hP0SWVnCR8f4PMjkffjB/DQS8waxpHFfFgaaeHZDRRtJn0yP5tF31ymFVJ2nN27GD66KBzca2/XEWdkUpD3Fmd4tYj0FMS54Q9UnuaDUv6yE/24ewWP/DU6N/d1fvousYEs28DyLVEvGDOAt/egmSkXv2VYn3NBfpXbua6J8hMFFvy2RHsL+57gmX+w/AN651PfEDWQzLRI+afqIqOxFDJT6Rbn9Bmad3PnTH5wIxOXkJTWGiz57hCDsyqDWVldRNzeyOh+paaPfpFKnvqQX88iZwDVx0lLJqUHbe3EkZ1Odm+yUqK2GHYKmhvIG8fyeTz9IY5x67jnFPapdPDkl6jzwEF9IDjZJlgwfbG+o2u8+g4rd7D/UYI41TXnevV5K4j2q6uESckUP8rvNrH6fUH/sRXB9AlPONMSDZ8uazwoi56JjEyvdftV88jinhf4uIzmJRQOoOYgja0RKAiIBZxpjvZH5tP0c97axcLlyBXOuWZemJTYFFbUCU+1dl3j8PGSyFhnJ7EkYcWh7/njqpep5xfzWTyZZ7dEg73xOJKiGqf3YenNLBjLTz7i539COg/OvSOYO2GFo/VRG0Zwe0YX4Ns3R7NXSCxBeM8IthXfZvGf3xCWc/kkXvg2vVP4YB/rDzC1gGlDo+50/xvs2khKPrNnzAzmTH5HbzR0fkkKro93Ab5vx9kfaGgT3lLA5EyWbRpoTdHbSreOppGJV/PwlRTksK+aZz5l6z+RLBgxaau5k2cJelTKzmRQMq0d51J8UxL+23d1TDTcj7WQllZu4YwxDo+eZc22X9mwd6gN65GIFmQzampxcMOoR1xeuMbpVoqromsXdG3+wmCiekNtfSSmiUNWu2zgap+WjlZW8X11TeNkpWwICvNfCm8u3Cmxg4PN0VdmEJw7/7+0/g32RaqCbhRecAAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" style="margin-inline:5px" data-title="本网站由又拍云提供CDN加速/云存储服务" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-%E5%8F%88%E6%8B%8D%E4%BA%91-00b6ff?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAABs1JREFUSInllv2PVFcZxz/n3LfZmdmd3ZndZWGhhV0qYLaFEgzQpog12tZYbVRCSa00mLap6Q+aNERp5QcVlRhi0GjaGElromI08aU1tMRXWmspRaEVbIDtdimwy77M7uy83Xvn3nP84c7b7oD/QE8yyT13znO/z/f7nOcF3m9L1B4OnNYYEoSG165kGZkukLLjdEmXiew4yum7+4qK31u2rduLFXOgEEoQCrQs9RjepaW2f35Nu/9QqRh4Fi4jrkHCMmhTitlCBcOIoP768CoAzGt5owFLQBKfad/Yflau+Mo4qY0IE8qAUbXUgKT9ctFZVJAzqzcivLN+/JGY0H6HKD0riKGvw7gFWAFtUmMTyFPF5C+Gded2LBmBaB2BAigRyeMJ0jGPgxtiyX+MtW18/ZL1DLEMK/TER9eb+Z2GQGU1CK0b8gKy9uCYYJmQcUCgUm+U0qeGw/R2pIwAdbPvAiE0aAGux0MDc7eJAJ57V7+GZYAQjLDo8yd0z6lAqQ5bBbh+iF8JWxmP5XwSJrhCyz9NJU7mdHwwknOBWEKAAq0EuIrPrKp8d3lb+M/HT/qvlsN2pKNRSoDUXAxSN+eKlWMPD7jrFi3pZc4NeHUh4+zcNMW5q/z47dLhi4X4IHYt2hFDBBFDpUmYJXoNb+y23tzPHlgRfu2F8bZ9s4W2zdgSpap2OopbzsysPUHX85YIcdU1YnxLX5pT0+59w+X4NqwmpgIIgUCxNF4+vsaY2bsknjtq+yYTnsGhMx33H8127SFp03KTBBAT/H3U+qTIZe9ambFfagHOl0OOjJs/wjCZdwtCARI2d899Z0iP7Rkv2J0ngu49xUCvu1R2+sJS6g4MAyF11deasY5+CjBs3jE6f3KrMXlDC/Cfr0xuuegtWYIpmjwXUA7YcbP69tb2ypPfO5naPyJ7d4fKioLUDihdVxZEpI4ApGiEyoKLM8aydyx5J/CXeTE+m5PbkFZV4qpBoPlAJnh7R7rw5G8vm9+/4PfvDg0rSiMdgYraeQ0xGVZu78o9tSUx9ViK0pUGc0CbTNtdu1oYG7Geu+vFAaLbqz0+3B1sf2WKnhcvJ79MvCn21JiKiGIAt6amn9scK+4brpiskOHMKRU/jCSS2xG8ddVbVcOrM54KrBvqoERyO4YqLTaKb76ct7+JtufHfuEyYKIkeoKKpN12ySs1QF28qkJmrL8FuBwqv7HTEELC4b/Fks/EjPgcDq05TeO8EJrhSten35KLDjpmhfd8/QBNYY6clp0twC1LAmGQLJdyCF08gub/MtYCECZni+JBTyYwrKS7ML2UbrxplEwpHeoJHkk9IPO/z3QluKen/GC/MXuM8PrIQkc3+sY298hAwsIQbSvnAWuwpSq3AGesyhhh08EwZKBdHi+EDjEkyxLBm9dtNYjqXx5DTnHvsCeXFCoi1fh6VPEsEYy3ACf1zN9qlRE0whAcdzM/GCk5Hz+W1dv+U0jubFy+aqdpFsCD9en8r4ba9fDLU6mfI8wo7Zqc65Ccru3q6dQtC79EVb6AUc1lQzJakP2jOvUSZrqKUgu0QMvqNgBkyOpk7ndfXKruP+11Pf5uwdgqHYWqHwIIGTTLh88tBN7a3/3i+VF/ZtyzujAFut57a0d0A1sDpdzoUkfMdCTNs4Pm3MG1nfL1Fy7bjxwtxn6IXfOzauNDZ6w8u67Pf/7IQuDB3hSfCMtPHDoX/hTDaJKxXgzR1ca/PjnzxOL47IGgXOYG2+U9f/Gyw1Op31yYsz6LKcEEpZryyPe5d1B+dWnf4rrwdeATo+P0yfBQr53cOVHp2oIjWpo/LgwlZp/etdo78MeJ9DeO5cUmM+fflNcdy9E2ONGkoWvZIQSUFGt63ZNb+hPPzPr1S9KUTlYndizDl1Zan+qOlXNUqobVD2gPMubcyP4PlR57Ix979MhI+9fLRsfH8qJ7OYYNhkZo1dRfNATQ3ebmdq2073KFQTmgFfjG7jjprjgrMsncPb2FDXEKkwRV8BCEGbD7g2LNmdnYwLPn257Gro6kNMaixlQlwJckVXbyvszsBseJTU+VqA4JC4DdisavwNUy2Ia4sCk5OdRvzLxCBXAVj64NdvTGtbf337ETaBvMa3V9EQ2BFbgpkf/XnbHpIUuHF2YrYMqGgPNi3OxJIZQgjYmNidIdYwHfyjpZ3ZGtHN6fXXbOVfE0MebncHXMAUiL4uRHlpQP3pJW+04OC3KhST+tw8k152oJeEpQNGxWx0tP+WGeK0Xbcb3SWCYpTS80ul0lECi0EF6n8LNJOzjThvuHobj/603dTnFcORQDQcf1y937bP0Pc6b8FW3Czt0AAAAASUVORK5CYII=" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" style="margin-inline:5px" data-title="冀ICP备2023010011号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E5%86%80ICP%E5%A4%87-2023010011%E5%8F%B7-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13060602001624" style="margin-inline:5px" data-title="冀公网安备13060602001624号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E5%86%80%E5%85%AC%E7%BD%91%E5%AE%89%E5%A4%87-13060602001624%E5%8F%B7-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;tutorial/Codeforces(1800-1899)/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/27.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;tutorial/Codeforces(1800-1899)/&quot;);" href="javascript:void(0);" alt="">Codeforces(1848-1899)</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;tutorial/Codeforces(1800-1899)/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;algorithm/xwysyy Algorithm/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/19.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;algorithm/xwysyy Algorithm/&quot;);" href="javascript:void(0);" alt="">xwysyy Algorithm</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;algorithm/xwysyy Algorithm/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;syntax/LaTeX/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/img-background/44.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;syntax/LaTeX/&quot;);" href="javascript:void(0);" alt="">LaTeX</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;syntax/LaTeX/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:24%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/course/&quot;);" href="javascript:void(0);">course</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/algorithm/&quot;);" href="javascript:void(0);">algorithm</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/syntax/&quot;);" href="javascript:void(0);">syntax</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/tutorial/&quot;);" href="javascript:void(0);">tutorial</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/note/&quot;);" href="javascript:void(0);">note</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/project/&quot;);" href="javascript:void(0);">project</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CPP/&quot;);" href="javascript:void(0);">CPP</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>